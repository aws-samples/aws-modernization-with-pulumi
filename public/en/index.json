[
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/20_getting_started_with_pulumi/1_new_project.html",
	"title": "1.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Infrastructure in Pulumi is organized into projects. Each project is a single program that, when run, declares the desired infrastructure for Pulumi to manage.\nStep 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir iac-workshop cd iac-workshop Pulumi will use the directory name as your project name by default. You can change this during the project initiation process, but we\u0026rsquo;ll stick with the default for now.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible to create a new one by hand, but pulumi new command automates the process:\npulumi new typescript -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;iac-workshop\u0026#39; Please enter your desired stack name. To create a stack in an organization, use the format \u0026lt;org-name\u0026gt;/\u0026lt;stack-name\u0026gt; (e.g. `acmecorp/dev`). Created stack \u0026#39;dev\u0026#39; Installing dependencies... This output will be followed by some npm output. Once that\u0026rsquo;s done, the command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from npmjs.\nStep 3 — Inspect Your New Project Our project is comprised of multiple files:\nPulumi.yaml: your project\u0026rsquo;s metadata, containing its name and language index.ts: your program\u0026rsquo;s main entrypoint file node_modules/: your program\u0026rsquo;s npm dependencies package.json and package-lock.json: your project\u0026rsquo;s npm dependency information tsconfig.json: your project\u0026rsquo;s TypeScript configuration Run cat index.ts to see the contents of your project\u0026rsquo;s empty program:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; Feel free to explore the other files, although we won\u0026rsquo;t be editing any of them by hand.\n"
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python/20_getting_started_with_pulumi/1_new_project.html",
	"title": "1.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Infrastructure in Pulumi is organized into projects. Each project is a single program that, when run, declares the desired infrastructure for Pulumi to manage.\nStep 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir iac-workshop cd iac-workshop Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new python -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;iac-workshop\u0026#39; Created stack \u0026#39;dev\u0026#39; Saved config Installing dependencies... Finished installing dependencies Your new project is ready to go! This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from PyPi.\nStep 3 — Inspect Your New Project Our project is comprised of multiple files:\n__main__.py: your program\u0026rsquo;s main entrypoint file requirements.txt: your project\u0026rsquo;s Python dependency information Pulumi.yaml: your project\u0026rsquo;s metadata, containing its name and language venv: a virtualenv for your project Run cat __main__.py to see the contents of your project\u0026rsquo;s empty program:\n\u0026#34;\u0026#34;\u0026#34;A Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi Feel free to explore the other files, although we won\u0026rsquo;t be editing any of them by hand aside from requirements.txt.\n"
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java/20_getting_started_with_pulumi/1_new_project.html",
	"title": "1.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Infrastructure in Pulumi is organized into projects. Each project is a single program that, when run, declares the desired infrastructure for Pulumi to manage.\nStep 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir iac-workshop cd iac-workshop Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new java -y This will print output similar to the following with a bit more information and status as it goes:\nThis command will walk you through creating a new Pulumi project. Enter a value or leave blank to accept the (default), and press \u0026lt;ENTER\u0026gt;. Press ^C at any time to quit. project name: (iac-workshop) project description: (A minimal Java Pulumi program with Maven builds) Created project \u0026#39;iac-workshop\u0026#39; Please enter your desired stack name. To create a stack in an organization, use the format \u0026lt;org-name\u0026gt;/\u0026lt;stack-name\u0026gt; (e.g. `acmecorp/dev`). stack name: (dev) Created stack \u0026#39;dev\u0026#39; Your new project is ready to go! ✨ To perform an initial deployment, run \u0026#39;pulumi up\u0026#39; This command initializes a new Pulumi stack named dev (an instance of our project) and generates a Maven project template. You can also use Gradle build tool if you prefer by simply typing\npulumi new java-gradle -y Step 3 — Inspect Your New Project Our project is composed of multiple files:\nsrc/main/java/myproject/App.java: your program\u0026rsquo;s main entrypoint file pom.xml: Maven xml file describing your project Pulumi.yaml: your project\u0026rsquo;s metadata, containing its name and language Run cat src/main/java/myproject/App.java to see the contents of your project\u0026rsquo;s empty program:\npackage myproject; import com.pulumi.Pulumi; import com.pulumi.core.Output; public class App { public static void main(String[] args) { Pulumi.run(ctx -\u0026gt; { ctx.export(\u0026#34;exampleOutput\u0026#34;, Output.of(\u0026#34;example\u0026#34;)); }); } } "
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java/30_deploying_webservers/1_new_project.html",
	"title": "1.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Infrastructure in Pulumi is organized into projects. Each project is a single program that, when run, declares the desired infrastructure for Pulumi to manage.\nStep 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir iac-workshop-webservers cd iac-workshop-webservers Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new java This will print output similar to the following with a bit more information and status as it goes:\nThis command will walk you through creating a new Pulumi project. Enter a value or leave blank to accept the (default), and press \u0026lt;ENTER\u0026gt;. Press ^C at any time to quit. project name: (iac-workshop-webservers) project description: (A minimal Java Pulumi program with Maven builds) Created project \u0026#39;iac-workshop-webservers\u0026#39; Please enter your desired stack name. To create a stack in an organization, use the format \u0026lt;org-name\u0026gt;/\u0026lt;stack-name\u0026gt; (e.g. `acmecorp/dev`). stack name: (dev) Created stack \u0026#39;dev\u0026#39; Your new project is ready to go! ✨ To perform an initial deployment, run \u0026#39;pulumi up\u0026#39; This command initializes a new Pulumi stack named dev (an instance of our project) and generates a Maven project template. You can also use Gradle build tool if you prefer by simply typing\npulumi new java-gradle -y Step 3 — Inspect Your New Project Our project is composed of multiple files:\nsrc/main/java/myproject/App.java: your program\u0026rsquo;s main entrypoint file pom.xml: Maven xml file describing your project Pulumi.yaml: your project\u0026rsquo;s metadata, containing its name and language Run cat src/main/java/myproject/App.java to see the contents of your project\u0026rsquo;s empty program:\npackage myproject; import com.pulumi.Pulumi; import com.pulumi.core.Output; public class App { public static void main(String[] args) { Pulumi.run(ctx -\u0026gt; { ctx.export(\u0026#34;exampleOutput\u0026#34;, Output.of(\u0026#34;example\u0026#34;)); }); } } Step 4 — Add AWS Dependencies Before we continue, we need to include AWS dependencies. You can do it by editing your pom.xml file. Find the dependencies section and add the following entries:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-native\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.16.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Also, ensure that the properties section references Java 17 as we will be using constructs available on newer versions.\nYour pom.xml file should look like the following:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;iac-workshop-webserver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.release\u0026gt;17\u0026lt;/maven.compiler.release\u0026gt; \u0026lt;mainClass\u0026gt;myproject.App\u0026lt;/mainClass\u0026gt; \u0026lt;mainArgs/\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pulumi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-native\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.16.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;addClasspath\u0026gt;true\u0026lt;/addClasspath\u0026gt; \u0026lt;mainClass\u0026gt;${mainClass}\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-assembly-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;addClasspath\u0026gt;true\u0026lt;/addClasspath\u0026gt; \u0026lt;mainClass\u0026gt;${mainClass}\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;descriptorRefs\u0026gt; \u0026lt;descriptorRef\u0026gt;jar-with-dependencies\u0026lt;/descriptorRef\u0026gt; \u0026lt;/descriptorRefs\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;make-my-jar-with-dependencies\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;single\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.codehaus.mojo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;exec-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;mainClass\u0026gt;${mainClass}\u0026lt;/mainClass\u0026gt; \u0026lt;commandlineArgs\u0026gt;${mainArgs}\u0026lt;/commandlineArgs\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-wrapper-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;mavenVersion\u0026gt;3.8.5\u0026lt;/mavenVersion\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; Step 5 — Configure an AWS Region Finally, set up your Pulumi configurations:\npulumi config set aws:region us-west-2 Step 6 — Configure an AWS Profile As with the first module, if you are using an alternative AWS profile, tell Pulumi which one to use by one of the following options:\nUsing an environment variable: export AWS_PROFILE=\u0026lt;profile name\u0026gt; Using configuration: pulumi config set aws:profile \u0026lt;profile name\u0026gt; "
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java/40_ecs/1_new_project.html",
	"title": "1.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Infrastructure in Pulumi is organized into projects. Each project is a single program that, when run, declares the desired infrastructure for Pulumi to manage.\nStep 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir iac-workshop-ecs cd iac-workshop-ecs Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new java -y This will print output similar to the following with a bit more information and status as it goes:\nThis command will walk you through creating a new Pulumi project. Enter a value or leave blank to accept the (default), and press \u0026lt;ENTER\u0026gt;. Press ^C at any time to quit. project name: (iac-workshop-ecs) project description: (A minimal Java Pulumi program with Maven builds) Created project \u0026#39;iac-workshop\u0026#39; Please enter your desired stack name. To create a stack in an organization, use the format \u0026lt;org-name\u0026gt;/\u0026lt;stack-name\u0026gt; (e.g. `acmecorp/dev`). stack name: (dev) Created stack \u0026#39;dev\u0026#39; Your new project is ready to go! ✨ To perform an initial deployment, run \u0026#39;pulumi up\u0026#39; This command initializes a new Pulumi stack named dev (an instance of our project) and generates a Maven project template. You can also use Gradle build tool if you prefer by simply typing\npulumi new java-gradle -y Step 3 — Inspect Your New Project Our project is composed of multiple files:\nsrc/main/java/myproject/App.java: your program\u0026rsquo;s main entrypoint file pom.xml: Maven xml file describing your project Pulumi.yaml: your project\u0026rsquo;s metadata, containing its name and language Run cat src/main/java/myproject/App.java to see the contents of your project\u0026rsquo;s empty program:\npackage myproject; import com.pulumi.Pulumi; import com.pulumi.core.Output; public class App { public static void main(String[] args) { Pulumi.run(ctx -\u0026gt; { ctx.export(\u0026#34;exampleOutput\u0026#34;, Output.of(\u0026#34;example\u0026#34;)); }); } } "
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts/20_getting_started_with_pulumi/1_new_project.html",
	"title": "1.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Infrastructure in Pulumi is organized into projects. Each project is a single program that, when run, declares the desired infrastructure for Pulumi to manage.\nStep 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir simple-lambda-function cd simple-lambda-function Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new typescript -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;simple-lambda-function\u0026#39; Created stack \u0026#39;dev\u0026#39; Saved config Installing dependencies... Finished installing dependencies Your new project is ready to go! This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from NPM.\nStep 3 — Inspect Your New Project Our project is comprised of multiple files:\nindex.ts: your program\u0026rsquo;s main entrypoint file package.json and package-lock.json: your project\u0026rsquo;s NPM dependency information Pulumi.yaml: your project\u0026rsquo;s metadata, containing its name and language tsconfig.json: your project\u0026rsquo;s TypeScript settings node_modules/: a directory containing your project\u0026rsquo;s installed NPM dependencies Run cat index.ts to see the contents of your project\u0026rsquo;s empty program:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; Feel free to explore the other files, although we won\u0026rsquo;t be editing any of them by hand.\n"
},
{
	"uri": "//localhost:1313/en/50_eks_platform/20_provision_cluster/1_new_project.html",
	"title": "1.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Infrastructure in Pulumi is organized into projects. Each project is a single program that, when run, declares the desired infrastructure for Pulumi to manage.\nStep 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir workshop-cluster cd workshop-cluster Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new typescript -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;workshop-cluster\u0026#39; Created stack \u0026#39;dev\u0026#39; Saved config Installing dependencies... Finished installing dependencies Your new project is ready to go! This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from NPM.\nStep 3 — Inspect Your New Project Our project is comprised of multiple files:\nindex.ts: your program\u0026rsquo;s main entrypoint file package.json and package-lock.json: your project\u0026rsquo;s NPM dependency information Pulumi.yaml: your project\u0026rsquo;s metadata, containing its name and language tsconfig.json: your project\u0026rsquo;s TypeScript settings node_modules/: a directory containing your project\u0026rsquo;s installed NPM dependencies Run cat index.ts to see the contents of your project\u0026rsquo;s empty program:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; Feel free to explore the other files, although we won\u0026rsquo;t be editing any of them by hand.\n"
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/30_deploying_eks_cluster/1_new_project.html",
	"title": "2.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Step 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir eks-infrastructure cd eks-infrastructure Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new typescript -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;eks-infrastructure\u0026#39; Created stack \u0026#39;dev\u0026#39; Saved config Installing dependencies... Finished installing dependencies Your new project is ready to go! This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from NPM.\nStep 3 — Install pulumi-eks and pulumi-awsx Packages Run the following commands to install the packages:\nnpm install @pulumi/eks npm install @pulumi/awsx The packages will be added to node_modules, package.json, and package-lock.json.\nStep 4 — Setting AWS Region Configure the AWS region you would like to deploy to:\npulumi config set aws:region us-west-2 Feel free to choose any AWS region.\n"
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/30_deploying_webservers/1_new_project.html",
	"title": "2.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Infrastructure in Pulumi is organized into projects. Each project is a single program that, when run, declares the desired infrastructure for Pulumi to manage.\nStep 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir iac-workshop-webservers cd iac-workshop-webservers Pulumi will use the directory name as your project name by default. You can change this during the project initiation process, but we\u0026rsquo;ll stick with the default for now.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new aws-python -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;iac-workshop-webservers\u0026#39; Created stack \u0026#39;dev\u0026#39; Saved config Installing dependencies... Finished installing dependencies Your new project is ready to go! This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from PyPi.\nStep 3 — Inspect Your New Project Our project is comprised of multiple files:\n__main__.py: your program\u0026rsquo;s main entrypoint file requirements.txt: your project\u0026rsquo;s Python dependency information Pulumi.yaml: your project\u0026rsquo;s metadata, containing its name and language venv: a virtualenv for your project Run cat __main__.py to see the contents of your project\u0026rsquo;s empty program:\n\u0026#34;\u0026#34;\u0026#34;An AWS Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi from pulumi_aws import s3 # Create an AWS resource (S3 Bucket) bucket = s3.Bucket(\u0026#39;my-bucket\u0026#39;) # Export the name of the bucket pulumi.export(\u0026#39;bucket_name\u0026#39;, bucket.id) Feel free to explore the other files, although we won\u0026rsquo;t be editing any of them by hand.\nStep 4 — Configure an AWS Region Configure the AWS region you would like to deploy to:\npulumi config set aws:region us-west-2 "
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python/30_deploying_webservers/1_new_project.html",
	"title": "2.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Infrastructure in Pulumi is organized into projects. Each project is a single program that, when run, declares the desired infrastructure for Pulumi to manage.\nStep 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir iac-workshop-webservers cd iac-workshop-webservers Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new aws-python -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;iac-workshop-webservers\u0026#39; Created stack \u0026#39;dev\u0026#39; Saved config Installing dependencies... Finished installing dependencies Your new project is ready to go! This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from PyPi.\nStep 3 — Inspect Your New Project Our project is comprised of multiple files:\n__main__.py: your program\u0026rsquo;s main entrypoint file requirements.txt: your project\u0026rsquo;s Python dependency information Pulumi.yaml: your project\u0026rsquo;s metadata, containing its name and language venv: a virtualenv for your project Run cat __main__.py to see the contents of your project\u0026rsquo;s empty program:\n\u0026#34;\u0026#34;\u0026#34;An AWS Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi from pulumi_aws import s3 # Create an AWS resource (S3 Bucket) bucket = s3.Bucket(\u0026#39;my-bucket\u0026#39;) # Export the name of the bucket pulumi.export(\u0026#39;bucket_name\u0026#39;, bucket.id) Feel free to explore the other files, although we won\u0026rsquo;t be editing any of them by hand.\nStep 4 — Configure an AWS Region Configure the AWS region you would like to deploy to:\npulumi config set aws:region us-west-2 "
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts/30_simple_api_gateway/1_new_project.html",
	"title": "2.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Infrastructure in Pulumi is organized into projects. Each project is a single program that, when run, declares the desired infrastructure for Pulumi to manage.\nStep 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir lambda-api-gateway cd lambda-api-gateway Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new typescript -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;lambda-api-gateway\u0026#39; Created stack \u0026#39;dev\u0026#39; Saved config Installing dependencies... Finished installing dependencies Your new project is ready to go! This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from NPM.\nStep 3 — Inspect Your New Project Our project is comprised of multiple files:\nindex.ts: your program\u0026rsquo;s main entrypoint file package.json and package-lock.json: your project\u0026rsquo;s NPM dependency information Pulumi.yaml: your project\u0026rsquo;s metadata, containing its name and language tsconfig.json: your project\u0026rsquo;s TypeScript settings node_modules/: a directory containing your project\u0026rsquo;s installed NPM dependencies Run cat index.ts to see the contents of your project\u0026rsquo;s empty program:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; Feel free to explore the other files, although we won\u0026rsquo;t be editing any of them by hand.\n"
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/40_deploying_applications_to_eks/1_new_project.html",
	"title": "3.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Step 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir eks-demo-apps cd eks-demo-apps Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new typescript -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;eks-demo-apps\u0026#39; Created stack \u0026#39;dev\u0026#39; Saved config Installing dependencies... Finished installing dependencies Your new project is ready to go! This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from NPM.\nStep 3 — Install pulumi kubernetes Package Run the following command to install the Kubernetes package:\nnpm install @pulumi/kubernetes The package will be added to node_modules, package.json, and package-lock.json.\n"
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python/40_ecs/1_new_project.html",
	"title": "3.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Infrastructure in Pulumi is organized into projects. Each project is a single program that, when run, declares the desired infrastructure for Pulumi to manage.\nStep 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir iac-workshop-ecs cd iac-workshop-ecs Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new python -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;iac-workshop-ecs\u0026#39; Created stack \u0026#39;dev\u0026#39; Saved config Installing dependencies... Finished installing dependencies Your new project is ready to go! This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from PyPi.\nStep 3 — Inspect Your New Project Our project is comprised of multiple files:\n__main__.py: your program\u0026rsquo;s main entrypoint file requirements.txt: your project\u0026rsquo;s Python dependency information Pulumi.yaml: your project\u0026rsquo;s metadata, containing its name and language venv: a virtualenv for your project Run cat __main__.py to see the contents of your project\u0026rsquo;s empty program:\n\u0026#34;\u0026#34;\u0026#34;A Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi Feel free to explore the other files, although we won\u0026rsquo;t be editing any of them by hand aside from requirements.txt.\n"
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts/40_container_thumbnailer/1_new_project.html",
	"title": "3.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Infrastructure in Pulumi is organized into projects. Each project is a single program that, when run, declares the desired infrastructure for Pulumi to manage.\nStep 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir lambda-thumbnailer cd lambda-thumbnailer Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new typescript -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;lambda-thumbnailer\u0026#39; Created stack \u0026#39;dev\u0026#39; Saved config Installing dependencies... Finished installing dependencies Your new project is ready to go! This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from NPM.\nStep 3 — Inspect Your New Project Our project is comprised of multiple files:\nindex.ts: your program\u0026rsquo;s main entrypoint file package.json and package-lock.json: your project\u0026rsquo;s NPM dependency information Pulumi.yaml: your project\u0026rsquo;s metadata, containing its name and language tsconfig.json: your project\u0026rsquo;s TypeScript settings node_modules/: a directory containing your project\u0026rsquo;s installed NPM dependencies Run cat index.ts to see the contents of your project\u0026rsquo;s empty program:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; Feel free to explore the other files, although we won\u0026rsquo;t be editing any of them by hand.\n"
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/45_componens/1_open_project.html",
	"title": "4.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Step 1 — Open the Project Go to the folder that contains the deploying_applications_to_eks lab.\ncd eks-demo-apps The code you have in that project should look like this:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; const pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); // Get the kubeconfig from the cluster stack output. const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;); // Create the k8s provider with the kubeconfig. const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, { kubeconfig }); const ns = new k8s.core.v1.Namespace(\u0026#34;eks-demo-apps-ns\u0026#34;, { metadata: { name: \u0026#34;eks-demo-apps\u0026#34; }, }, { provider }); const appLabels = { app: \u0026#34;eks-demo-apps\u0026#34; }; const deployment = new k8s.apps.v1.Deployment(\u0026#34;eks-demo-apps-dep\u0026#34;, { metadata: { namespace: ns.metadata.name }, spec: { selector: { matchLabels: appLabels }, replicas: 3, template: { metadata: { labels: appLabels }, spec: { containers: [{ name: \u0026#34;eks-demo-apps\u0026#34;, image: \u0026#34;jocatalin/kubernetes-bootcamp:v2\u0026#34;, }], }, }, }, }, { provider }); const service = new k8s.core.v1.Service(\u0026#34;eks-demo-apps-svc\u0026#34;, { metadata: { namespace: ns.metadata.name }, spec: { selector: appLabels, ports: [{ port: 80, targetPort: 8080 }], type: \u0026#34;LoadBalancer\u0026#34;, }, }, { provider }); const address = service.status.loadBalancer.ingress[0].hostname; const port = service.spec.ports[0].port; export const url = pulumi.interpolate`http://${address}:${port}`; Note that there is quite a bit of boilerplate here. In fact, there are really only 4 things that are being customized for this particular workload:\nThe image to use The number of replicas The port mappings The namespace to create the Service and Deployment inside In this lab, we\u0026rsquo;ll create a component that only requires specifying these four things, abstracting away all the boilerplate and complexity behind a simple interface for this common pattern.\n"
},
{
	"uri": "//localhost:1313/en/",
	"title": "AWS Modernization with Pulumi",
	"tags": [],
	"description": "",
	"content": "AWS Modernization with Pulumi Pulumi is an Infrastructure as Code platform that uses familiar, modern programming languages to declare infrastructure in AWS.\nThe Prerequisites workshop will guide you through setting up your Pulumi environment for all the workshops. It\u0026rsquo;s recommended to start there.\nChoose a workshop from the navigation bar on the left to get started.\n"
},
{
	"uri": "//localhost:1313/en/10_prerequisites/self_paced/account.html",
	"title": "Create an AWS account",
	"tags": [],
	"description": "",
	"content": " Your account must have the ability to create new IAM roles and scope other IAM permissions.\nIf you don\u0026rsquo;t already have an AWS account with Administrator access: create one now by clicking here\nOnce you have an AWS account, ensure you are following the remaining workshop steps as an IAM user with administrator access to the AWS account: Create a new IAM user to use for the workshop\nEnter the user details: Attach the AdministratorAccess IAM Policy: Click to create the new user: Take note of the login URL and save: "
},
{
	"uri": "//localhost:1313/en/additional-content/100_provision_ec2_virtual_machines/1_new_project.html",
	"title": "Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Step 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir ec2-workshop cd ec2-workshop Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new typescript -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;ec2-workshop\u0026#39; Created stack \u0026#39;dev\u0026#39; Saved config Installing dependencies... Finished installing dependencies Your new project is ready to go! This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from NPM.\nStep 3 — Install pulumi-aws Package Run the following command to install the AWS package:\nnpm install @pulumi/aws The package will be added to node_modules, package.json, and package-lock.json.\nStep 4 — Setting AWS Region Configure the AWS region you would like to deploy to:\npulumi config set aws:region us-west-2 Feel free to choose any AWS region.\n"
},
{
	"uri": "//localhost:1313/en/additional-content/110_deploying_containers_to_ecs/1_new_project.html",
	"title": "Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Step 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir ecs-workshop cd ecs-workshop Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new typescript -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;ecs-workshop\u0026#39; Created stack \u0026#39;dev\u0026#39; Saved config Installing dependencies... Finished installing dependencies Your new project is ready to go! This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from NPM.\nStep 3 — Install pulumi-aws Package Run the following command to install the AWS package:\nnpm install @pulumi/aws The package will be added to node_modules, package.json, and package-lock.json.\nStep 4 — Setting AWS Region Configure the AWS region you would like to deploy to:\npulumi config set aws:region us-west-2 Feel free to choose any AWS region.\n"
},
{
	"uri": "//localhost:1313/en/additional-content/120_serverless_application_patterns/1_new_project.html",
	"title": "Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Step 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir serverless-deployment cd serverless-deployment Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new typescript -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;serverless-deployment\u0026#39; Created stack \u0026#39;dev\u0026#39; Saved config Installing dependencies... Finished installing dependencies Your new project is ready to go! This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from NPM.\nStep 3 — Install pulumi-aws Package Run the following command to install the AWS and AWSX packages:\nnpm install @pulumi/aws npm install @pulumi/awsx The packages will be added to node_modules, package.json, and package-lock.json.\nStep 4 — Setting AWS Region Configure the AWS region you would like to deploy to:\npulumi config set aws:region us-west-2 Feel free to choose any AWS region.\n"
},
{
	"uri": "//localhost:1313/en/additional-content/150_deploying_argocd_to_eks/1_new_project.html",
	"title": "Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Step 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir argocd cd argocd Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new typescript -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;argocd\u0026#39; Created stack \u0026#39;dev\u0026#39; Saved config Installing dependencies... Finished installing dependencies Your new project is ready to go! This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from NPM.\nStep 3 — Install pulumi kubernetes Package Run the following command to install the Kubernetes package:\nnpm install @pulumi/kubernetes The package will be added to node_modules, package.json, and package-lock.json.\n"
},
{
	"uri": "//localhost:1313/en/additional-content/160_gitops_for_socks_shop/1_new_project.html",
	"title": "Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Step 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir socks-shop cd socks-shop Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new typescript -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;socks-shop\u0026#39; Created stack \u0026#39;dev\u0026#39; Saved config Installing dependencies... Finished installing dependencies Your new project is ready to go! This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from NPM.\nStep 3 — Install pulumi kubernetes Package Run the following command to install the Kubernetes package:\nnpm install @pulumi/kubernetes The package will be added to node_modules, package.json, and package-lock.json.\n"
},
{
	"uri": "//localhost:1313/en/10_prerequisites/start_workshop.html",
	"title": "Start the Workshop...",
	"tags": [],
	"description": "",
	"content": "Getting Started To start the workshop, follow one of the following depending on whether you are\u0026hellip;\n\u0026hellip;running the workshop on your own, or \u0026hellip;attending an AWS hosted event Once you have completed with either setup, continue with Install the required tools\n"
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/20_getting_started_with_pulumi/10_configuring_aws.html",
	"title": "1.2 Configuring AWS",
	"tags": [],
	"description": "",
	"content": "Now that we have a basic project, let\u0026rsquo;s add the Pulumi AWS provider and configure our credentials.\nStep 1 — Install the AWS Provider Run the following command:\nnpm i @pulumi/aws This will install the Pulumi AWS node SDK and add it to your package.json file. This is the library that will allow us to manage AWS assets with Pulumi. Pulumi also supports a wide range of other providers. For a complete list of all supported providers, see the Pulumi Registry.\nStep 2 — Import the AWS Provider Now that the AWS package is installed, we need to import it as part of our project.\nAdd the following to the top of your index.ts:\nimport * as aws from \u0026#34;@pulumi/aws\u0026#34;; After this change, your index.ts should look like this:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; Step 3 — Configure an AWS Region Configure the AWS region you would like to deploy to, replacing us-east-1 with your AWS region of choice:\npulumi config set aws:region us-east-1 Setting the AWS region is not strictly necessary, but we do it here to demonstrate how to set stack configuration values. If you do not set the region, Pulumi will use the default region for your AWS profile.\nNote that the previous command will create the file Pulumi.dev.yaml which contains the configuration for our dev stack. (Stacks are logical groupings of Pulumi resources.) We will be working with a single Pulumi stack in this tutorial, but we could define additional stacks to deploy our infrastructure to different regions/accounts with different parameters. To learn more about Pulumi stacks, see Stacks in the Pulumi docs.\n(Optional) Step 4 — Configure an AWS Profile If you are using an AWS profile other than the default, you can tell Pulumi which to use in one of two ways:\nUsing an environment variable: export AWS_PROFILE=\u0026lt;profile name\u0026gt; Using configuration: pulumi config set aws:profile \u0026lt;profile name\u0026gt; "
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python/20_getting_started_with_pulumi/10_configuring_aws.html",
	"title": "1.2 Configuring AWS",
	"tags": [],
	"description": "",
	"content": "Now that we have a basic project, let\u0026rsquo;s add the Pulumi AWS provider and configure our credentials.\nStep 1 — Install the AWS Package Pulumi created a virtualenv for us when we created our iac-workshop project. We\u0026rsquo;ll need to activate it to install dependencies:\nsource venv/bin/activate Add the following content to requirements.txt:\npulumi_aws\u0026gt;=5.0.0,\u0026lt;6.0.0 Run the following command to install the AWS packages:\npip3 install -r requirements.txt Step 2 — Import the AWS Package Now that the AWS package is installed, we need to import it as part of our project.\nAdd the following to the top of your __main.py__:\nimport pulumi_aws as aws \u0026#x2705; After this change, your __main__.py should look like this:\n\u0026#34;\u0026#34;\u0026#34;A Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws Step 3 — Configure an AWS Region Configure the AWS region you would like to deploy to, replacing us-east-1 with your AWS region of choice:\npulumi config set aws:region us-east-1 Note that the previous command will create the file Pulumi.dev.yaml which contains the configuration for our dev stack. (Stacks are logical groupings of Pulumi resources.) We will be working with a single Pulumi stack in this tutorial, but we could define additional stacks to deploy our infrastructure to different regions/accounts with different parameters. To learn more about Pulumi stacks, see Stacks in the Pulumi docs.\n(Optional) Step 4 — Configure an AWS Profile If you are using an alternative AWS profile, you can tell Pulumi which to use in one of two ways:\nUsing an environment variable: export AWS_PROFILE=\u0026lt;profile name\u0026gt; Using configuration: pulumi config set aws:profile \u0026lt;profile name\u0026gt; "
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java/20_getting_started_with_pulumi/10_configuring_aws.html",
	"title": "1.2 Configuring AWS",
	"tags": [],
	"description": "",
	"content": " Current module of the workshop is updated to use AWS Native and AWS Classic providers side-by-side. AWS Native is in public preview. AWS Native provides coverage of all resources in the AWS Cloud Control API, including same-day access to all new AWS resources. However, some AWS resources are not yet available in AWS Native.\nNow that you have a basic project, let\u0026rsquo;s configure AWS support for it.\nStep 1 — Add AWS dependencies Before we can use AWS Native and AWS Classic providers, we need to update our project with appropriate dependencies.\nYou can do it by editing your pom.xml file. Find the dependencies section and add the following entries:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-native\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.16.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Also, so we can use some newer features of Java, update the properties section to point to Java 17 instead of Java 11.\n\u0026lt;properties\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.release\u0026gt;17\u0026lt;/maven.compiler.release\u0026gt; \u0026lt;mainClass\u0026gt;myproject.App\u0026lt;/mainClass\u0026gt; \u0026lt;mainArgs/\u0026gt; \u0026lt;/properties\u0026gt; Your pom.xml file should look like the following:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;iac-workshop\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.release\u0026gt;17\u0026lt;/maven.compiler.release\u0026gt; \u0026lt;mainClass\u0026gt;myproject.App\u0026lt;/mainClass\u0026gt; \u0026lt;mainArgs/\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pulumi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-native\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.16.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;addClasspath\u0026gt;true\u0026lt;/addClasspath\u0026gt; \u0026lt;mainClass\u0026gt;${mainClass}\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-assembly-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;addClasspath\u0026gt;true\u0026lt;/addClasspath\u0026gt; \u0026lt;mainClass\u0026gt;${mainClass}\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;descriptorRefs\u0026gt; \u0026lt;descriptorRef\u0026gt;jar-with-dependencies\u0026lt;/descriptorRef\u0026gt; \u0026lt;/descriptorRefs\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;make-my-jar-with-dependencies\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;single\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.codehaus.mojo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;exec-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;mainClass\u0026gt;${mainClass}\u0026lt;/mainClass\u0026gt; \u0026lt;commandlineArgs\u0026gt;${mainArgs}\u0026lt;/commandlineArgs\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-wrapper-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;mavenVersion\u0026gt;3.8.5\u0026lt;/mavenVersion\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; Update your Maven dependencies to get autocompletion for your IDE, if you so choose.\nStep 2 — Configure an AWS Region Configure the AWS region you would like to deploy to:\npulumi config set aws:region us-west-2 Feel free to choose any AWS region that supports the services used in these labs (see this table for a list of available regions).\n(Optional) Step 4 — Configure an AWS Profile If you\u0026rsquo;re using an alternative AWS profile, you can tell Pulumi which to use in one of two ways:\nUsing an environment variable: export AWS_PROFILE=\u0026lt;profile name\u0026gt; Using configuration: pulumi config set aws:profile \u0026lt;profile name\u0026gt; "
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java/40_ecs/10_configuring_aws.html",
	"title": "1.2 Configuring AWS",
	"tags": [],
	"description": "",
	"content": " Current module of the workshop is updated to use AWS Native and AWS Classic providers side-by-side. AWS Native is in public preview. AWS Native provides coverage of all resources in the AWS Cloud Control API, including same-day access to all new AWS resources. However, some AWS resources are not yet available in AWS Native.\nNow that you have a basic project, let\u0026rsquo;s configure AWS support for it.\nStep 1 — Add AWS dependencies Before we can use AWS Native and AWS Classic providers, we need to update our project with appropriate dependencies.\nYou can do it by editing your pom.xml file. Find the dependencies section and add the following entries:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-native\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.16.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Your pom.xml file should look like the following:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;iac-workshop\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.release\u0026gt;17\u0026lt;/maven.compiler.release\u0026gt; \u0026lt;mainClass\u0026gt;myproject.App\u0026lt;/mainClass\u0026gt; \u0026lt;mainArgs/\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pulumi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pulumi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-native\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.16.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;addClasspath\u0026gt;true\u0026lt;/addClasspath\u0026gt; \u0026lt;mainClass\u0026gt;${mainClass}\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-assembly-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;addClasspath\u0026gt;true\u0026lt;/addClasspath\u0026gt; \u0026lt;mainClass\u0026gt;${mainClass}\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;descriptorRefs\u0026gt; \u0026lt;descriptorRef\u0026gt;jar-with-dependencies\u0026lt;/descriptorRef\u0026gt; \u0026lt;/descriptorRefs\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;make-my-jar-with-dependencies\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;single\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.codehaus.mojo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;exec-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;mainClass\u0026gt;${mainClass}\u0026lt;/mainClass\u0026gt; \u0026lt;commandlineArgs\u0026gt;${mainArgs}\u0026lt;/commandlineArgs\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-wrapper-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;mavenVersion\u0026gt;3.8.5\u0026lt;/mavenVersion\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; Step 2 — Configure an AWS Region Configure the AWS region you would like to deploy to:\npulumi config set aws:region us-west-2 Feel free to choose any AWS region that supports the services used in these labs (see this table for a list of available regions).\n(Optional) Step 4 — Configure an AWS Profile If you\u0026rsquo;re using an alternative AWS profile, you can tell Pulumi which to use in one of two ways:\nUsing an environment variable: export AWS_PROFILE=\u0026lt;profile name\u0026gt; Using configuration: pulumi config set aws:profile \u0026lt;profile name\u0026gt; "
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts/20_getting_started_with_pulumi/10_configuring_aws.html",
	"title": "1.2 Configuring AWS",
	"tags": [],
	"description": "",
	"content": "Now that you have a basic project, let\u0026rsquo;s configure AWS support for it.\nStep 1 — Install the AWS Package Run the following command to install the AWS package:\nnpm install @pulumi/aws The package will be added to node_modules, package.json, and package-lock.json.\nStep 2 — Import the AWS Package Now that the AWS package is installed, we need to import it as part of our project:\nimport * as aws from \u0026#34;@pulumi/aws\u0026#34;; The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; Step 3 — Configure an AWS Region Configure the AWS region you would like to deploy to:\npulumi config set aws:region us-west-2 Feel free to choose any AWS region that supports the services used in these labs (see this table for a list of available regions).\n(Optional) Step 4 — Configure an AWS Profile If you\u0026rsquo;re using an alternative AWS profile, you can tell Pulumi which to use in one of two ways:\nUsing an environment variable: export AWS_PROFILE=\u0026lt;profile name\u0026gt; Using configuration: pulumi config set aws:profile \u0026lt;profile name\u0026gt; "
},
{
	"uri": "//localhost:1313/en/50_eks_platform/20_provision_cluster/10_configuring_aws.html",
	"title": "1.2 Configuring AWS",
	"tags": [],
	"description": "",
	"content": "Now that you have a basic project, let\u0026rsquo;s configure AWS support for it.\nStep 1 — Install the AWS Package Run the following command to install the AWS and AWS Crosswalk package:\nnpm install @pulumi/aws npm install @pulumi/awsx The package will be added to node_modules, package.json, and package-lock.json.\nStep 2 — Import the AWS Package Now that the AWS package is installed, we need to import it as part of our project:\nimport * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; Step 3 — Configure AWS Configure the AWS region you would like to deploy to:\npulumi config set aws:region us-west-2 pulumi config set aws:skipMetadataApiCheck false # set this if running in an IAM role Feel free to choose any AWS region that supports the services used in these labs (see this table for a list of available regions).\n(Optional) Step 4 — Configure an AWS Profile If you\u0026rsquo;re using an alternative AWS profile, you can tell Pulumi which to use in one of two ways:\nUsing an environment variable: export AWS_PROFILE=\u0026lt;profile name\u0026gt; Using configuration: pulumi config set aws:profile \u0026lt;profile name\u0026gt; "
},
{
	"uri": "//localhost:1313/en/50_eks_platform/30_deploy_ingress_controller/1_new_project.html",
	"title": "2.1 Creating a New Project",
	"tags": [],
	"description": "",
	"content": "Infrastructure in Pulumi is organized into projects. Each project is a single program that, when run, declares the desired infrastructure for Pulumi to manage.\nStep 1 — Create a Directory Each Pulumi project lives in its own directory. Create one now and change into it:\nmkdir aws-load-balancer-controller cd aws-load-balancer-controller Pulumi will use the directory name as your project name by default. To create an independent project, simply name the directory differently.\nStep 2 — Initialize Your Project A Pulumi project is just a directory with some files in it. It\u0026rsquo;s possible for you to create a new one by hand. The pulumi new command, however, automates the process:\npulumi new aws-python -y This will print output similar to the following with a bit more information and status as it goes:\nCreated project \u0026#39;aws-load-balancer-controller\u0026#39; Please enter your desired stack name. To create a stack in an organization, use the format \u0026lt;org-name\u0026gt;/\u0026lt;stack-name\u0026gt; (e.g. `acmecorp/dev`). Created stack \u0026#39;dev\u0026#39; Saved config Creating virtual environment... Finished creating virtual environment Updating pip, setuptools, and wheel in virtual environment... Collecting pip This command has created all the files we need, initialized a new stack named dev (an instance of our project), and installed the needed package dependencies from NPM.\nStep 3 — Inspect Your New Project Our project is comprised of multiple files:\n__main__.py: your program\u0026rsquo;s main entrypoint file requirements.txt: your project\u0026rsquo;s Python dependency information Pulumi.yaml: your project\u0026rsquo;s metadata, containing its name and language venv: a virtualenv for your project Run cat __main__.py to see the contents of your project\u0026rsquo;s empty program:\n\u0026#34;\u0026#34;\u0026#34;An AWS Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi from pulumi_aws import s3 # Create an AWS resource (S3 Bucket) bucket = s3.Bucket(\u0026#39;my-bucket\u0026#39;) # Export the name of the bucket pulumi.export(\u0026#39;bucket_name\u0026#39;, bucket.id) Feel free to explore the other files, although we won\u0026rsquo;t be editing any of them by hand.\nStep 4 — Add the Kubernetes Provider We\u0026rsquo;ll be provisioning Kubernetes resources alongside AWS resources in this Pulumi project, so we\u0026rsquo;ll add the Kubernetes provider to our program.\nFirst, we need to install it. We\u0026rsquo;ll activate our virtual env,\nsource venv/bin/activate and the install the provider inside that:\npip3 install pulumi-kubernetes Next, add the provider to our Pulumi program. Clear our any boilerplate configuration in your Pulumi program and add the following:\nimport pulumi_kubernetes as k8s import pulumi_aws as aws The __main__.py file should now have the following contents:\nimport pulumi import pulumi_kubernetes as k8s import pulumi_aws as aws Now we\u0026rsquo;re ready to provision the dependent AWS resources we need for the LoadBalancer\n"
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts/30_simple_api_gateway/10_configuring_aws.html",
	"title": "2.2 Configuring AWS",
	"tags": [],
	"description": "",
	"content": "Now that you have a basic project, let\u0026rsquo;s configure AWS support for it.\nStep 1 — Install the AWS Packages Run the following command to install the AWS package:\nnpm install @pulumi/aws npm install @pulumi/awsx The package will be added to node_modules, package.json, and package-lock.json.\nStep 2 — Import the AWS Package Now that the AWS packages are installed, we need to import it as part of our project:\nimport * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx Step 3 — Configure an AWS Region Configure the AWS region you would like to deploy to:\npulumi config set aws:region us-west-2 Feel free to choose any AWS region that supports the services used in these labs (see this table for a list of available regions).\n(Optional) Step 4 — Configure an AWS Profile If you\u0026rsquo;re using an alternative AWS profile, you can tell Pulumi which to use in one of two ways:\nUsing an environment variable: export AWS_PROFILE=\u0026lt;profile name\u0026gt; Using configuration: pulumi config set aws:profile \u0026lt;profile name\u0026gt; "
},
{
	"uri": "//localhost:1313/en/50_eks_platform/30_deploy_ingress_controller/10_create_iam_role.html",
	"title": "2.2 Create an IAM Role",
	"tags": [],
	"description": "",
	"content": "We\u0026rsquo;ll be deploying the AWS Load Balancer Controller into our EKS Cluster, but it will need to make API calls to AWS for some operations.\nWe can pass an IAM role to our Kubernetes deployment using IAM Roles for Service Accounts which we configured on our cluster\nLet\u0026rsquo;s define the IAM role we need to pass to our Kubernetes resources\nStep 1 — Retrieve Stack References Before we define any resources, we need to retrieve some outputs from our cluster stack.\nAdd a StackReference call to your __main__.py:\nstack = pulumi.get_stack() cluster = pulumi.StackReference(f\u0026#34;jaxxstorm/workshop-cluster/{stack}\u0026#34;) The __main__.py file should now have the following contents:\nimport pulumi import pulumi_aws as aws import pulumi_kubernetes as k8s stack = pulumi.get_stack() cluster = pulumi.StackReference(f\u0026#34;jaxxstorm/workshop-cluster/{stack}\u0026#34;) oidc_arn = cluster.get_output(\u0026#39;clusterOidcProviderArn\u0026#39;) oidc_url = cluster.get_output(\u0026#39;clusterOidcProvider\u0026#39;) Step 2 — Define your IAM Role Now we\u0026rsquo;ve retrieved these important values from our cluster stack, we can start to build our AWS resources. Define your IAM role and use your retrieved values inside your IAM policy:\nimport json ns = \u0026#34;aws-lb-controller\u0026#34; service_account_name = f\u0026#34;system:serviceaccount:{ns}:aws-lb-controller-serviceaccount\u0026#34; iam_role = aws.iam.Role( \u0026#34;aws-loadbalancer-controller-role\u0026#34;, assume_role_policy=pulumi.Output.all(oidc_arn, oidc_url).apply( lambda args: json.dumps( { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Federated\u0026#34;: args[0], }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: {f\u0026#34;{args[1]}:sub\u0026#34;: service_account_name}, }, } ], } ) ), ) We use two important pulumi methods here, an all and an apply. This allows us to concatenate a standard string with a pulumi.Output\u0026lt;string\u0026gt;.\nWe\u0026rsquo;ve also defined a namespace variable, so we can ensure we don\u0026rsquo;t make mistakes later.\nThe __main__.py file should now have the following contents:\nimport pulumi import pulumi_aws as aws import json import pulumi_kubernetes as k8s stack = pulumi.get_stack() cluster = pulumi.StackReference(f\u0026#34;jaxxstorm/workshop-cluster/{stack}\u0026#34;) oidc_arn = cluster.get_output(\u0026#39;clusterOidcProviderArn\u0026#39;) oidc_url = cluster.get_output(\u0026#39;clusterOidcProvider\u0026#39;) ns = \u0026#34;aws-lb-controller\u0026#34; service_account_name = f\u0026#34;system:serviceaccount:{ns}:aws-lb-controller-serviceaccount\u0026#34; iam_role = aws.iam.Role( \u0026#34;aws-loadbalancer-controller-role\u0026#34;, assume_role_policy=pulumi.Output.all(oidc_arn, oidc_url).apply( lambda args: json.dumps( { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Federated\u0026#34;: args[0], }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: {f\u0026#34;{args[1]}:sub\u0026#34;: service_account_name}, }, } ], } ) ), ) Step 3 — Define your IAM Policy Now we have an IAM role, we need to add the policy to this role that allows the AWS Load Balancer Controller to call the AWS APIs it needs to do its job.\nThis policy is very long, so in order to save some lines of code, we\u0026rsquo;ll download the policy and read it from a file.\nCreate a directory to store the policy file, and then download the policy from the AWS Load Balancer controller GitHub:\nmkdir files curl -L https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/main/docs/install/iam_policy.json -o files/iam_policy.json Then, add the IAM policy resource\nwith open(\u0026#34;files/iam_policy.json\u0026#34;) as policy_file: policy_doc = policy_file.read() iam_policy = aws.iam.Policy( \u0026#34;aws-loadbalancer-controller-policy\u0026#34;, policy=policy_doc, opts=pulumi.ResourceOptions(parent=iam_role), ) The __main__.py file should now have the following contents:\n\u0026#34;\u0026#34;\u0026#34;An AWS Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws import json import pulumi_kubernetes as k8s stack = pulumi.get_stack() cluster = pulumi.StackReference(f\u0026#34;jaxxstorm/workshop-cluster/{stack}\u0026#34;) oidc_arn = cluster.get_output(\u0026#34;clusterOidcProviderArn\u0026#34;) oidc_url = cluster.get_output(\u0026#34;clusterOidcProvider\u0026#34;) ns = \u0026#34;aws-lb-controller\u0026#34; service_account_name = f\u0026#34;system:serviceaccount:{ns}:aws-lb-controller-serviceaccount\u0026#34; iam_role = aws.iam.Role( \u0026#34;aws-loadbalancer-controller-role\u0026#34;, assume_role_policy=pulumi.Output.all(oidc_arn, oidc_url).apply( lambda args: json.dumps( { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Federated\u0026#34;: args[0], }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: {f\u0026#34;{args[1]}:sub\u0026#34;: service_account_name}, }, } ], } ) ), ) with open(\u0026#34;files/iam_policy.json\u0026#34;) as policy_file: policy_doc = policy_file.read() iam_policy = aws.iam.Policy( \u0026#34;aws-loadbalancer-controller-policy\u0026#34;, policy=policy_doc, opts=pulumi.ResourceOptions(parent=iam_role), ) Step 4 — Attach the IAM Policy to the Role Now we have an IAM role for our Kubernetes pod to use, and a policy, but they don\u0026rsquo;t yet know about each other.\nTo rectify this, we can use IamPolicyAttachment resource.\nAdd the following to your Pulumi program to link the two resources together\naws.iam.PolicyAttachment( \u0026#34;aws-loadbalancer-controller-attachment\u0026#34;, policy_arn=iam_policy.arn, roles=[iam_role.name], opts=pulumi.ResourceOptions(parent=iam_role), ) The __main__.py file should now have the following contents:\n\u0026#34;\u0026#34;\u0026#34;An AWS Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws import json import pulumi_kubernetes as k8s stack = pulumi.get_stack() cluster = pulumi.StackReference(f\u0026#34;jaxxstorm/workshop-cluster/{stack}\u0026#34;) oidc_arn = cluster.get_output(\u0026#34;clusterOidcProviderArn\u0026#34;) oidc_url = cluster.get_output(\u0026#34;clusterOidcProvider\u0026#34;) ns = \u0026#34;aws-lb-controller\u0026#34; service_account_name = f\u0026#34;system:serviceaccount:{ns}:aws-lb-controller-serviceaccount\u0026#34; iam_role = aws.iam.Role( \u0026#34;aws-loadbalancer-controller-role\u0026#34;, assume_role_policy=pulumi.Output.all(oidc_arn, oidc_url).apply( lambda args: json.dumps( { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Federated\u0026#34;: args[0], }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: {f\u0026#34;{args[1]}:sub\u0026#34;: service_account_name}, }, } ], } ) ), ) with open(\u0026#34;files/iam_policy.json\u0026#34;) as policy_file: policy_doc = policy_file.read() iam_policy = aws.iam.Policy( \u0026#34;aws-loadbalancer-controller-policy\u0026#34;, policy=policy_doc, opts=pulumi.ResourceOptions(parent=iam_role), ) aws.iam.PolicyAttachment( \u0026#34;aws-loadbalancer-controller-attachment\u0026#34;, policy_arn=iam_policy.arn, roles=[iam_role.name], opts=pulumi.ResourceOptions(parent=iam_role), ) Step 5 — Provision your Infrastructure Now that we have our role fleshed out, we can use Pulumi to provision it.\nLet\u0026rsquo;s preview your changes:\npulumi up This command evaluates your program, determines the resource updates to make, and shows you an outline of these changes:\npulumi up Previewing update (dev) View Live: https://app.pulumi.com/jaxxstorm/aws-load-balancer-controller/dev/previews/a4fe98ec-cc73-43d8-af04-9e2c0ac2aeb9 Type Name Plan + pulumi:pulumi:Stack aws-load-balancer-controller-dev create + └─ aws:iam:Role aws-loadbalancer-controller-role create + ├─ aws:iam:Policy aws-loadbalancer-controller-policy create + └─ aws:iam:PolicyAttachment aws-loadbalancer-controller-policy-attachment create Resources: + 4 to create Do you want to perform this update? [Use arrows to move, enter to select, type to filter] yes \u0026gt; no details Hit yes to create your resources\n"
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/30_deploying_eks_cluster/10_creating_a_vpc.html",
	"title": "2.2 Creating an Amazon VPC",
	"tags": [],
	"description": "",
	"content": "Start by adding the Pulumi AWSX import to your index.ts file:\nimport * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; Then add the following to your index.ts to create a vpc. The vpc will be made of 2 private and 2 public subnets. The private subnets will be routed to the internet via nat gateways.\nSee for more details and examples:\nAPI Docs Examples const vpc = new awsx.ec2.Vpc(\u0026#34;workshop-vpc\u0026#34;, {}); We will be able to use this vpc in which to deploy our Amazon EKS cluster.\nThe index.ts file should now have the following contents:\nimport * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; const vpc = new awsx.ec2.Vpc(\u0026#34;workshop-vpc\u0026#34;, {}); To provision the vpc, run:\npulumi up After confirming, you will see output like the following:\nUpdating (dev): Type Name Status + pulumi:pulumi:Stack eks-infrastructure-dev created + └─ awsx:x:ec2:Vpc workshop-vpc created + ├─ awsx:x:ec2:Subnet workshop-vpc-private-1 created + │ ├─ aws:ec2:Subnet workshop-vpc-private-1 created + │ ├─ aws:ec2:RouteTable workshop-vpc-private-1 created + │ ├─ aws:ec2:RouteTableAssociation workshop-vpc-private-1 created + │ └─ aws:ec2:Route workshop-vpc-private-1-nat-1 created + ├─ awsx:x:ec2:Subnet workshop-vpc-private-0 created + │ ├─ aws:ec2:Subnet workshop-vpc-private-0 created + │ ├─ aws:ec2:RouteTable workshop-vpc-private-0 created + │ ├─ aws:ec2:RouteTableAssociation workshop-vpc-private-0 created + │ └─ aws:ec2:Route workshop-vpc-private-0-nat-0 created + ├─ awsx:x:ec2:InternetGateway workshop-vpc created + │ └─ aws:ec2:InternetGateway workshop-vpc created + ├─ awsx:x:ec2:Subnet workshop-vpc-public-0 created + │ ├─ aws:ec2:RouteTable workshop-vpc-public-0 created + │ ├─ aws:ec2:Subnet workshop-vpc-public-0 created + │ ├─ aws:ec2:Route workshop-vpc-public-0-ig created + │ └─ aws:ec2:RouteTableAssociation workshop-vpc-public-0 created + ├─ awsx:x:ec2:NatGateway workshop-vpc-0 created + │ ├─ aws:ec2:Eip workshop-vpc-0 created + │ └─ aws:ec2:NatGateway workshop-vpc-0 created + ├─ awsx:x:ec2:Subnet workshop-vpc-public-1 created + │ ├─ aws:ec2:Subnet workshop-vpc-public-1 created + │ ├─ aws:ec2:RouteTable workshop-vpc-public-1 created + │ ├─ aws:ec2:RouteTableAssociation workshop-vpc-public-1 created + │ └─ aws:ec2:Route workshop-vpc-public-1-ig created + ├─ awsx:x:ec2:NatGateway workshop-vpc-1 created + │ ├─ aws:ec2:Eip workshop-vpc-1 created + │ └─ aws:ec2:NatGateway workshop-vpc-1 created + └─ aws:ec2:Vpc workshop-vpc created Resources: + 31 created Duration: 2m50s Permalink: https://app.pulumi.com/workshops/eks-infrastructure/dev/updates/1 "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/30_deploying_webservers/10_provision_ec2.html",
	"title": "2.2 Provision an EC2 Instances",
	"tags": [],
	"description": "",
	"content": "Step 1 — Declare the EC2 Instance Remove any existing code here from the bootstrapping of your project. Then, import the AWS package in an empty __main__.py file:\nfrom pulumi import export import pulumi_aws as aws Now dynamically query the Amazon Linux machine image. Doing this in code avoids needing to hard-code the machine image (a.k.a., its AMI):\nami = aws.get_ami( most_recent=\u0026#34;true\u0026#34;, owners=[\u0026#34;137112412989\u0026#34;], filters=[{\u0026#34;name\u0026#34;:\u0026#34;name\u0026#34;,\u0026#34;values\u0026#34;:[\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;]}]) We also need to grab the default vpc that is available in our AWS account:\nvpc = aws.ec2.get_vpc(default=True) Next, create an AWS security group. This enables ping over ICMP and HTTP traffic on port 80:\ngroup = aws.ec2.SecurityGroup( \u0026#34;web-secgrp\u0026#34;, description=\u0026#39;Enable HTTP access\u0026#39;, vpc_id=vpc.id, ingress=[ { \u0026#39;protocol\u0026#39;: \u0026#39;icmp\u0026#39;, \u0026#39;from_port\u0026#39;: 8, \u0026#39;to_port\u0026#39;: 0, \u0026#39;cidr_blocks\u0026#39;: [\u0026#39;0.0.0.0/0\u0026#39;] }, { \u0026#39;protocol\u0026#39;: \u0026#39;tcp\u0026#39;, \u0026#39;from_port\u0026#39;: 80, \u0026#39;to_port\u0026#39;: 80, \u0026#39;cidr_blocks\u0026#39;: [\u0026#39;0.0.0.0/0\u0026#39;] } ]) Create the server. Notice it has a startup script that spins up a simple Python webserver:\nserver = aws.ec2.Instance( \u0026#39;web-server\u0026#39;, instance_type=\u0026#34;t2.micro\u0026#34;, vpc_security_group_ids=[group.id], ami=ami.id, user_data=\u0026#34;\u0026#34;\u0026#34; #!/bin/bash echo \u0026#34;Hello, World!\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp; \u0026#34;\u0026#34;\u0026#34;, tags={ \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34;, }, ) For most real-world applications, you would want to create a dedicated image for your application, rather than embedding the script in your code like this.\nFinally export the EC2 instances\u0026rsquo;s resulting IP address and hostname:\npulumi.export(\u0026#39;ip\u0026#39;, server.public_ip) pulumi.export(\u0026#39;hostname\u0026#39;, server.public_dns) \u0026#x2705; After this change, your __main__.py should look like this:\nimport pulumi import pulumi_aws as aws ami = aws.get_ami( most_recent=\u0026#34;true\u0026#34;, owners=[\u0026#34;137112412989\u0026#34;], filters=[{\u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;values\u0026#34;: [\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;]}], ) vpc = aws.ec2.get_vpc(default=True) group = aws.ec2.SecurityGroup( \u0026#34;web-secgrp\u0026#34;, description=\u0026#34;Enable HTTP Access\u0026#34;, ingress=[ { \u0026#34;protocol\u0026#34;: \u0026#34;icmp\u0026#34;, \u0026#34;from_port\u0026#34;: 8, \u0026#34;to_port\u0026#34;: 0, \u0026#34;cidr_blocks\u0026#34;: [\u0026#34;0.0.0.0/0\u0026#34;], }, { \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;from_port\u0026#34;: 80, \u0026#34;to_port\u0026#34;: 80, \u0026#34;cidr_blocks\u0026#34;: [\u0026#34;0.0.0.0/0\u0026#34;], }, ], ) server = aws.ec2.Instance( \u0026#34;web=server\u0026#34;, instance_type=\u0026#34;t2.micro\u0026#34;, vpc_security_group_ids=[group.name], ami=ami.id, user_data=\u0026#34;\u0026#34;\u0026#34; #!/bin/bash echo \u0026#34;Hello, World!\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp; \u0026#34;\u0026#34;\u0026#34;, tags={ \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34;, }, ) pulumi.export(\u0026#34;ip\u0026#34;, server.public_ip) pulumi.export(\u0026#34;hostname\u0026#34;, server.public_dns) Step 2 — Provision the EC2 Instance and Access It To provision the VM, run:\npulumi up After confirming, you will see output like the following:\nUpdating (dev): Type Name Status + pulumi:pulumi:Stack iac-workshop-dev created + ├─ aws:ec2:SecurityGroup web-secgrp created + └─ aws:ec2:Instance web-server created Outputs: hostname: \u0026#34;ec2-52-57-250-206.eu-central-1.compute.amazonaws.com\u0026#34; ip : \u0026#34;52.57.250.206\u0026#34; Resources: + 3 created Duration: 40s Permalink: https://app.pulumi.com/jaxxstorm/iac-workshop/dev/updates/1 To verify that our server is accepting requests properly, curl either the hostname or IP address:\ncurl $(pulumi stack output hostname) Either way you should see a response from the Python webserver:\nHello, World! "
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python/30_deploying_webservers/10_provision_ec2.html",
	"title": "2.2 Provision an EC2 Instances",
	"tags": [],
	"description": "",
	"content": "Step 1 — Declare the EC2 Instance Remove any existing code here from the bootstrapping of your project. Then, import the AWS package in an empty __main__.py file:\nfrom pulumi import export import pulumi_aws as aws Now dynamically query the Amazon Linux machine image. Doing this in code avoids needing to hard-code the machine image (a.k.a., its AMI):\nami = aws.get_ami( most_recent=\u0026#34;true\u0026#34;, owners=[\u0026#34;137112412989\u0026#34;], filters=[{\u0026#34;name\u0026#34;:\u0026#34;name\u0026#34;,\u0026#34;values\u0026#34;:[\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;]}]) We also need to grab the default vpc that is available in our AWS account:\nvpc = aws.ec2.get_vpc(default=True) Next, create an AWS security group. This enables ping over ICMP and HTTP traffic on port 80:\ngroup = aws.ec2.SecurityGroup( \u0026#34;web-secgrp\u0026#34;, description=\u0026#39;Enable HTTP access\u0026#39;, vpc_id=vpc.id, ingress=[ { \u0026#39;protocol\u0026#39;: \u0026#39;icmp\u0026#39;, \u0026#39;from_port\u0026#39;: 8, \u0026#39;to_port\u0026#39;: 0, \u0026#39;cidr_blocks\u0026#39;: [\u0026#39;0.0.0.0/0\u0026#39;] }, { \u0026#39;protocol\u0026#39;: \u0026#39;tcp\u0026#39;, \u0026#39;from_port\u0026#39;: 80, \u0026#39;to_port\u0026#39;: 80, \u0026#39;cidr_blocks\u0026#39;: [\u0026#39;0.0.0.0/0\u0026#39;] } ]) Create the server. Notice it has a startup script that spins up a simple Python webserver:\nserver = aws.ec2.Instance( \u0026#39;web-server\u0026#39;, instance_type=\u0026#34;t2.micro\u0026#34;, vpc_security_group_ids=[group.id], ami=ami.id, user_data=\u0026#34;\u0026#34;\u0026#34; #!/bin/bash echo \u0026#34;Hello, World!\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp; \u0026#34;\u0026#34;\u0026#34;, tags={ \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34;, }, ) For most real-world applications, you would want to create a dedicated image for your application, rather than embedding the script in your code like this.\nFinally export the EC2 instances\u0026rsquo;s resulting IP address and hostname:\npulumi.export(\u0026#39;ip\u0026#39;, server.public_ip) pulumi.export(\u0026#39;hostname\u0026#39;, server.public_dns) \u0026#x2705; After this change, your __main__.py should look like this:\nimport pulumi import pulumi_aws as aws ami = aws.get_ami( most_recent=\u0026#34;true\u0026#34;, owners=[\u0026#34;137112412989\u0026#34;], filters=[{\u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;values\u0026#34;: [\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;]}], ) vpc = aws.ec2.get_vpc(default=True) group = aws.ec2.SecurityGroup( \u0026#34;web-secgrp\u0026#34;, description=\u0026#34;Enable HTTP Access\u0026#34;, ingress=[ { \u0026#34;protocol\u0026#34;: \u0026#34;icmp\u0026#34;, \u0026#34;from_port\u0026#34;: 8, \u0026#34;to_port\u0026#34;: 0, \u0026#34;cidr_blocks\u0026#34;: [\u0026#34;0.0.0.0/0\u0026#34;], }, { \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;from_port\u0026#34;: 80, \u0026#34;to_port\u0026#34;: 80, \u0026#34;cidr_blocks\u0026#34;: [\u0026#34;0.0.0.0/0\u0026#34;], }, ], ) server = aws.ec2.Instance( \u0026#34;web=server\u0026#34;, instance_type=\u0026#34;t2.micro\u0026#34;, vpc_security_group_ids=[group.name], ami=ami.id, user_data=\u0026#34;\u0026#34;\u0026#34; #!/bin/bash echo \u0026#34;Hello, World!\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp; \u0026#34;\u0026#34;\u0026#34;, tags={ \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34;, }, ) pulumi.export(\u0026#34;ip\u0026#34;, server.public_ip) pulumi.export(\u0026#34;hostname\u0026#34;, server.public_dns) Step 2 — Provision the EC2 Instance and Access It To provision the VM, run:\npulumi up After confirming, you will see output like the following:\nUpdating (dev): Type Name Status + pulumi:pulumi:Stack iac-workshop-dev created + ├─ aws:ec2:SecurityGroup web-secgrp created + └─ aws:ec2:Instance web-server created Outputs: hostname: \u0026#34;ec2-52-57-250-206.eu-central-1.compute.amazonaws.com\u0026#34; ip : \u0026#34;52.57.250.206\u0026#34; Resources: + 3 created Duration: 40s Permalink: https://app.pulumi.com/jaxxstorm/iac-workshop/dev/updates/1 To verify that our server is accepting requests properly, curl either the hostname or IP address:\ncurl $(pulumi stack output hostname) Either way you should see a response from the Python webserver:\nHello, World! "
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java/30_deploying_webservers/10_provision_ec2.html",
	"title": "2.2 Provision an EC2 Instances",
	"tags": [],
	"description": "",
	"content": "Step 1 — Declare the EC2 Instance Remove any existing code here from the bootstrapping of your project. We\u0026rsquo;re going to use AWS API to query the latest Amazon Linux machine image. Doing this in code avoids needing to hard-code the machine image (a.k.a., its AMI):\nvar latestAmi = Ec2Functions .getAmi( GetAmiArgs.builder() .mostRecent(true) .owners(\u0026#34;137112412989\u0026#34;) .filters(GetAmiFilter.builder().name(\u0026#34;name\u0026#34;).values(\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;).build()) .build() ).thenApply(GetAmiResult::id); We also need to grab the default vpc that is available in our AWS account:\nvar defaultVpcId = Ec2Functions .getVpc(GetVpcArgs.builder().default_(true).build()) .thenApply(GetVpcResult::id); Next, create an AWS security group. This enables HTTP traffic on port 80:\nvar securityGroup = new SecurityGroup(\u0026#34;web-secgrp\u0026#34;, SecurityGroupArgs .builder() .description(\u0026#34;Enable HTTP Access\u0026#34;) .vpcId(Output.of(defaultVpcId)) .ingress( SecurityGroupIngressArgs.builder() .protocol(\u0026#34;tcp\u0026#34;) .fromPort(80) .toPort(80) .cidrBlocks(\u0026#34;0.0.0.0/0\u0026#34;) .build()) .build()); Create the server. Notice it has a startup script that spins up a simple Python webserver:\nvar ec2Instance = new Instance(\u0026#34;web-server\u0026#34;, InstanceArgs.builder() .instanceType(\u0026#34;t2.micro\u0026#34;) .vpcSecurityGroupIds(Output.all(securityGroup.getId())) .ami(Output.of(latestAmi)) .userData(\u0026#34;\u0026#34;\u0026#34; #!/bin/bash echo \u0026#34;Hello, World!\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp;\u0026#34;\u0026#34;\u0026#34;) .tags(Map.of(\u0026#34;Name\u0026#34;, \u0026#34;web-server\u0026#34;)) .build() ); For most real-world applications, you would want to create a dedicated image for your application, rather than embedding the script in your code like this.\nFinally, export the EC2 instances\u0026rsquo; resulting IP address and hostname:\nctx.export(\u0026#34;ip\u0026#34;, ec2Instance.publicIp()); ctx.export(\u0026#34;hostname\u0026#34;, ec2Instance.publicDns()); \u0026#x2705; After this change, your App.java should look like this:\npackage myproject; import com.pulumi.Pulumi; import com.pulumi.aws.ec2.*; import com.pulumi.aws.ec2.inputs.GetAmiArgs; import com.pulumi.aws.ec2.inputs.GetAmiFilter; import com.pulumi.aws.ec2.inputs.GetVpcArgs; import com.pulumi.aws.ec2.inputs.SecurityGroupIngressArgs; import com.pulumi.aws.ec2.outputs.GetAmiResult; import com.pulumi.aws.ec2.outputs.GetVpcResult; import com.pulumi.core.Output; import java.util.Map; public class App { public static void main(String[] args) { Pulumi.run(ctx -\u0026gt; { var latestAmi = Ec2Functions .getAmi( GetAmiArgs.builder() .mostRecent(true) .owners(\u0026#34;137112412989\u0026#34;) .filters(GetAmiFilter.builder().name(\u0026#34;name\u0026#34;).values(\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;).build()) .build() ).thenApply(GetAmiResult::id); var defaultVpcId = Ec2Functions .getVpc(GetVpcArgs.builder().default_(true).build()) .thenApply(GetVpcResult::id); var securityGroup = new SecurityGroup(\u0026#34;web-secgrp\u0026#34;, SecurityGroupArgs .builder() .description(\u0026#34;Enable HTTP Access\u0026#34;) .vpcId(Output.of(defaultVpcId)) .ingress( SecurityGroupIngressArgs.builder() .protocol(\u0026#34;tcp\u0026#34;) .fromPort(80) .toPort(80) .cidrBlocks(\u0026#34;0.0.0.0/0\u0026#34;) .build()) .build()); var ec2Instance = new Instance(\u0026#34;web-server\u0026#34;, InstanceArgs.builder() .instanceType(\u0026#34;t2.micro\u0026#34;) .vpcSecurityGroupIds(Output.all(securityGroup.getId())) .ami(Output.of(latestAmi)) .userData(\u0026#34;\u0026#34;\u0026#34; #!/bin/bash echo \u0026#34;Hello, World!\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp;\u0026#34;\u0026#34;\u0026#34;) .tags(Map.of(\u0026#34;Name\u0026#34;, \u0026#34;web-server\u0026#34;)) .build() ); ctx.export(\u0026#34;ip\u0026#34;, ec2Instance.publicIp()); ctx.export(\u0026#34;hostname\u0026#34;, ec2Instance.publicDns()); }); } } Step 2 — Provision the EC2 Instance and Access It To provision the VM, run:\npulumi up After confirming, you will see output like the following:\nUpdating (dev): Type Name Status + pulumi:pulumi:Stack iac-workshop-dev created + ├─ aws:ec2:SecurityGroup web-secgrp created + └─ aws:ec2:Instance web-server created Outputs: hostname: \u0026#34;ec2-52-57-250-206.eu-central-1.compute.amazonaws.com\u0026#34; ip : \u0026#34;52.57.250.206\u0026#34; Resources: + 3 created Duration: 40s Permalink: https://app.pulumi.com/jaxxstorm/iac-workshop/dev/updates/1 To verify that our server is accepting requests properly, curl either the hostname or IP address:\ncurl $(pulumi stack output hostname) Either way you should see a response from the webserver:\nHello, World! "
},
{
	"uri": "//localhost:1313/en/50_eks_platform/40_deploy_app/10_create_app.html",
	"title": "3.1 Create a Sample App",
	"tags": [],
	"description": "",
	"content": "To simulate the experience of a backend engineer deploying to your Kubernetes platform, we\u0026rsquo;ll write a small application in Go, that we want to use to deploy to a Kubernetes clyster.\nStep 1 — Create App Create a new directory in your Pulumi project called app:\nmkdir platform-app Inside that directory, add a main.go file which will serve a simple webserver that returns Hello, world!:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) func main() { r := gin.New() r.Use(gin.Logger()) r.Use(gin.Recovery()) r.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.String(http.StatusOK, \u0026#34;Hello, world!\u0026#34;) }) var listenPort string port, defined := os.LookupEnv(\u0026#34;LISTEN_PORT\u0026#34;) if defined { listenPort = port } else { listenPort = \u0026#34;80\u0026#34; } r.Run(fmt.Sprintf(\u0026#34;:%s\u0026#34;, listenPort)) } You\u0026rsquo;ll also need to create a go.mod file inside the app directory:\ngo mod init platform-app You can go test your application starts by using go run:\nLISTEN_PORT=8080 go run platform-app/main.go You should see your web server start, like so:\n[GIN-debug] [WARNING] Running in \u0026#34;debug\u0026#34; mode. Switch to \u0026#34;release\u0026#34; mode in production. - using env:\texport GIN_MODE=release - using code:\tgin.SetMode(gin.ReleaseMode) [GIN-debug] GET / --\u0026gt; main.main.func1 (3 handlers) [GIN-debug] Listening and serving HTTP on :8080 Step 2 — Create a Docker Image Next, we need to add a Dockerfile so we can push this Image to a registry. Inside the app directory, add a `Dockerfile that looks like this:\nFROM golang:buster as builder WORKDIR /app COPY . . ENV CGO_ENABLED=0 RUN go mod download \\ \u0026amp;\u0026amp; go build -o /app/webserver # Runtime container FROM scratch WORKDIR /app ENV LISTEN_PORT=80 COPY --from=builder /app/webserver /app/webserver ENTRYPOINT [ \u0026#34;/app/webserver\u0026#34; ] We\u0026rsquo;re using a Docker multi-stage build here to ensure we keep the image size as low as possible. This is the end of building our application.\nNow we have our docker container, we need to deploy it to our Kubernetes cluster.\n"
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts/40_container_thumbnailer/10_configuring_aws.html",
	"title": "3.2 Configuring AWS",
	"tags": [],
	"description": "",
	"content": "Now that you have a basic project, let\u0026rsquo;s configure AWS support for it.\nStep 1 — Install the AWS Package Run the following command to install the AWS packages:\nnpm install @pulumi/aws npm install @pulumi/awsx The package will be added to node_modules, package.json, and package-lock.json.\nStep 2 — Import the AWS Package Now that the AWS package is installed, we need to import it as part of our project:\nimport * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; Step 3 — Configure an AWS Region Configure the AWS region you would like to deploy to:\npulumi config set aws:region us-west-2 Feel free to choose any AWS region that supports the services used in these labs (see this table for a list of available regions).\n(Optional) Step 4 — Configure an AWS Profile If you\u0026rsquo;re using an alternative AWS profile, you can tell Pulumi which to use in one of two ways:\nUsing an environment variable: export AWS_PROFILE=\u0026lt;profile name\u0026gt; Using configuration: pulumi config set aws:profile \u0026lt;profile name\u0026gt; "
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java/40_ecs/20_create_cluster.html",
	"title": "3.2 Create an ECS Cluster &amp; LoadBalancer",
	"tags": [],
	"description": "",
	"content": "Step 1 — Create an ECS Cluster Remove all the boilerplate from the project bootstrap.\nAs a first step, we\u0026rsquo;re going to create an ECS cluster:\nvar cluster = new Cluster(\u0026#34;cluster\u0026#34;); \u0026#x2705; After this change, your App.java should look like this:\npackage myproject; import com.pulumi.Pulumi; import com.pulumi.aws.ecs.Cluster; public class App { public static void main(String[] args) { Pulumi.run(ctx -\u0026gt; { var cluster = new Cluster(\u0026#34;cluster\u0026#34;); }); } } Step 2 — Create a Load-Balanced Container Service Next, allocate the application load balancer (ALB) and listen for HTTP traffic port 80. In order to do this, we need to find the default VPC and the subnet groups for it:\nvar defaultVpcId = Ec2Functions .getVpc(GetVpcArgs.builder().default_(true).build()) .thenApply(GetVpcResult::id); var vpcSubnetsIds = defaultVpcId .thenCompose(vpcId -\u0026gt; Ec2Functions.getSubnetIds(GetSubnetIdsArgs.builder().vpcId(vpcId).build())) .thenApply(GetSubnetIdsResult::ids); var securityGroup = new SecurityGroup(\u0026#34;web-secgrp\u0026#34;, SecurityGroupArgs .builder() .description(\u0026#34;Enable HTTP Access\u0026#34;) .vpcId(Output.of(defaultVpcId)) .ingress( SecurityGroupIngressArgs.builder() .protocol(\u0026#34;tcp\u0026#34;) .fromPort(80) .toPort(80) .cidrBlocks(\u0026#34;0.0.0.0/0\u0026#34;) .build()) .egress( SecurityGroupEgressArgs.builder() .protocol(\u0026#34;-1\u0026#34;) .fromPort(0) .toPort(0) .cidrBlocks(\u0026#34;0.0.0.0/0\u0026#34;) .build() ) .build()); var loadBalancer = new LoadBalancer(\u0026#34;app-lb\u0026#34;, LoadBalancerArgs.builder() .internal(false) .securityGroups(Output.all(securityGroup.getId())) .subnets(Output.of(vpcSubnetsIds)) .loadBalancerType(\u0026#34;application\u0026#34;) .build() ); var targetGroup = new TargetGroup(\u0026#34;app-tg\u0026#34;, TargetGroupArgs.builder() .port(80) .protocol(\u0026#34;HTTP\u0026#34;) .targetType(\u0026#34;ip\u0026#34;) .vpcId(Output.of(defaultVpcId)) .build() ); var albListener = new Listener(\u0026#34;web\u0026#34;, ListenerArgs.builder() .loadBalancerArn(loadBalancer.arn()) .port(80) .defaultActions( ListenerDefaultActionArgs.builder() .type(\u0026#34;forward\u0026#34;) .targetGroupArn(targetGroup.arn()) .build()) .build() ); \u0026#x2705; After this change, your App.java should look like this:\npackage myproject; import com.pulumi.Pulumi; import com.pulumi.aws.alb.*; import com.pulumi.aws.alb.inputs.ListenerDefaultActionArgs; import com.pulumi.aws.ec2.Ec2Functions; import com.pulumi.aws.ec2.SecurityGroup; import com.pulumi.aws.ec2.SecurityGroupArgs; import com.pulumi.aws.ec2.inputs.GetSubnetIdsArgs; import com.pulumi.aws.ec2.inputs.GetVpcArgs; import com.pulumi.aws.ec2.inputs.SecurityGroupEgressArgs; import com.pulumi.aws.ec2.inputs.SecurityGroupIngressArgs; import com.pulumi.aws.ec2.outputs.GetSubnetIdsResult; import com.pulumi.aws.ec2.outputs.GetVpcResult; import com.pulumi.aws.ecs.Cluster; import com.pulumi.core.Output; public class App { public static void main(String[] args) { Pulumi.run(ctx -\u0026gt; { var cluster = new Cluster(\u0026#34;cluster\u0026#34;); var defaultVpcId = Ec2Functions .getVpc(GetVpcArgs.builder().default_(true).build()) .thenApply(GetVpcResult::id); var vpcSubnetsIds = defaultVpcId .thenCompose(vpcId -\u0026gt; Ec2Functions.getSubnetIds(GetSubnetIdsArgs.builder().vpcId(vpcId).build())) .thenApply(GetSubnetIdsResult::ids); var securityGroup = new SecurityGroup(\u0026#34;web-secgrp\u0026#34;, SecurityGroupArgs .builder() .description(\u0026#34;Enable HTTP Access\u0026#34;) .vpcId(Output.of(defaultVpcId)) .ingress( SecurityGroupIngressArgs.builder() .protocol(\u0026#34;tcp\u0026#34;) .fromPort(80) .toPort(80) .cidrBlocks(\u0026#34;0.0.0.0/0\u0026#34;) .build()) .egress( SecurityGroupEgressArgs.builder() .protocol(\u0026#34;-1\u0026#34;) .fromPort(0) .toPort(0) .cidrBlocks(\u0026#34;0.0.0.0/0\u0026#34;) .build() ) .build()); var loadBalancer = new LoadBalancer(\u0026#34;app-lb\u0026#34;, LoadBalancerArgs.builder() .internal(false) .securityGroups(Output.all(securityGroup.getId())) .subnets(Output.of(vpcSubnetsIds)) .loadBalancerType(\u0026#34;application\u0026#34;) .build() ); var targetGroup = new TargetGroup(\u0026#34;app-tg\u0026#34;, TargetGroupArgs.builder() .port(80) .protocol(\u0026#34;HTTP\u0026#34;) .targetType(\u0026#34;ip\u0026#34;) .vpcId(Output.of(defaultVpcId)) .build() ); var albListener = new Listener(\u0026#34;web\u0026#34;, ListenerArgs.builder() .loadBalancerArn(loadBalancer.arn()) .port(80) .defaultActions( ListenerDefaultActionArgs.builder() .type(\u0026#34;forward\u0026#34;) .targetGroupArn(targetGroup.arn()) .build()) .build() ); }); } } Run your program with pulumi up:\nUpdating (dev) Type Name Status + pulumi:pulumi:Stack java-dev created + ├─ aws:ecs:Cluster cluster created + ├─ aws:ec2:SecurityGroup web-secgrp created + ├─ aws:alb:TargetGroup app-tg created + ├─ aws:alb:LoadBalancer app-lb created + └─ aws:alb:Listener web created Resources: + 6 created Duration: 2m13s We\u0026rsquo;ve fleshed out our infrastructure and added a LoadBalancer we can add infrastructure to, in the next steps we\u0026rsquo;ll run a container.\n"
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python/40_ecs/10_configuring_aws.html",
	"title": "3.2 Installing and Configuring the AWS and AWSX Providers",
	"tags": [],
	"description": "",
	"content": "Now that we have our project boilerplate, we will add 2 Pulumi providers:\nAWS Classic, which gives us all the fundamental AWS resources, like VPC subnets. AWSx, which contains higher level Pulumi components, like a full, production-ready VPC that includes subnets, NAT gateways, routing tables, and so on. At the time of writing, AWSx is in beta and may change before its official 1.0 release. If you encounter any issues with AWSx, please file a GitHub issue.\nStep 1 — Install the AWS and AWSx Packages Pulumi created a virtualenv for us when we created our iac-workshop-ecs project. We\u0026rsquo;ll need to activate it to install dependencies:\nsource venv/bin/activate Add the following content to requirements.txt:\npulumi_aws\u0026gt;=5.0.0,\u0026lt;6.0.0 pulumi_awsx\u0026gt;=1.0.0-beta.9,\u0026lt;2.0.0 Run the following command to install the AWS and AWSx packages:\npip3 install -r requirements.txt Step 2 — Import the AWS Package Now that our packages are installed, we need to import them as part of our project.\nAdd the following to the top of your __main.py__:\nimport pulumi_aws as aws import pulumi_awsx as awsx \u0026#x2705; After this change, your __main__.py should look like this:\n\u0026#34;\u0026#34;\u0026#34;A Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws import pulumi_awsx as awsx Step 3 — Configure an AWS Region Configure the AWS region you would like to deploy to, replacing us-east-1 with your AWS region of choice:\npulumi config set aws:region us-east-1 Note that the previous command will create the file Pulumi.dev.yaml which contains the configuration for our dev stack. (Stacks are logical groupings of Pulumi resources.) We will be working with a single Pulumi stack in this tutorial, but we could define additional stacks to deploy our infrastructure to different regions/accounts with different parameters. To learn more about Pulumi stacks, see Stacks in the Pulumi docs.\n(Optional) Step 4 — Configure an AWS Profile If you are using an alternative AWS profile, you can tell Pulumi which to use in one of two ways:\nUsing an environment variable: export AWS_PROFILE=\u0026lt;profile name\u0026gt; Using configuration: pulumi config set aws:profile \u0026lt;profile name\u0026gt; "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/40_deploying_applications_to_eks/10_use_an_existing_cluster.html",
	"title": "3.2 Use an Existing Kubernetes Cluster",
	"tags": [],
	"description": "",
	"content": "Configure the use of a StackReference to the Kubernetes cluster stack to extract and use the kubeconfig. This can be found in the previous lab.\nLet\u0026rsquo;s start by adding these imports to your index.ts file:\nimport * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; Create a StackReference to the Kubernetes cluster stack using the config clusterStackRef stack setting.\nconst pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); Next, we need to declare a new Kubernetes provider based on the kubeconfig created in the cluster stack. To do this, add this to your index.ts file\n// Get the kubeconfig from the cluster stack output. const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;).apply(JSON.stringify); // Create the k8s provider with the kubeconfig. const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, { kubeconfig }); The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; const pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); // Get the kubeconfig from the cluster stack output. const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;).apply(JSON.stringify); // Create the k8s provider with the kubeconfig. const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, {kubeconfig}); "
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python/40_ecs/20_create_cluster.html",
	"title": "3.3 Create a VPC, ECS Cluster, &amp; Load Balancer",
	"tags": [],
	"description": "",
	"content": "Step 1 — Create a VPC First, we\u0026rsquo;ll create a VPC to host our ECS cluster. We\u0026rsquo;ll use the AWSx provider to do this. The AWSx provider contains higher-level constructs called component resources that allow us to create production-ready infrastructure without needing to declare every individual resource.\nAdd the following to your __main__.py:\nvpc = awsx.ec2.Vpc(\u0026#34;my-vpc\u0026#34;) \u0026#x2705; After this change, your __main__.py should look like this:\nimport pulumi as pulumi import pulumi_aws as aws import pulumi_awsx as awsx vpc = awsx.ec2.Vpc(\u0026#34;my-vpc\u0026#34;) To see how Pulumi components help us ship infrastructure faster with fewer lines of code, run pulumi preview to see all the resources that will be created. Notice how, with a single line of code and the default options, we have a complete, functional VPC, deployed across 3 AZs, with public and private subnets. To explore the options available in the VPC component, as well as the other components available in AWSx, see the AWSx API docs in the Pulumi Registry.\nStep 2 — Create an ECS Cluster Now we will add the ECS cluster itself.\nAdd the following to your __main__.py:\ncluster = aws.ecs.Cluster(\u0026#34;cluster\u0026#34;) \u0026#x2705; After this change, your __main__.py should look like this:\nimport pulumi as pulumi import pulumi_aws as aws import pulumi_awsx as awsx vpc = awsx.ec2.Vpc(\u0026#34;my-vpc\u0026#34;) cluster = aws.ecs.Cluster(\u0026#34;cluster\u0026#34;) Step 3 — Add Load Balancer Resources Next, we will add an application load balancer (ALB) to the public subnet of our VPC and listen for HTTP traffic port 80, plus some associated resources.\nAdd the following to your __main__.py:\ngroup = aws.ec2.SecurityGroup( \u0026#34;web-secgrp\u0026#34;, vpc_id=vpc.vpc_id, description=\u0026#34;Enable HTTP access\u0026#34;, ingress=[aws.ec2.SecurityGroupIngressArgs( protocol=\u0026#34;tcp\u0026#34;, from_port=80, to_port=80, cidr_blocks=[\u0026#34;0.0.0.0/0\u0026#34;], )], egress=[aws.ec2.SecurityGroupEgressArgs( protocol=\u0026#34;-1\u0026#34;, from_port=0, to_port=0, cidr_blocks=[\u0026#34;0.0.0.0/0\u0026#34;], )], ) alb = aws.lb.LoadBalancer( \u0026#34;app-lb\u0026#34;, security_groups=[group.id], subnets=vpc.public_subnet_ids, ) target_group = aws.lb.TargetGroup( \u0026#34;app-tg\u0026#34;, port=80, protocol=\u0026#34;HTTP\u0026#34;, target_type=\u0026#34;ip\u0026#34;, vpc_id=vpc.vpc_id, ) listener = aws.lb.Listener( \u0026#34;web\u0026#34;, load_balancer_arn=alb.arn, port=80, default_actions=[aws.lb.ListenerDefaultActionArgs( type=\u0026#34;forward\u0026#34;, target_group_arn=target_group.arn, )], ) \u0026#x2705; After this change, your __main__.py should look like this:\nimport pulumi as pulumi import pulumi_aws as aws import pulumi_awsx as awsx vpc = awsx.ec2.Vpc(\u0026#34;my-vpc\u0026#34;) cluster = aws.ecs.Cluster(\u0026#34;cluster\u0026#34;) group = aws.ec2.SecurityGroup( \u0026#34;web-secgrp\u0026#34;, vpc_id=vpc.vpc_id, description=\u0026#34;Enable HTTP access\u0026#34;, ingress=[aws.ec2.SecurityGroupIngressArgs( protocol=\u0026#34;tcp\u0026#34;, from_port=80, to_port=80, cidr_blocks=[\u0026#34;0.0.0.0/0\u0026#34;], )], egress=[aws.ec2.SecurityGroupEgressArgs( protocol=\u0026#34;-1\u0026#34;, from_port=0, to_port=0, cidr_blocks=[\u0026#34;0.0.0.0/0\u0026#34;], )], ) alb = aws.lb.LoadBalancer( \u0026#34;app-lb\u0026#34;, security_groups=[group.id], subnets=vpc.public_subnet_ids, ) target_group = aws.lb.TargetGroup( \u0026#34;app-tg\u0026#34;, port=80, protocol=\u0026#34;HTTP\u0026#34;, target_type=\u0026#34;ip\u0026#34;, vpc_id=vpc.vpc_id, ) listener = aws.lb.Listener( \u0026#34;web\u0026#34;, load_balancer_arn=alb.arn, port=80, default_actions=[aws.lb.ListenerDefaultActionArgs( type=\u0026#34;forward\u0026#34;, target_group_arn=target_group.arn, )], ) Run your program to deploy the infrastructure we\u0026rsquo;ve declared so far:\npulumi up In the next step, we\u0026rsquo;ll define a Fargate service and deploy a container.\n"
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/45_componens/10_create_component.html",
	"title": "4.2 Create a ComponentResource",
	"tags": [],
	"description": "",
	"content": "To create our component, first create a new file servicedeployment.ts, with the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; export interface ServiceDeploymentArgs { namespace?: pulumi.Input\u0026lt;string\u0026gt;; replicas?: pulumi.Input\u0026lt;number\u0026gt;; image: pulumi.Input\u0026lt;string\u0026gt;; port: k8s.types.input.core.v1.ServicePort; } export class ServiceDeployment extends pulumi.ComponentResource { deployment: k8s.apps.v1.Deployment; service: k8s.core.v1.Service; url: pulumi.Output\u0026lt;string\u0026gt;; constructor(name: string, args: ServiceDeploymentArgs, opts?: pulumi.ComponentResourceOptions) { super(\u0026#34;my:kubernetes:ServiceDeployment\u0026#34;, name, args, opts); // TODO } } The ServiceDeploymentArgs interface is the arguments we\u0026rsquo;ll allow to be passed to our component.\nThe ServiceDeployment class is a ComponentResource, meaning its a kind of Pulumi resource that can manage other resources. In our case, it will create and manage a Service and a Deployment. It will have three output properties, for the Service, the Deployment and the url of the service as a convenience.\nFirst we\u0026rsquo;ll add the deployment. Add the following to the // TODO section.\nconst appLabels = { app: name }; this.deployment = new k8s.apps.v1.Deployment(\u0026#34;eks-demos-app\u0026#34;, { metadata: { namespace: args.namespace }, spec: { selector: { matchLabels: appLabels }, replicas: args.replicas || 1, template: { metadata: { labels: appLabels }, spec: { containers: [{ name: \u0026#34;eks-demo-app\u0026#34;, image: args.image, }] } }, }, }, { parent: this }); This code is nearly the same as what we have in our index.ts - with three differences:\nWe use the name of the component as the app label. We use the provided replicas or else default to 1. We pass {parent: this} to indicate that the resource is a child of the ServiceDeployment component. Next, we do the same for our Service. Add the following code after the Deployment.\nthis.service = new k8s.core.v1.Service(\u0026#34;app-svc\u0026#34;, { metadata: { namespace: args.namespace }, spec: { selector: appLabels, ports: [args.port], type: \u0026#34;LoadBalancer\u0026#34;, } }, { parent: this }); const address = this.service.status.loadBalancer.ingress[0].hostname; const port = this.service.spec.ports[0].port; this.url = pulumi.interpolate`http://${address}:${port}`; Again, this is very similar to what we have in index.ts. We decide to be a little more opinionated here (we can choose how flexible we want our new component to be depending on the needs of our project and team - just like when we design APIs in our software projects) and require that we expose just a single port and that there is an HTTP service exposed on that port. We could of course customize this further is needed.\nThe servicedeployment.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; export interface ServiceDeploymentArgs { namespace?: pulumi.Input\u0026lt;string\u0026gt;; replicas?: pulumi.Input\u0026lt;number\u0026gt;; image: pulumi.Input\u0026lt;string\u0026gt;; port: k8s.types.input.core.v1.ServicePort; } export class ServiceDeployment extends pulumi.ComponentResource { deployment: k8s.apps.v1.Deployment; service: k8s.core.v1.Service; url: pulumi.Output\u0026lt;string\u0026gt;; constructor(name: string, args: ServiceDeploymentArgs, opts?: pulumi.ComponentResourceOptions) { super(\u0026#34;my:kubernetes:ServiceDeployment\u0026#34;, name, args, opts); const appLabels = { app: name }; this.deployment = new k8s.apps.v1.Deployment(\u0026#34;eks-demos-app\u0026#34;, { metadata: { namespace: args.namespace }, spec: { selector: { matchLabels: appLabels }, replicas: args.replicas || 1, template: { metadata: { labels: appLabels }, spec: { containers: [{ name: \u0026#34;eks-demo-app\u0026#34;, image: args.image, }] } }, }, }, { parent: this }); this.service = new k8s.core.v1.Service(\u0026#34;app-svc\u0026#34;, { metadata: { namespace: args.namespace }, spec: { selector: appLabels, ports: [args.port], type: \u0026#34;LoadBalancer\u0026#34;, } }, { parent: this }); const address = this.service.status.loadBalancer.ingress[0].hostname; const port = this.service.spec.ports[0].port; this.url = pulumi.interpolate`http://${address}:${port}`; } } "
},
{
	"uri": "//localhost:1313/en/10_prerequisites/aws_event.html",
	"title": "At an AWS Event",
	"tags": [],
	"description": "",
	"content": "To complete this workshop, you are provided with an AWS account via the AWS Event Engine service. A 12-digit hash will be provided to you by event staff - this is your unique access code. eg:\nCreate AWS Account 1 . Connect to the portal by clicking the button or browsing to https://dashboard.eventengine.run/. The following screen shows up. Enter the provided hash in the text box. The button on the bottom right corner changes to Accept Terms \u0026amp; Login. Click on that button to continue.\n2 . Choose AWS Console, then Open AWS Console. This account will expire at the end of the workshop and the all the resources created will be automatically deprovisioned. You will not be able to access this account after today.\n3 . Use a single region for the duration of this workshop. This workshop supports the following regions:\nus-west-2 (US West - Oregon) Please select US West (Oregon) in the top right corner.\nNext step Once you have completed the step above, you can leave the AWS console open. You can now move to the Workshop Setup section.\n"
},
{
	"uri": "//localhost:1313/en/additional-content/120_serverless_application_patterns/10_creating_a_dynamodb_table.html",
	"title": "Creating a DynamoDB Table",
	"tags": [],
	"description": "",
	"content": "Start by installing the AWS SDK package. This will allow you to query your DynamoDB from your Lambda:\n$ npm install aws-sdk Next you need to import the necessary packages to the top of your index.ts file:\nimport * as AWS from \u0026#34;aws-sdk\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; import * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; We can now create our DynamoDB Table:\nconst hits = new aws.dynamodb.Table(\u0026#34;hits\u0026#34;, { attributes: [{ name: \u0026#34;Site\u0026#34;, type: \u0026#34;S\u0026#34; }], hashKey: \u0026#34;Site\u0026#34;, billingMode: \u0026#34;PAY_PER_REQUEST\u0026#34;, }); The index.ts file should now have the following contents:\nimport * as AWS from \u0026#34;aws-sdk\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; import * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; const hits = new aws.dynamodb.Table(\u0026#34;hits\u0026#34;, { attributes: [{ name: \u0026#34;Site\u0026#34;, type: \u0026#34;S\u0026#34; }], hashKey: \u0026#34;Site\u0026#34;, billingMode: \u0026#34;PAY_PER_REQUEST\u0026#34;, }); This will create an Amazon EKS cluster situated in the default VPC for the region and a default node group that has two t2.medium instances and export the kubeconfig for us to use to interact with the cluster\nTo provision the EKS Cluster, run:\npulumi up After confirming, you will see output like the following:\nUpdating (dev): Type Name Status + pulumi:pulumi:Stack eks-workshop-dev created + └─ eks:index:Cluster eks created + ├─ eks:index:ServiceRole eks-instanceRole created + │ ├─ aws:iam:Role eks-instanceRole-role created + │ ├─ aws:iam:RolePolicyAttachment eks-instanceRole-03516f97 created + │ ├─ aws:iam:RolePolicyAttachment eks-instanceRole-3eb088f2 created + │ └─ aws:iam:RolePolicyAttachment eks-instanceRole-e1b295bd created + ├─ eks:index:ServiceRole eks-eksRole created + │ ├─ aws:iam:Role eks-eksRole-role created + │ ├─ aws:iam:RolePolicyAttachment eks-eksRole-90eb1c99 created + │ └─ aws:iam:RolePolicyAttachment eks-eksRole-4b490823 created + ├─ pulumi-nodejs:dynamic:Resource eks-cfnStackName created + ├─ aws:ec2:SecurityGroup eks-eksClusterSecurityGroup created + ├─ aws:iam:InstanceProfile eks-instanceProfile created + ├─ aws:eks:Cluster eks-eksCluster created + ├─ aws:ec2:SecurityGroupRule eks-eksClusterInternetEgressRule created + ├─ aws:ec2:SecurityGroup eks-nodeSecurityGroup created + ├─ aws:ec2:SecurityGroupRule eks-eksNodeClusterIngressRule created + ├─ aws:ec2:SecurityGroupRule eks-eksNodeIngressRule created + ├─ aws:ec2:SecurityGroupRule eks-eksClusterIngressRule created + ├─ aws:ec2:SecurityGroupRule eks-eksExtApiServerClusterIngressRule created + ├─ aws:ec2:SecurityGroupRule eks-eksNodeInternetEgressRule created + ├─ aws:ec2:LaunchConfiguration eks-nodeLaunchConfiguration created + ├─ pulumi:providers:kubernetes eks-eks-k8s created + ├─ pulumi-nodejs:dynamic:Resource eks-vpc-cni created + ├─ kubernetes:core:ConfigMap eks-nodeAccess created + ├─ aws:cloudformation:Stack eks-nodes created + └─ pulumi:providers:kubernetes eks-provider created Outputs: kubeconfig: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;: \\\u0026#34;v1\\\u0026#34;, \\\u0026#34;clusters\\\u0026#34;: ...}\u0026#34; Resources: + 28 created Duration: 14m40s Permalink: https://app.pulumi.com/workshops/eks-workshop/dev/updates/1 "
},
{
	"uri": "//localhost:1313/en/additional-content/100_provision_ec2_virtual_machines/10_creating_a_vm.html",
	"title": "Creating a VM",
	"tags": [],
	"description": "",
	"content": "Import the AWS package to your empty index.ts file:\nimport * as aws from \u0026#34;@pulumi/aws\u0026#34;; Now dynamically query the Amazon Linux machine image. Doing this in code avoids needing to hard-code the machine image (a.k.a., its AMI):\nconst ami = aws.getAmi({ filters: [{ name: \u0026#34;name\u0026#34;, values: [\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;] }], owners: [ \u0026#34;137112412989\u0026#34; ], mostRecent: true, }).then(ami =\u0026gt; ami.id); Next, create an AWS security group. This enables ping over ICMP and HTTP traffic on port 80:\nconst sg = new aws.ec2.SecurityGroup(\u0026#34;web-secgrp\u0026#34;, { ingress: [ { protocol: \u0026#34;icmp\u0026#34;, fromPort: 8, toPort: 0, cidrBlocks: [\u0026#34;0.0.0.0/0\u0026#34;] }, { protocol: \u0026#34;tcp\u0026#34;, fromPort: 80, toPort: 80, cidrBlocks: [\u0026#34;0.0.0.0/0\u0026#34;] }, ], }); Create the server. Notice it has a startup script that spins up a simple Python webserver:\nconst server = new aws.ec2.Instance(\u0026#34;web-server\u0026#34;, { instanceType: \u0026#34;t3.micro\u0026#34;, securityGroups: [ sg.name ], ami: ami, userData: \u0026#34;#!/bin/bash\\n\u0026#34;+ \u0026#34;echo \u0026#39;Hello, World!\u0026#39; \u0026gt; index.html\\n\u0026#34; + \u0026#34;nohup python -m SimpleHTTPServer 80 \u0026amp;\u0026#34;, tags: { \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34; }, }); For most real-world applications, you would want to create a dedicated image for your application, rather than embedding the script in your code like this.\nFinally export the VM\u0026rsquo;s resulting IP address and hostname:\nexport const ip = server.publicIp; export const hostname = server.publicDns; The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; const ami = aws.getAmi({ filters: [{ name: \u0026#34;name\u0026#34;, values: [\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;] }], owners: [ \u0026#34;137112412989\u0026#34; ], mostRecent: true, }).then(ami =\u0026gt; ami.id); const sg = new aws.ec2.SecurityGroup(\u0026#34;web-secgrp\u0026#34;, { ingress: [ { protocol: \u0026#34;icmp\u0026#34;, fromPort: 8, toPort: 0, cidrBlocks: [\u0026#34;0.0.0.0/0\u0026#34;] }, { protocol: \u0026#34;tcp\u0026#34;, fromPort: 80, toPort: 80, cidrBlocks: [\u0026#34;0.0.0.0/0\u0026#34;] }, ], }); const server = new aws.ec2.Instance(\u0026#34;web-server\u0026#34;, { instanceType: \u0026#34;t3.micro\u0026#34;, securityGroups: [ sg.name ], ami: ami, userData: \u0026#34;#!/bin/bash\\n\u0026#34;+ \u0026#34;echo \u0026#39;Hello, World!\u0026#39; \u0026gt; index.html\\n\u0026#34; + \u0026#34;nohup python -m SimpleHTTPServer 80 \u0026amp;\u0026#34;, tags: { \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34; }, }); export const ip = server.publicIp; export const hostname = server.publicDns; To provision the VM, run:\npulumi up After confirming, you will see output like the following:\nUpdating (dev): Type Name Status + pulumi:pulumi:Stack iac-workshop-dev created + ├─ aws:ec2:SecurityGroup web-secgrp created + └─ aws:ec2:Instance web-server created Outputs: hostname: \u0026#34;ec2-52-57-250-206.us-west-2.compute.amazonaws.com\u0026#34; ip : \u0026#34;52.57.250.206\u0026#34; Resources: + 3 created Duration: 40s Permalink: https://app.pulumi.com/workshops/ec2-workshop/dev/updates/1 To verify that our server is accepting requests properly, curl either the hostname or IP address.\ncurl $(pulumi stack output hostname) Either way you should see a response from the Python webserver:\nHello, World! The time for the machine to be provisioned in AWS can be a little slow, so initial requests to the endpoint may return \u0026ldquo;connection refused\u0026rdquo;\n"
},
{
	"uri": "//localhost:1313/en/additional-content/110_deploying_containers_to_ecs/10_creating_an_ecs_cluster.html",
	"title": "Creating an AWS ECS Cluster",
	"tags": [],
	"description": "",
	"content": "Install the AWSX package, if you haven\u0026rsquo;t already:\nnpm install @pulumi/awsx Import the AWSX and Pulumi packages in an empty index.ts file:\nimport * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; import * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; And now create a new ECS cluster. You will use the default values, so doing so is very concise:\nconst cluster = new awsx.ecs.Cluster(\u0026#34;cluster\u0026#34;); The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; const cluster = new awsx.ecs.Cluster(\u0026#34;cluster\u0026#34;); To provision the ECS Cluster, run:\npulumi up After confirming, you will see output like the following:\nUpdating (dev): Type Name Status + pulumi:pulumi:Stack ecs-workshop-dev created + ├─ awsx:x:ecs:Cluster cluster created + │ ├─ awsx:x:ec2:SecurityGroup cluster created + │ │ ├─ awsx:x:ec2:EgressSecurityGroupRule cluster-egress created + │ │ │ └─ aws:ec2:SecurityGroupRule cluster-egress created + │ │ ├─ awsx:x:ec2:IngressSecurityGroupRule cluster-containers created + │ │ │ └─ aws:ec2:SecurityGroupRule cluster-containers created + │ │ ├─ awsx:x:ec2:IngressSecurityGroupRule cluster-ssh created + │ │ │ └─ aws:ec2:SecurityGroupRule cluster-ssh created + │ │ └─ aws:ec2:SecurityGroup cluster created + │ └─ aws:ecs:Cluster cluster created + └─ awsx:x:ec2:Vpc default-vpc created + ├─ awsx:x:ec2:Subnet default-vpc-public-0 created + └─ awsx:x:ec2:Subnet default-vpc-public-1 created Resources: + 14 created Duration: 40s Permalink: https://app.pulumi.com/workshops/ecs-workshop/dev/updates/1 "
},
{
	"uri": "//localhost:1313/en/additional-content/110_deploying_containers_to_ecs/20_creating_a_loadbalanced_service.html",
	"title": "Creating an ECS Loadbalanced Service",
	"tags": [],
	"description": "",
	"content": "Next, allocate the application load balancer (ALB) and listen for HTTP traffic port 80. Make sure to pass along the ECS cluster\u0026rsquo;s security groups:\nconst alb = new awsx.elasticloadbalancingv2.ApplicationLoadBalancer( \u0026#34;app-lb\u0026#34;, { external: true, securityGroups: cluster.securityGroups }); const atg = alb.createTargetGroup( \u0026#34;app-tg\u0026#34;, { port: 80, deregistrationDelay: 0 }); const web = atg.createListener(\u0026#34;web\u0026#34;, { port: 80 }); Now declare the ECS service that will use \u0026ldquo;Fargate,\u0026rdquo; meaning you don\u0026rsquo;t need to manage the servers behind your ECS cluster. It will run the \u0026quot;nginx\u0026quot; image from the Docker Hub.\nconst appService = new awsx.ecs.FargateService(\u0026#34;app-svc\u0026#34;, { cluster, taskDefinitionArgs: { container: { image: \u0026#34;nginx\u0026#34;, portMappings: [ web ], }, }, desiredCount: 1, }); export const url = pulumi.interpolate`${web.endpoint.hostname}`; The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; const cluster = new awsx.ecs.Cluster(\u0026#34;cluster\u0026#34;); const alb = new awsx.elasticloadbalancingv2.ApplicationLoadBalancer( \u0026#34;app-lb\u0026#34;, { external: true, securityGroups: cluster.securityGroups }); const atg = alb.createTargetGroup( \u0026#34;app-tg\u0026#34;, { port: 80, deregistrationDelay: 0 }); const web = atg.createListener(\u0026#34;web\u0026#34;, { port: 80 }); const appService = new awsx.ecs.FargateService(\u0026#34;app-svc\u0026#34;, { cluster, taskDefinitionArgs: { container: { image: \u0026#34;nginx\u0026#34;, portMappings: [ web ], }, }, desiredCount: 1, }); export const url = pulumi.interpolate`${web.endpoint.hostname}`; To provision the ECS Cluster, run:\npulumi up After confirming, you will see output like the following:\nUpdating (dev): Type Name Status pulumi:pulumi:Stack ecs-workshop-dev + ├─ aws:lb:ApplicationLoadBalancer app-lb created + │ ├─ awsx:lb:ApplicationTargetGroup app-tg created + │ │ ├─ awsx:lb:ApplicationListener web created + │ │ │ ├─ awsx:x:ec2:IngressSecurityGroupRule web-external-0-ingress created + │ │ │ │ └─ aws:ec2:SecurityGroupRule web-external-0-ingress created + │ │ │ ├─ awsx:x:ec2:EgressSecurityGroupRule web-external-0-egress created + │ │ │ │ └─ aws:ec2:SecurityGroupRule web-external-0-egress created + │ │ │ └─ aws:lb:Listener web created + │ │ └─ aws:lb:TargetGroup app-tg created + │ └─ aws:lb:LoadBalancer app-lb created + ├─ awsx:x:ecs:FargateTaskDefinition app-svc created + │ ├─ aws:iam:Role app-svc-execution created + │ ├─ aws:cloudwatch:LogGroup app-svc created + │ ├─ aws:iam:Role app-svc-task created + │ ├─ aws:iam:RolePolicyAttachment app-svc-execution-9a42f520 created + │ ├─ aws:iam:RolePolicyAttachment app-svc-task-32be53a2 created + │ ├─ aws:iam:RolePolicyAttachment app-svc-task-fd1a00e5 created + │ └─ aws:ecs:TaskDefinition app-svc created + └─ awsx:x:ecs:FargateService app-svc created + └─ aws:ecs:Service app-svc created Outputs: + url: \u0026#34;app-lb-fd7bd4b-538931589.us-west-2.elb.amazonaws.com\u0026#34; Resources: + 20 created 14 unchanged Duration: 3m20s Permalink: https://app.pulumi.com/workshops/ecs-workshop/dev/updates/2 You can now curl the resulting endpoint:\ncurl $(pulumi stack output url) And you\u0026rsquo;ll see the Nginx default homepage:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; ... "
},
{
	"uri": "//localhost:1313/en/60_policy_as_code/10_intro_to_policy_as_code.html",
	"title": "Module 1: Intro to Policy as Code in Pulumi",
	"tags": [],
	"description": "",
	"content": "Intro to Policy as Code in Pulumi You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this module, you will use Pulumi\u0026rsquo;s policy as code features to ensure compliant infrastructure in AWS.\nStep 1: Create the directory structure We will start by creating a new directory to hold our code for this workshop and changing into it:\nmkdir workshop-policy-as-code cd workshop-policy-as-code Within our project, we will organize our infrastructure code (our Pulumi stack) and our policy packs into separate directories. Let\u0026rsquo;s create them now:\nmkdir infra policy Step 2: Initialize the infrastructure code Let\u0026rsquo;s initialize our infrastructure stack:\ncd infra pulumi new aws-python -n workshop-policy-as-code Accept the defaults for all prompts except possibly the AWS Region - choose a region near to you.\nReplace your __main__.py with the following content, which alters the S3 bucket to use the pulumi-read-write ACL:\n\u0026#34;\u0026#34;\u0026#34;An AWS Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws # Create an AWS resource (S3 Bucket) bucket = aws.s3.Bucket( \u0026#39;my-bucket\u0026#39;, aws.s3.BucketArgs( acl=\u0026#34;public-read-write\u0026#34;, ), ) # Export the name of the bucket pulumi.export(\u0026#39;bucket_name\u0026#39;, bucket.id) After Pulumi has finished initializing the project, ensure you\u0026rsquo;ve activated the Python virtual environment:\nsource venv/bin/activate Step 3: Install Pulumi policy pre-requisites In order to run the policy pack we are going to create, we need to add the pulumi_policy to our dependencies, even though we will not be using it directly in our Pulumi program. (Adding pulumi_policy is necessary due to the way Pulumi policy packs are implemented in Python.)\nRun the following command to add pulumi_policy as a dependency in the infra directory:\necho \u0026#34;pulumi_policy\u0026gt;=1.5.0,\u0026lt;2.0.0\u0026#34; \u0026gt;\u0026gt; requirements.txt Now we can install all of our dependencies:\npip install -r requirements.txt Step 4: Initialize and run a Pulumi policy pack Now we are ready to initialize a basic policy pack. Change to the policy directory:\ncd ../policy Initialize a Pulumi policy pack by running the following command:\npulumi policy new aws-python This command will create a Pulumi policy pack with a single policy that ensures S3 buckets do not have the public-read nor the public-read-write ACL. Feel free to check out policy/__main__.py for the details, but we\u0026rsquo;ll explore its contents author our own rules in a future module.\nLet\u0026rsquo;s activate the Python virtual environment and install requirements for the policy pack:\nsource venv/bin/activate pip install -r requirements.txt Back in the infra/ directory, let\u0026rsquo;s run the pulumi preview command against our policy pack by specifying the --policy-pack flag:\ncd ../infra pulumi preview --policy-pack ../policy The command should fail. You should see output similar to the following:\nPolicy Violations: [mandatory] aws-python v0.0.1 s3-no-public-read (aws:s3/bucket:Bucket: my-bucket) Prohibits setting the publicRead or publicReadWrite permission on AWS S3 buckets. You cannot set public-read or public-read-write on an S3 bucket. Read more about ACLs here: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html A few things to note:\nThe --policy-pack flag works with both the pulumi preview command and the pulumi up command. We can specify the --policy-pack flag multiple times to run any number of policy packs against our Pulumi program. Step 5: Exploring policy enforcement levels Each Pulumi policy in a policy pack may be set to one of the following enforcement levels:\nDisabled: The policy will not be run at all. Advisory: Pulumi will print a message stating a resource is not in compliance with the policy, but Pulumi commands will not fail. Mandatory: Pulumi will print a message stating a resource is not in compliance with the policy and Pulumi commands will fail. Let\u0026rsquo;s explore how these levels work. In policy/__main__.py, change the following line (toward the end of the file):\nenforcement_level=EnforcementLevel.MANDATORY, to this:\nenforcement_level=EnforcementLevel.ADVISORY, And let\u0026rsquo;s attempt to deploy our infrastructure:\npulumi up -y --policy-pack ../policy You\u0026rsquo;ll see that the command succeeds and our infrastructure deploys, but we still receive a warning that our infrastructure is not in compliance:\nPolicy Violations: [advisory] aws-python v0.0.1 s3-no-public-read (aws:s3/bucket:Bucket: my-bucket) Prohibits setting the publicRead or publicReadWrite permission on AWS S3 buckets. You cannot set public-read or public-read-write on an S3 bucket. Read more about ACLs here: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html Now let\u0026rsquo;s disable the rule altogether. Change this:\nenforcement_level=EnforcementLevel.ADVISORY, To this:\nenforcement_level=EnforcementLevel.DISABLED, And then attempt to deploy our infrastructure:\npulumi up -y --policy-pack ../policy The command will succeed (with no updates since we haven\u0026rsquo;t changed any of our infrastructure code - just our policy pack), but Pulumi will still indicate that our policy pack was indeed run:\nPolicy Packs run: Name Version aws-python (../policy) (local) Step 6: Policies run against existent resources Let\u0026rsquo;s demonstrate how Pulumi policy packs run against resources that are already deployed. In the previous step, we were able to deploy our non-compliant infrastructure because we set our policy enforcement level to ADVISORY. Now let\u0026rsquo;s change it back to MANDATORY.\nChange the following line in policy/__main__.py from this:\nenforcement_level=EnforcementLevel.DISABLED, to this:\nenforcement_level=EnforcementLevel.MANDATORY, And let\u0026rsquo;s attempt to run the following command:\npulumi up -y --policy-pack ../policy You\u0026rsquo;ll see that even though there are no changes in our infrastructure, the command still fails:\nDiagnostics: pulumi:pulumi:Stack (workshop-policy-as-code-dev): error: preview failed Policy Violations: [mandatory] aws-python v0.0.1 s3-no-public-read (aws:s3/bucket:Bucket: my-bucket) Prohibits setting the publicRead or publicReadWrite permission on AWS S3 buckets. You cannot set public-read or public-read-write on an S3 bucket. Read more about ACLs here: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html Pulumi policy packs are designed to check all resources in a stack, not just those that have changed. In this way, we can catch non-compliant resources that have already been deployed once a policy becomes mandatory. In a production scenario, we might consider rolling out policies first as ADVISORY to allow teams some time to comply with the policies, then change them to MANDATORY after teams have had sufficient time to become compliant.\n"
},
{
	"uri": "//localhost:1313/en/60_policy_as_code/20_authoring_policies.html",
	"title": "Module 2: Authoring Pulumi Policies",
	"tags": [],
	"description": "",
	"content": "Authoring Pulumi Policies You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this module, you will use Pulumi\u0026rsquo;s policy as code features to author your own policies.\nStep 1: Initialize the project If you are arriving at this module from Module 1, you can reuse your Pulumi program and policy pack from that module and skip this step. If not, run the following commands to initialize your workspace:\nmkdir workshop-policy-as-code cd workshop-policy-as-code mkdir infra policy Then, initialize a Pulumi program in the infra directory:\ncd infra pulumi new aws-python -n workshop-policy-as-code Choose the default for all options with the possible exception of AWS region - pick a region near to you.\nThen, initialize a Pulumi policy pack:\ncd ../policy pulumi policy new aws-python Step 2: Analyzing the structure of a Pulumi policy pack Let\u0026rsquo;s look at policy/__main__.py and break it down by sections so we get an understanding of how the code in Pulumi policy packs work.\nFirst, we import some required classes from pulumi-policy, the Python SDK for authoring policies:\nfrom pulumi_policy import ( EnforcementLevel, PolicyPack, ReportViolation, ResourceValidationArgs, ResourceValidationPolicy, ) Next we define our validator function:\ndef s3_no_public_read_validator(args: ResourceValidationArgs, report_violation: ReportViolation): if args.resource_type == \u0026#34;aws:s3/bucket:Bucket\u0026#34; and \u0026#34;acl\u0026#34; in args.props: acl = args.props[\u0026#34;acl\u0026#34;] if acl == \u0026#34;public-read\u0026#34; or acl == \u0026#34;public-read-write\u0026#34;: report_violation( \u0026#34;You cannot set public-read or public-read-write on an S3 bucket. \u0026#34; + \u0026#34;Read more about ACLs here: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html\u0026#34;) Validator functions for resources (there are also stack policies whose validators have a different signature and will be covered later in this module) take 2 arguments: ResourceValidationArgs which contains information about the resource we\u0026rsquo;re checking for compliance, and ReportViolation, a function we will invoke with a message if the resource is not in compliance.\nNext, we plug our validator function into the constructor for a ResourceValidationPolicy, also giving it a name and description. We can optionally add a default enforcement_level (whether the rule is disabled, advisory, or mandatory by default). This setting takes precedence over the default enforcement level for the entire policy pack. We can also an optional config_schema to allow our policy to be configurable. (We will cover configurable policies later in this module.):\ns3_no_public_read = ResourceValidationPolicy( name=\u0026#34;s3-no-public-read\u0026#34;, description=\u0026#34;Prohibits setting the publicRead or publicReadWrite permission on AWS S3 buckets.\u0026#34;, validate=s3_no_public_read_validator, ) Finally, we construct our PolicyPack which includes a name (which displays in the output of Pulumi commands when checking against our policies), the default enforcement level for all policies in the policy pack, and the policies to include in the pack:\nPolicyPack( name=\u0026#34;aws-python\u0026#34;, enforcement_level=EnforcementLevel.MANDATORY, policies=[ s3_no_public_read, ], ) Step 3: Authoring a resource policy Let\u0026rsquo;s add a new resource policy to our policy pack. This rule will ensure the force_destroy option is not set for our S3 bucket. The force_destroy option allows us to delete a bucket even if it has objects in it, so this is a wise policy to enforce for production S3 buckets.\nFirst, let\u0026rsquo;s add the force_destroy attribute to our S3 bucket:\nbucket = aws.s3.Bucket( \u0026#39;my-bucket\u0026#39;, aws.s3.BucketArgs( acl=\u0026#34;public-read\u0026#34;, # \u0026lt;-- ensure this line is present force_destroy=True, # \u0026lt;-- add this line ), ) Then, we\u0026rsquo;ll define our validator function. Add the following to policy/__main__.py:\ndef s3_no_force_destroy_validator(args: ResourceValidationArgs, report_violation: ReportViolation): if args.resource_type != \u0026#34;aws:s3/bucket:Bucket\u0026#34;: return if \u0026#34;forceDestroy\u0026#34; not in args.props: return if args.props[\u0026#34;forceDestroy\u0026#34;] == True: report_violation(\u0026#34;Force destroy must be disabled for S3 buckets.\u0026#34;) You might be wondering why we have to specify the attribute name as forceDestroy in our policy validator, rather than force_destroy, which is the name of the attribute in our Python Pulumi program where we define the bucket. Pulumi is a multi-language tool - the same provider (in this case, AWS Classic) can be consumed by Pulumi programs in multiple languages.\nWhen writing policies, we must reference language-neutral Pulumi identifiers which are a part of the provider\u0026rsquo;s schema, the magic behind the scenes which allows us to use the same provider for Pulumi programs written in different languages. Having to use these schema identifiers can be counter-intuitive at first, but by using the identifiers from the Pulumi schema we are able to use a policy written in any language (at the time of writing, Policy packs can be written in TypeScript or Python) against any Pulumi program, no matter what language we use to define our infrastructure!\nFor more details on Pulumi schemas, see the Pulumi docs.\nNext, we\u0026rsquo;ll create the ResourceValidationPolicy:\ns3_no_force_destroy = ResourceValidationPolicy( name=\u0026#34;s3-no-force-destroy\u0026#34;, description=\u0026#34;Prohibits setting force delete option in S3 buckets.\u0026#34;, validate=s3_no_force_destroy_validator, ) And finally, we\u0026rsquo;ll add our policy to the policy pack. Add the indicated line to the PolicyPack constructor:\nPolicyPack( name=\u0026#34;aws-python\u0026#34;, enforcement_level=EnforcementLevel.MANDATORY, policies=[ s3_no_public_read, s3_no_force_destroy, # \u0026lt;-- add this line ], ) Now let\u0026rsquo;s run our policy pack:\npulumi preview -y --policy-pack ../policy The command should fail with the following output:\nPolicy Violations: [mandatory] aws-python v0.0.1 s3-no-force-delete (aws:s3/bucket:Bucket: my-bucket) Prohibits setting force delete option in S3 buckets. Force destroy must be disabled for S3 buckets. [mandatory] aws-python v0.0.1 s3-no-public-read (aws:s3/bucket:Bucket: my-bucket) Prohibits setting the publicRead or publicReadWrite permission on AWS S3 buckets. You cannot set public-read or public-read-write on an S3 bucket. Read more about ACLs here: https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html Step 4: Cleaning up Let\u0026rsquo;s make sure we delete any resources we\u0026rsquo;ve created:\npulumi destroy -y And that\u0026rsquo;s it!\n"
},
{
	"uri": "//localhost:1313/en/10_prerequisites.html",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Prerequisites Start the Workshop... At an AWS Event ...on your own Create a workspace Create an IAM role for your workspace Attach the IAM role to your Workspace Update IAM settings for your Workspace Resize workspace\u0026#39;s EBS volume Install Pulumi \u0026amp; Language Dependencies "
},
{
	"uri": "//localhost:1313/en/additional-content/150_deploying_argocd_to_eks/10_use_an_existing_cluster.html",
	"title": "Use an Existing Kubernetes Cluster",
	"tags": [],
	"description": "",
	"content": "Configure the use of a StackReference to the Kubernetes cluster stack to extract and use the kubeconfig. This can be found in the previous lab.\nLet\u0026rsquo;s start by adding these imports to your index.ts file:\nimport * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; Create a StackReference to the Kubernetes cluster stack using the config clusterStackRef stack setting.\nconst pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); Next, we need to declare a new Kubernetes provider based on the kubeconfig created in the cluster stack. To do this, add this to your index.ts file\n// Get the kubeconfig from the cluster stack output. const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;); // Create the k8s provider with the kubeconfig. const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, { kubeconfig }); The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; const pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); // Get the kubeconfig from the cluster stack output. const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;); // Create the k8s provider with the kubeconfig. const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, {kubeconfig}); "
},
{
	"uri": "//localhost:1313/en/additional-content/160_gitops_for_socks_shop/10_use_an_existing_cluster.html",
	"title": "Use an Existing Kubernetes Cluster",
	"tags": [],
	"description": "",
	"content": "Configure the use of a StackReference to the Kubernetes cluster stack to extract and use the kubeconfig. This can be found in the previous lab.\nLet\u0026rsquo;s start by adding these imports to your index.ts file:\nimport * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; Create a StackReference to the Kubernetes cluster stack using the config clusterStackRef stack setting.\nconst pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); const argoStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;argoCDStackRef\u0026#34;)) Next, we need to declare a new Kubernetes provider based on the kubeconfig created in the cluster stack. To do this, add this to your index.ts file\n// Get the kubeconfig from the cluster stack output. const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;); // Create the k8s provider with the kubeconfig. const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, { kubeconfig }); The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; const pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); // Get the kubeconfig from the cluster stack output. const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;); // Create the k8s provider with the kubeconfig. const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, {kubeconfig}); "
},
{
	"uri": "//localhost:1313/en/10_prerequisites/self_paced.html",
	"title": "...on your own",
	"tags": [],
	"description": "",
	"content": "Running the workshop on your own Only complete this section if you are running the workshop on your own. If you are at an AWS hosted event (such as re:Invent, Kubecon, Immersion Day, etc), go to Start the workshop at an AWS event.\nCreate an AWS account "
},
{
	"uri": "//localhost:1313/en/10_prerequisites/workspace.html",
	"title": "Create a workspace",
	"tags": [],
	"description": "",
	"content": " The Cloud9 workspace should be built by an IAM user with Administrator privileges, not the root account user. Please ensure you are logged in as an IAM user, not the root account user.\nThis workshop was designed to run in the Oregon (us-west-2) region. Please don\u0026rsquo;t run in any other region. Future versions of this workshop will expand region availability, and this message will be removed.\nAd blockers, javascript disablers, and tracking blockers should be disabled for the cloud9 domain, or connecting to the workspace might be impacted. Cloud9 requires third-party-cookies. You can whitelist the specific domains.\nLaunch Cloud9: Create a Cloud9 Environment: https://us-west-2.console.aws.amazon.com/cloud9/home?region=us-west-2\nMake sure you are naming your Cloud9 environment Pulumi-Workshop, otherwise things will break later.\nSelect Create environment\nName it Pulumi-Workshop, and take all other defaults\nWhen it comes up, customize the environment by closing the welcome tab and lower work area, and opening a new terminal tab in the main work area: Your workspace should now look like this: If you like this theme, you can choose it yourself by selecting View / Themes / Solarized / Solarized Dark in the Cloud9 workspace menu.\n"
},
{
	"uri": "//localhost:1313/en/10_prerequisites/iamrole.html",
	"title": "Create an IAM role for your workspace",
	"tags": [],
	"description": "",
	"content": " Starting from here, when you see command to be entered such as below, you will enter these commands into Cloud9 IDE. You can use the Copy to clipboard feature (right hand upper corner) to simply copy and paste into Cloud9. In order to paste, you can use Ctrl + V for Windows or Command + V for Mac.\nFollow this deep link to create an IAM role with Administrator access. Confirm that AWS service and EC2 are selected, then click Next to view permissions. Confirm that AdministratorAccess is checked, then click Next to review. Enter Pulumi-Workshop-Admin for the Name, and select Create Role "
},
{
	"uri": "//localhost:1313/en/10_prerequisites/workspaceiam.html",
	"title": "Attach the IAM role to your Workspace",
	"tags": [],
	"description": "",
	"content": " Follow this deep link to find your Cloud9 EC2 instance Select the instance, then choose Actions / Instance Settings / Attach/Replace IAM Role Choose Pulumi-Workshop-Admin from the IAM Role drop down, and select Apply "
},
{
	"uri": "//localhost:1313/en/10_prerequisites/10_cloud.html",
	"title": "Update IAM settings for your Workspace",
	"tags": [],
	"description": "",
	"content": " Cloud9 normally manages IAM credentials dynamically. This isn\u0026rsquo;t currently compatible with the some AWS services authentication, so we will disable it and rely on the IAM role instead.\nReturn to your workspace and click the gear icon (in top right corner), or click to open a new tab and choose \u0026ldquo;Open Preferences\u0026rdquo; Select AWS SETTINGS Turn off AWS managed temporary credentials Close the Preferences tab Let\u0026rsquo;s run the command below, the following actions will take place as we do that:\n\u0026#x1f539; Install jq- jq is a command-line tool for parsing JSON\n\u0026#x1f539; Ensure temporary credentials aren’t already in place.\n\u0026#x1f539; Remove any existing credentials file.\n\u0026#x1f539; Set the region to work with our desired region.\n\u0026#x1f539; Validate that our IAM role is valid.\nsudo yum -y install jq rm -vf ${HOME}/.aws/credentials export ACCOUNT_ID=$(aws sts get-caller-identity --output text --query Account) export AWS_REGION=$(curl -s 169.254.169.254/latest/dynamic/instance-identity/document | jq -r \u0026#39;.region\u0026#39;) test -n \u0026#34;$AWS_REGION\u0026#34; \u0026amp;\u0026amp; echo AWS_REGION is \u0026#34;$AWS_REGION\u0026#34; || echo AWS_REGION is not set echo \u0026#34;export ACCOUNT_ID=${ACCOUNT_ID}\u0026#34; | tee -a ~/.bash_profile echo \u0026#34;export AWS_REGION=${AWS_REGION}\u0026#34; | tee -a ~/.bash_profile aws configure set default.region ${AWS_REGION} aws configure get default.region aws sts get-caller-identity --query Arn | grep Pulumi-Workshop-Admin -q \u0026amp;\u0026amp; echo \u0026#34;IAM role valid\u0026#34; || echo \u0026#34;IAM role NOT valid\u0026#34; If the IAM role is not valid, DO NOT PROCEED. Go back and confirm the steps on this page.\n"
},
{
	"uri": "//localhost:1313/en/50_eks_platform/20_provision_cluster/20_create_cluster.html",
	"title": "1.3 Create an EKS Cluster",
	"tags": [],
	"description": "",
	"content": "Now that you have a project configured to use AWS, you\u0026rsquo;ll need an AWS VPC configured for EKS. Let\u0026rsquo;s create that using Pulumi Crosswalk for AWS.\nStep 1 — Define the VPC Define your VPC. We\u0026rsquo;re going to create a VPC with public and private subnets like so:\nconst name = \u0026#39;lbriggs-workshop\u0026#39; // replace this with your name! const clusName = `${name}-cluster` const clusterTag = `kubernetes.io/cluster/${clusName}` // this defines a valid VPC that can be used for EKS const vpc = new awsx.ec2.Vpc(`vpc-${name}`, { cidrBlock: \u0026#34;172.16.0.0/24\u0026#34;, subnets: [ { type: \u0026#34;private\u0026#34;, tags: { [clusterTag]: \u0026#34;owned\u0026#34;, \u0026#34;kubernetes.io/role/internal-elb\u0026#34;: \u0026#34;1\u0026#34;, } }, { type: \u0026#34;public\u0026#34;, tags: { [clusterTag]: \u0026#34;owned\u0026#34;, \u0026#34;kubernetes.io/role/elb\u0026#34;: \u0026#34;1\u0026#34;, } }], tags: { Name: `${name}-vpc`, } }); The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; const name = \u0026#39;lbriggs-workshop\u0026#39; const clusName = `${name}-cluster` const clusterTag = `kubernetes.io/cluster/${clusName}` // this defines a valid VPC that can be used for EKS const vpc = new awsx.ec2.Vpc(`vpc-${name}`, { cidrBlock: \u0026#34;172.16.0.0/24\u0026#34;, subnets: [ { type: \u0026#34;private\u0026#34;, tags: { [clusterTag]: \u0026#34;owned\u0026#34;, \u0026#34;kubernetes.io/role/internal-elb\u0026#34;: \u0026#34;1\u0026#34;, } }, { type: \u0026#34;public\u0026#34;, tags: { [clusterTag]: \u0026#34;owned\u0026#34;, \u0026#34;kubernetes.io/role/elb\u0026#34;: \u0026#34;1\u0026#34;, } }], tags: { Name: `${name}-vpc`, } }); There are a couple things to break down here. The first is that we are specifying some important tags on the subnets inside the VPC, which are necessarily for some later components.\nThe second thing to note is that we\u0026rsquo;ve defined some thing as variables, so that we don\u0026rsquo;t make mistakes later.\nStep 2 — Define the Amazon EKS Cluster We\u0026rsquo;ll now add an EKS cluster in this project. In order to do this, we\u0026rsquo;ll use the Pulumi EKS package. Let\u0026rsquo;s install it first:\nnpm install @pulumi/eks And then we can add an EKS cluster to our index.ts file:\nimport * as eks from \u0026#34;@pulumi/eks\u0026#34;; const cluster = new eks.Cluster(name, { name: clusName, vpcId: vpc.id, privateSubnetIds: vpc.privateSubnetIds, publicSubnetIds: vpc.publicSubnetIds, instanceType: \u0026#34;t2.medium\u0026#34;, desiredCapacity: 2, minSize: 1, maxSize: 2, createOidcProvider: true, }); The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; import * as eks from \u0026#34;@pulumi/eks\u0026#34;; const name = \u0026#39;lbriggs-workshop\u0026#39; const clusName = `${name}-cluster` const clusterTag = `kubernetes.io/cluster/${clusName}` // this defines a valid VPC that can be used for EKS const vpc = new awsx.ec2.Vpc(`vpc-${name}`, { cidrBlock: \u0026#34;172.16.0.0/24\u0026#34;, subnets: [ { type: \u0026#34;private\u0026#34;, tags: { [clusterTag]: \u0026#34;owned\u0026#34;, \u0026#34;kubernetes.io/role/internal-elb\u0026#34;: \u0026#34;1\u0026#34;, } }, { type: \u0026#34;public\u0026#34;, tags: { [clusterTag]: \u0026#34;owned\u0026#34;, \u0026#34;kubernetes.io/role/elb\u0026#34;: \u0026#34;1\u0026#34;, } }], tags: { Name: `${name}-vpc`, } }); const cluster = new eks.Cluster(name, { name: clusName, vpcId: vpc.id, privateSubnetIds: vpc.privateSubnetIds, publicSubnetIds: vpc.publicSubnetIds, instanceType: \u0026#34;t2.medium\u0026#34;, desiredCapacity: 2, minSize: 1, maxSize: 2, createOidcProvider: true, }); Again, notice how we\u0026rsquo;re use the variables we\u0026rsquo;ve defined to reduce possible mistakes. In addition to this, we\u0026rsquo;re passing outputs from our VPC to our EKS cluster.\nStep 3 — Preview Your Changes Now preview your changes:\npulumi up This command evaluates your program, determines the resource updates to make, and shows you an outline of these changes:\npulumi up Previewing update (dev) View Live: https://app.pulumi.com/jaxxstorm/workshop-cluster/dev/previews/a23fbd93-81da-49b5-bb5b-22beeb69f487 Type Name Plan + pulumi:pulumi:Stack workshop-cluster-dev create + ├─ awsx:x:ec2:Vpc vpc-lbriggs-workshop create + │ ├─ awsx:x:ec2:Subnet vpc-lbriggs-workshop-public-1 create + │ │ ├─ aws:ec2:RouteTable vpc-lbriggs-workshop-public-1 create + │ │ ├─ aws:ec2:Subnet vpc-lbriggs-workshop-public-1 create + │ │ ├─ aws:ec2:Route vpc-lbriggs-workshop-public-1-ig create + │ │ └─ aws:ec2:RouteTableAssociation vpc-lbriggs-workshop-public-1 create + │ ├─ awsx:x:ec2:NatGateway vpc-lbriggs-workshop-0 create + │ │ ├─ aws:ec2:Eip vpc-lbriggs-workshop-0 create .... redacted ... Resources: + 59 to create Do you want to perform this update? [Use arrows to move, enter to select, type to filter] yes \u0026gt; no details This is a summary view and has been redacted for its length. In less than 50 lines of code, we\u0026rsquo;re defining a best practice VPC and an Amazon EKS cluster.\nStep 4 — Deploy Your Changes Now that we\u0026rsquo;ve seen the full set of changes, let\u0026rsquo;s deploy them. Select yes:\nThis creation process will take a little while, please be patient.\nDo you want to perform this update? yes Updating (dev) View Live: https://app.pulumi.com/jaxxstorm/workshop-cluster/dev/updates/3 Type Name Status Info + pulumi:pulumi:Stack workshop-cluster-dev creating... + ├─ eks:index:Cluster lbriggs-workshop creating. + │ ├─ eks:index:ServiceRole lbriggs-workshop-instanceRole created + │ │ ├─ aws:iam:Role lbriggs-workshop-instanceRole-role created + │ │ ├─ aws:iam:RolePolicyAttachment lbriggs-workshop-instanceRole-e1b295bd created + │ │ ├─ aws:iam:RolePolicyAttachment lbriggs-workshop-instanceRole-3eb088f2 created + ├─ eks:index:Cluster lbriggs-workshop creating... + ├─ eks:index:Cluster lbriggs-workshop creating. + ├─ eks:index:Cluster lbriggs-workshop creating.. ...... + ├─ awsx:x:ec2:NatGateway vpc-lbriggs-workshop-1 created + │ ├─ aws:ec2:Eip vpc-lbriggs-workshop-1 created + │ └─ aws:ec2:NatGateway vpc-lbriggs-workshop-1 created + └─ aws:ec2:Vpc vpc-lbriggs-workshop created Resources: + 59 created Duration: 14m33s At this stage, you should have a working EKS cluster.\nStep 5 — Access your Cluster Now that we have a cluster provisioned, we need to export our KUBECONFIG from the cluster so we can interact with it.\nAdd the following to the end of the index.ts file:\nexport const kubeconfig = cluster.kubeconfig export const clusterName = clusName export const vpcId = vpc.id export const clusterOidcProvider = cluster.core.oidcProvider?.url export const clusterOidcProviderArn = cluster.core.oidcProvider?.arn The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; import * as eks from \u0026#34;@pulumi/eks\u0026#34;; const name = \u0026#39;lbriggs-workshop\u0026#39; const clusName = `${name}-cluster` const clusterTag = `kubernetes.io/cluster/${clusName}` // this defines a valid VPC that can be used for EKS const vpc = new awsx.ec2.Vpc(`vpc-${name}`, { cidrBlock: \u0026#34;172.16.0.0/24\u0026#34;, subnets: [ { type: \u0026#34;private\u0026#34;, tags: { [clusterTag]: \u0026#34;owned\u0026#34;, \u0026#34;kubernetes.io/role/internal-elb\u0026#34;: \u0026#34;1\u0026#34;, } }, { type: \u0026#34;public\u0026#34;, tags: { [clusterTag]: \u0026#34;owned\u0026#34;, \u0026#34;kubernetes.io/role/elb\u0026#34;: \u0026#34;1\u0026#34;, } }], tags: { Name: `${name}-vpc`, } }); const cluster = new eks.Cluster(name, { name: clusName, vpcId: vpc.id, privateSubnetIds: vpc.privateSubnetIds, publicSubnetIds: vpc.publicSubnetIds, instanceType: \u0026#34;t2.medium\u0026#34;, desiredCapacity: 2, minSize: 1, maxSize: 2, createOidcProvider: true, }); export const kubeconfig = cluster.kubeconfig export const clusterName = clusName export const vpcId = vpc.id export const clusterOidcProvider = cluster.core.oidcProvider?.url export const clusterOidcProviderArn = cluster.core.oidcProvider?.arn This creates some outputs, one of which is the KUBECONFIG (the other two will be used later).\nRe-run your pulumi up command and hit yes, which will create some Outputs you can use:\nDo you want to perform this update? yes Updating (dev) View Live: https://app.pulumi.com/jaxxstorm/workshop-cluster/dev/updates/4 Type Name Status pulumi:pulumi:Stack workshop-cluster-dev └─ eks:index:Cluster lbriggs-workshop └─ aws:eks:Cluster lbriggs-workshop-eksCluster Outputs: + clusterOidcProvider : \u0026#34;oidc.eks.us-west-1.amazonaws.com/id/6C8ED2C48B8B2BD3022877F93BF16E7D\u0026#34; + clusterOidcProviderArn: \u0026#34;arn:aws:iam::616138583583:oidc-provider/oidc.eks.us-west-1.amazonaws.com/id/6C8ED2C48B8B2BD3022877F93BF16E7D\u0026#34; + kubeconfig : { + apiVersion : \u0026#34;v1\u0026#34; ... Once the outputs have been created, we can output the KUBECONFIG to a file using the pulumi stack output command:\npulumi stack output kubeconfig | tee ~/.kube/config This will give us the ability to use the kubectl command with our cluster. Let\u0026rsquo;s try that now:\nkubectl get nodes NAME STATUS ROLES AGE VERSION ip-172-16-0-101.us-west-1.compute.internal Ready \u0026lt;none\u0026gt; 9m10s v1.18.9-eks-d1db3c ip-172-16-0-28.us-west-1.compute.internal Ready \u0026lt;none\u0026gt; 9m18s v1.18.9-eks-d1db3c We\u0026rsquo;re now ready to deploy resources to our EKS cluster.\n"
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts/20_getting_started_with_pulumi/20_create_function.html",
	"title": "1.3 Provisioning a Lambda Function",
	"tags": [],
	"description": "",
	"content": "Now that you have a project configured to use AWS, you\u0026rsquo;ll create some basic infrastructure in it. Let\u0026rsquo;s create a simple lambda function.\nStep 1 — Create a Lambda Execution Role Add a role to your Pulumi project so that your Lambda function can execute.\nconst role = new aws.iam.Role(\u0026#39;my-function-role\u0026#39;, { assumeRolePolicy: aws.iam.assumeRolePolicyForPrincipal({ Service: \u0026#34;lambda.amazonaws.com\u0026#34; }) }) The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; const role = new aws.iam.Role(\u0026#39;my-function-role\u0026#39;, { assumeRolePolicy: aws.iam.assumeRolePolicyForPrincipal({ Service: \u0026#34;lambda.amazonaws.com\u0026#34; }) }) Step 2 — Declare a New Lambda Function We\u0026rsquo;ve defined an execution role, let\u0026rsquo;s define a Lambda function that uses this execution role.\nAdd the following to your index.ts file:\nconst lambdaFunction = new aws.lambda.Function(\u0026#39;my-function\u0026#39;, { role: role.arn, handler: \u0026#34;index.handler\u0026#34;, runtime: aws.lambda.NodeJS12dXRuntime, code: new pulumi.asset.AssetArchive({ \u0026#34;index.js\u0026#34;: new pulumi.asset.StringAsset( \u0026#34;exports.handler = (e, c, cb) =\u0026gt; cb(null, {statusCode: 200, body: \u0026#39;Hello, world!\u0026#39;});\u0026#34;, ), }), }) The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; const role = new aws.iam.Role(\u0026#39;my-function-role\u0026#39;, { assumeRolePolicy: aws.iam.assumeRolePolicyForPrincipal({ Service: \u0026#34;lambda.amazonaws.com\u0026#34; }) }) const lambdaFunction = new aws.lambda.Function(\u0026#39;my-function\u0026#39;, { role: role.arn, handler: \u0026#34;index.handler\u0026#34;, runtime: aws.lambda.NodeJS12dXRuntime, code: new pulumi.asset.AssetArchive({ \u0026#34;index.js\u0026#34;: new pulumi.asset.StringAsset( \u0026#34;exports.handler = (e, c, cb) =\u0026gt; cb(null, {statusCode: 200, body: \u0026#39;Hello, world!\u0026#39;});\u0026#34;, ), }), }) Step 3 — Preview Your Changes Now preview your changes:\npulumi up This command evaluates your program, determines the resource updates to make, and shows you an outline of these changes:\nPreviewing update (dev) View Live: https://app.pulumi.com/jaxxstorm/hello-world/dev/previews/855bb68e-7f45-4740-a7c5-e1acb10aeb04 Type Name Plan + pulumi:pulumi:Stack hello-world-dev create + ├─ aws:iam:Role my-function-role create + └─ aws:lambda:Function my-function create Resources: + 3 to create This is a summary view. Select details to view the full set of properties:\nDo you want to perform this update? details + pulumi:pulumi:Stack: (create) [urn=urn:pulumi:dev::hello-world::pulumi:pulumi:Stack::hello-world-dev] + aws:iam/role:Role: (create) [urn=urn:pulumi:dev::hello-world::aws:iam/role:Role::my-function-role] [provider=urn:pulumi:dev::hello-world::pulumi:providers:aws::default_3_16_0::04da6b54-80e4-46f7-96ec-b56ff0331ba9] assumeRolePolicy : \u0026#34;{\\\u0026#34;Statement\\\u0026#34;:[{\\\u0026#34;Action\\\u0026#34;:\\\u0026#34;sts:AssumeRole\\\u0026#34;,\\\u0026#34;Effect\\\u0026#34;:\\\u0026#34;Allow\\\u0026#34;,\\\u0026#34;Principal\\\u0026#34;:{\\\u0026#34;Service\\\u0026#34;:\\\u0026#34;lambda.amazonaws.com\\\u0026#34;},\\\u0026#34;Sid\\\u0026#34;:\\\u0026#34;AllowAssumeRole\\\u0026#34;}],\\\u0026#34;Version\\\u0026#34;:\\\u0026#34;2012-10-17\\\u0026#34;}\u0026#34; forceDetachPolicies: false maxSessionDuration : 3600 name : \u0026#34;my-function-role-13ec370\u0026#34; path : \u0026#34;/\u0026#34; + aws:lambda/function:Function: (create) [urn=urn:pulumi:dev::hello-world::aws:lambda/function:Function::my-function] [provider=urn:pulumi:dev::hello-world::pulumi:providers:aws::default_3_16_0::04da6b54-80e4-46f7-96ec-b56ff0331ba9] code : archive(assets:b898ebe) { \u0026#34;index.js\u0026#34;: asset(text:fd60d66) { \u0026lt;stripped\u0026gt; } } handler : \u0026#34;index.handler\u0026#34; memorySize : 128 name : \u0026#34;my-function-142ac16\u0026#34; publish : false reservedConcurrentExecutions: -1 role : output\u0026lt;string\u0026gt; runtime : \u0026#34;nodejs12.x\u0026#34; timeout : 3 The stack resource is a synthetic resource that all resources your program creates are parented to.\nStep 4 — Deploy Your Changes Now that we\u0026rsquo;ve seen the full set of changes, let\u0026rsquo;s deploy them. Select yes:\nUpdating (dev) View Live: https://app.pulumi.com/jaxxstorm/hello-world/dev/updates/4 Type Name Status + pulumi:pulumi:Stack hello-world-dev created + ├─ aws:iam:Role my-function-role created + └─ aws:lambda:Function my-function created Resources: + 3 created Duration: 27s Now our lambda function has been created in our AWS account. Feel free to click the Permalink URL and explore; this will take you to the Pulumi Console, which records your deployment history.\nStep 4 — Export Your Function Name To inspect your new Lambda function, you will need its name. Pulumi records a logical name, my-function, however the resulting AWS lambda function resource in AWS will be autogenerated.\nPrograms can export variables which will be shown in the CLI and recorded for each deployment. Export your lambda function\u0026rsquo;s name by adding this line to index.ts:\nexport const functionName = lambdaFunction.name The difference between logical and physical names is in part due to \u0026ldquo;auto-naming\u0026rdquo; which Pulumi does to ensure side-by-side projects and zero-downtime upgrades work seamlessly. It can be disabled if you wish; read more about auto-naming here.\nThe index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; const role = new aws.iam.Role(\u0026#39;my-function-role\u0026#39;, { assumeRolePolicy: aws.iam.assumeRolePolicyForPrincipal({ Service: \u0026#34;lambda.amazonaws.com\u0026#34; }) }) const lambdaFunction = new aws.lambda.Function(\u0026#39;my-function\u0026#39;, { role: role.arn, handler: \u0026#34;index.handler\u0026#34;, runtime: aws.lambda.NodeJS12dXRuntime, code: new pulumi.asset.AssetArchive({ \u0026#34;index.js\u0026#34;: new pulumi.asset.StringAsset( \u0026#34;exports.handler = (e, c, cb) =\u0026gt; cb(null, {statusCode: 200, body: \u0026#39;Hello, world!\u0026#39;});\u0026#34;, ), }), }) export const functionName = lambdaFunction.name Now deploy the changes:\npulumi up --yes Notice a new Outputs section is included in the output containing the lambda function\u0026rsquo;s name:\nPreviewing update (dev) View Live: https://app.pulumi.com/jaxxstorm/hello-world/dev/previews/ae4d29f1-e2f2-4ee4-89a2-f7e769ecd63e Type Name Plan pulumi:pulumi:Stack hello-world-dev Outputs: + functionName: \u0026#34;my-function-d60edb4\u0026#34; Resources: 3 unchanged Updating (dev) View Live: https://app.pulumi.com/jaxxstorm/hello-world/dev/updates/5 Type Name Status pulumi:pulumi:Stack hello-world-dev Outputs: + functionName: \u0026#34;my-function-d60edb4\u0026#34; Resources: 3 unchanged Duration: 2s Step 5 — Trigger your function We can now trigger out function using the AWS CLI\naws lambda invoke --function-name $(pulumi stack output functionName) /tmp/out This should tell us that the function executed successfully. We could go and look at the cloudwatch log group, but there\u0026rsquo;s an easier way we\u0026rsquo;ll be able to see in the next step.\nStep 6 — Destroy Everything Finally, destroy the resources and the stack itself:\npulumi destroy pulumi stack rm "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/20_getting_started_with_pulumi/20_provisioning_infrastructure.html",
	"title": "1.3 Provisioning Infrastructure",
	"tags": [],
	"description": "",
	"content": "Now that we have a project configured to use AWS, we can create some basic infrastructure. We will start with a simple S3 bucket.\nStep 1 — Declare a New Bucket Add the following to your index.ts file:\nconst bucket = new aws.s3.Bucket(\u0026#34;my-website-bucket\u0026#34;, { website: { indexDocument: \u0026#34;index.html\u0026#34;, }, }); After this change, your index.ts should look like this:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; const bucket = new aws.s3.Bucket(\u0026#34;my-website-bucket\u0026#34;, { website: { indexDocument: \u0026#34;index.html\u0026#34;, }, }); Step 2 — Preview and Deploy Your Changes Now let\u0026rsquo;s deploy our bucket:\npulumi up The pulumi up command evaluates our program, determines what the resources need to change, and shows us a preview of the planned changes. You\u0026rsquo;ll see output similar to the following:\nPreviewing update (dev) View Live: https://app.pulumi.com/username/iac-workshop/dev/previews/82f71dc2-077e-48d5-b574-e4575f27dad9 Type Name Plan + pulumi:pulumi:Stack iac-workshop-dev create + └─ aws:s3:Bucket my-website-bucket create Resources: + 2 to create Do you want to perform this update? [Use arrows to move, enter to select, type to filter] yes \u0026gt; no details The pulumi:pulumi:stack resource is the container for all of our infrastructure. Whenever we create a new stack with Pulumi, we\u0026rsquo;ll see this resource created. The second resource is our S3 bucket, which we declared in our program.\nNow that we\u0026rsquo;ve examined a preview of our changes, let\u0026rsquo;s deploy them. Select yes:\nUpdating (dev) View Live: https://app.pulumi.com/jkodroff/iac-workshop/dev/updates/1 Type Name Status + pulumi:pulumi:Stack iac-workshop-dev created + └─ aws:s3:Bucket my-website-bucket created Resources: + 2 created Duration: 7s Our S3 bucket has been created in our AWS account! Feel free to click the link in the command output and explore; this will take you to the Pulumi Service, which records your deployment history.\nIn the next step, we\u0026rsquo;ll add some files to our S3 bucket.\n"
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python/20_getting_started_with_pulumi/20_provisioning_infrastructure.html",
	"title": "1.3 Provisioning Infrastructure",
	"tags": [],
	"description": "",
	"content": "Now that we have a project configured to use AWS, we can create some basic infrastructure. We will start with a simple S3 bucket.\nStep 1 — Declare a New Bucket Add the following to your __main__.py file:\nbucket = aws.s3.Bucket( \u0026#34;my-website-bucket\u0026#34;, aws.s3.BucketArgs( website=aws.s3.BucketWebsiteArgs( index_document=\u0026#34;index.html\u0026#34; ) ) ) \u0026#x2705; After this change, your __main__.py should look like this:\n\u0026#34;\u0026#34;\u0026#34;A Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws aws.s3.Bucket( \u0026#34;my-website-bucket\u0026#34;, aws.s3.BucketArgs( website=aws.s3.BucketWebsiteArgs( index_document=\u0026#34;index.html\u0026#34; ) ) ) Step 2 — Preview and Deploy Your Changes Now let\u0026rsquo;s deploy our bucket:\npulumi up The pulumi up command evaluates our program, determines what the resources need to change, and shows us a preview of the planned changes. You\u0026rsquo;ll see output similar to the following:\nPreviewing update (dev) View Live: https://app.pulumi.com/username/iac-workshop/dev/previews/82f71dc2-077e-48d5-b574-e4575f27dad9 Type Name Plan + pulumi:pulumi:Stack iac-workshop-dev create + └─ aws:s3:Bucket my-website-bucket create Resources: + 2 to create Do you want to perform this update? [Use arrows to move, enter to select, type to filter] yes \u0026gt; no details The pulumi:pulumi:stack resource is the container for all of our infrastructure. Whenever we create a new stack with Pulumi, we\u0026rsquo;ll see this resource created. The second resource is our S3 bucket, which we declared in our program.\nNow that we\u0026rsquo;ve examined a preview of our changes, let\u0026rsquo;s deploy them. Select yes:\nUpdating (dev) View Live: https://app.pulumi.com/jkodroff/iac-workshop/dev/updates/1 Type Name Status + pulumi:pulumi:Stack iac-workshop-dev created + └─ aws:s3:Bucket my-website-bucket created Resources: + 2 created Duration: 7s Our S3 bucket has been created in our AWS account! Feel free to click the link in the command output and explore; this will take you to the Pulumi Service, which records your deployment history.\nIn the next step, we\u0026rsquo;ll add some files to our S3 bucket.\n"
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java/20_getting_started_with_pulumi/20_provisioning_infrastructure.html",
	"title": "1.3 Provisioning Infrastructure",
	"tags": [],
	"description": "",
	"content": "Now that you have a project configured to use AWS, you\u0026rsquo;ll create some basic infrastructure in it. We will start with a simple S3 bucket.\nStep 1 — Declare a New Bucket Update the imports in the App.java file as follows:\n// ... import com.pulumi.Pulumi; import com.pulumi.aws.s3.Bucket; import com.pulumi.aws.s3.BucketArgs; import com.pulumi.aws.s3.inputs.BucketWebsiteArgs; Add the following code to your main method in the App class in the App.java file:\n// ... var bucket = new Bucket(\u0026#34;my-website-bucket\u0026#34;, BucketArgs.builder() .website(BucketWebsiteArgs.builder().indexDocument(\u0026#34;index.html\u0026#34;).build()) .build() ); // ... \u0026#x2705; After this change, your App.java should look like this:\npackage myproject; import com.pulumi.Pulumi; import com.pulumi.aws.s3.Bucket; import com.pulumi.aws.s3.BucketArgs; import com.pulumi.aws.s3.inputs.BucketWebsiteArgs; public class App { public static void main(String[] args) { Pulumi.run(ctx -\u0026gt; { var bucket = new Bucket(\u0026#34;my-website-bucket\u0026#34;, BucketArgs.builder() .website(BucketWebsiteArgs.builder().indexDocument(\u0026#34;index.html\u0026#34;).build()) .build() ); }); } } Step 2 — Preview Your Changes Now preview your changes:\npulumi up This command evaluates your program, determines the resource updates to make, and shows you an outline of these changes:\nPreviewing update (dev): Type Name Plan + pulumi:pulumi:Stack java-iac-workshop-dev create + └─ aws:s3:Bucket my-website-bucket create Resources: + 2 to create Do you want to perform this update? yes \u0026gt; no details This is a summary view. Select details to view the full set of properties:\n+ pulumi:pulumi:Stack: (create) [urn=urn:pulumi:iac-workshop-dev::java::pulumi:pulumi:Stack::java-iac-workshop-dev] + aws:s3/bucket:Bucket: (create) [urn=urn:pulumi:iac-workshop-dev::java::aws:s3/bucket:Bucket::my-website-bucket] [provider=urn:pulumi:iac-workshop-dev::java::pulumi:providers:aws::default_4_37_3::04da6b54-80e4-46f7-96ec-b56ff0331ba9] acl : \u0026#34;private\u0026#34; bucket : \u0026#34;my-website-bucket-19643db\u0026#34; forceDestroy: false website : { indexDocument: \u0026#34;index.html\u0026#34; } Do you want to perform this update? [Use arrows to move, enter to select, type to filter] yes \u0026gt; no details The stack resource is a synthetic resource that all resources your program creates are parented to.\nStep 3 — Deploy Your Changes Now that we\u0026rsquo;ve seen the full set of changes, let\u0026rsquo;s deploy them. Select yes:\nUpdating (dev): Type Name Status + pulumi:pulumi:Stack java-iac-workshop-dev created + └─ aws:s3:Bucket my-website-bucket created Resources: + 2 created Duration: 8s Permalink: https://app.pulumi.com/workshops/iac-workshop/dev/updates/1 Now our S3 bucket has been created in our AWS account. Feel free to click the Permalink URL and explore; this will take you to the Pulumi Console, which records your deployment history.\nStep 4 — Export Your New Bucket Name To inspect your new bucket, you will need its physical AWS name. Pulumi records a logical name, my-bucket, however the resulting AWS name will be different.\nPrograms can export variables which will be shown in the CLI and recorded for each deployment. Export your bucket\u0026rsquo;s name by adding this line to App.java at the end of the main method:\n// ... ctx.export(\u0026#34;bucket_name\u0026#34;, bucket.bucket()); // ... \u0026#x2705; After this change, your Main.java should look like this:\npackage myproject; import com.pulumi.Pulumi; import com.pulumi.aws.s3.Bucket; import com.pulumi.aws.s3.BucketArgs; import com.pulumi.aws.s3.inputs.BucketWebsiteArgs; public class App { public static void main(String[] args) { Pulumi.run(ctx -\u0026gt; { var bucket = new Bucket(\u0026#34;my-website-bucket\u0026#34;, BucketArgs.builder() .website(BucketWebsiteArgs.builder().indexDocument(\u0026#34;index.html\u0026#34;).build()) .build() ); ctx.export(\u0026#34;bucket_name\u0026#34;, bucket.bucket()); }); } } Now deploy the changes:\npulumi up --yes Notice a new Outputs section is included in the output containing the bucket\u0026rsquo;s name:\nOutputs: + bucket_name: \u0026#34;my-website-bucket-4d8d96b\u0026#34; Resources: 2 unchanged Duration: 3s Permalink: https://app.pulumi.com/workshops/iac-workshop/dev/updates/2 The difference between logical and physical names is in part due to \u0026ldquo;auto-naming\u0026rdquo; which Pulumi does to ensure side-by-side projects and zero-downtime upgrades work seamlessly. It can be disabled if you wish; read more about auto-naming here.\nStep 5 — Inspect Your New Bucket Now run the aws CLI to list the objects in this new bucket:\naws s3 ls $(pulumi stack output bucket_name) Note that the bucket is currently empty, so you get a blank output without an error.\n"
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/30_deploying_webservers/20_provision_more_ec2.html",
	"title": "2.3 Add more EC2 Instances",
	"tags": [],
	"description": "",
	"content": "Step 1 – Add more EC2 instances Now you will create multiple EC2 instances, each running the same Python webserver, across all AWS availability zones in your region. Replace the part of your code that creates the webserver and exports the resulting IP address and hostname with the following:\n... ips = [] hostnames = [] for az in aws.get_availability_zones().names: server = aws.ec2.Instance(f\u0026#39;web-server-{az}\u0026#39;, instance_type=\u0026#34;t2.micro\u0026#34;, vpc_security_group_ids=[group.id], ami=ami.id, availability_zone=az, user_data=\u0026#34;\u0026#34;\u0026#34;#!/bin/bash echo \\\u0026#34;Hello, World -- from {}!\\\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp; \u0026#34;\u0026#34;\u0026#34;.format(az), tags={ \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34;, }, ) ips.append(server.public_ip) hostnames.append(server.public_dns) pulumi.export(\u0026#34;ips\u0026#34;, ips) pulumi.export(\u0026#34;hostnames\u0026#34;, hostnames) \u0026#x2705; After this change, your __main__.py should look like this:\n\u0026#34;\u0026#34;\u0026#34;An AWS Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws ami = aws.get_ami( most_recent=\u0026#34;true\u0026#34;, owners=[\u0026#34;137112412989\u0026#34;], filters=[{\u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;values\u0026#34;: [\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;]}], ) vpc = aws.ec2.get_vpc(default=True) group = aws.ec2.SecurityGroup( \u0026#34;web-secgrp\u0026#34;, description=\u0026#34;Enable HTTP Access\u0026#34;, vpc_id=vpc.id, ingress=[ { \u0026#34;protocol\u0026#34;: \u0026#34;icmp\u0026#34;, \u0026#34;from_port\u0026#34;: 8, \u0026#34;to_port\u0026#34;: 0, \u0026#34;cidr_blocks\u0026#34;: [\u0026#34;0.0.0.0/0\u0026#34;], }, { \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;from_port\u0026#34;: 80, \u0026#34;to_port\u0026#34;: 80, \u0026#34;cidr_blocks\u0026#34;: [\u0026#34;0.0.0.0/0\u0026#34;], }, ], ) ips = [] hostnames = [] for az in aws.get_availability_zones().names: server = aws.ec2.Instance( f\u0026#34;web-server-{az}\u0026#34;, instance_type=\u0026#34;t2.micro\u0026#34;, vpc_security_group_ids=[group.id], ami=ami.id, user_data=\u0026#34;\u0026#34;\u0026#34;#!/bin/bash echo \\\u0026#34;Hello, World -- from {}!\\\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp; \u0026#34;\u0026#34;\u0026#34;.format( az ), tags={ \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34;, }, ) ips.append(server.public_ip) hostnames.append(server.public_dns) pulumi.export(\u0026#34;ips\u0026#34;, ips) pulumi.export(\u0026#34;hostnames\u0026#34;, hostnames) Now run a command to update your stack with the new resource definitions:\npulumi up You will see output like the following:\nUpdating (dev): Type Name Plan pulumi:pulumi:Stack iac-workshop-webservers-dev + ├─ aws:ec2:Instance web-server-us-west-2a create + ├─ aws:ec2:Instance web-server-us-west-2b create + ├─ aws:ec2:Instance web-server-us-west-2c create + ├─ aws:ec2:Instance web-server-us-west-2d create - └─ aws:ec2:Instance web-server delete Outputs: - hostname : \u0026#34;ec2-18-236-225-249.us-west-2.compute.amazonaws.com\u0026#34; + hostnames: [ + [0]: \u0026#34;ec2-34-221-69-215.us-west-2.compute.amazonaws.com\u0026#34; + [1]: \u0026#34;ec2-54-202-104-111.us-west-2.compute.amazonaws.com\u0026#34; + [2]: \u0026#34;ec2-54-244-18-49.us-west-2.compute.amazonaws.com\u0026#34; + [3]: \u0026#34;ec2-18-236-225-249.us-west-2.compute.amazonaws.com\u0026#34; ] - ip : \u0026#34;18.236.225.249\u0026#34; + ips : [ + [0]: \u0026#34;34.221.69.215\u0026#34; + [1]: \u0026#34;54.202.104.111\u0026#34; + [2]: \u0026#34;54.244.18.49\u0026#34; + [3]: \u0026#34;18.236.225.249\u0026#34; ] Resources: + 4 created - 1 deleted 5 changes. 2 unchanged Duration: 1m2s Permalink: https://app.pulumi.com/jaxxstorm/iac-workshop/dev/updates/2 Notice that your original server was deleted and new ones created in its place, because its name changed.\nTo test the changes, curl any of the resulting IP addresses or hostnames:\nfor i in {0..2}; do curl $(pulumi stack output hostnames | jq -r \u0026#34;.[${i}]\u0026#34;); done The count of servers depends on the number of AZs in your region. Adjust the {0..2} accordingly.\nThe pulumi stack output command emits JSON serialized data — hence the use of the jq tool to extract a specific index. If you don\u0026rsquo;t have jq, don\u0026rsquo;t worry; simply copy-and-paste the hostname or IP address from the console output and curl that.\nNote that the webserver number is included in its response:\nHello, World -- from us-west-2a! Hello, World -- from us-west-2b! Hello, World -- from us-west-2c! "
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python/30_deploying_webservers/20_provision_more_ec2.html",
	"title": "2.3 Add more EC2 Instances",
	"tags": [],
	"description": "",
	"content": "Step 1 – Add more EC2 instances Now you will create multiple EC2 instances, each running the same Python webserver, across all AWS availability zones in your region. Replace the part of your code that creates the webserver and exports the resulting IP address and hostname with the following:\n... ips = [] hostnames = [] for az in aws.get_availability_zones().names: server = aws.ec2.Instance(f\u0026#39;web-server-{az}\u0026#39;, instance_type=\u0026#34;t2.micro\u0026#34;, vpc_security_group_ids=[group.id], ami=ami.id, availability_zone=az, user_data=\u0026#34;\u0026#34;\u0026#34;#!/bin/bash echo \\\u0026#34;Hello, World -- from {}!\\\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp; \u0026#34;\u0026#34;\u0026#34;.format(az), tags={ \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34;, }, ) ips.append(server.public_ip) hostnames.append(server.public_dns) pulumi.export(\u0026#34;ips\u0026#34;, ips) pulumi.export(\u0026#34;hostnames\u0026#34;, hostnames) \u0026#x2705; After this change, your __main__.py should look like this:\n\u0026#34;\u0026#34;\u0026#34;An AWS Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws ami = aws.get_ami( most_recent=\u0026#34;true\u0026#34;, owners=[\u0026#34;137112412989\u0026#34;], filters=[{\u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;values\u0026#34;: [\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;]}], ) vpc = aws.ec2.get_vpc(default=True) group = aws.ec2.SecurityGroup( \u0026#34;web-secgrp\u0026#34;, description=\u0026#34;Enable HTTP Access\u0026#34;, vpc_id=vpc.id, ingress=[ { \u0026#34;protocol\u0026#34;: \u0026#34;icmp\u0026#34;, \u0026#34;from_port\u0026#34;: 8, \u0026#34;to_port\u0026#34;: 0, \u0026#34;cidr_blocks\u0026#34;: [\u0026#34;0.0.0.0/0\u0026#34;], }, { \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;from_port\u0026#34;: 80, \u0026#34;to_port\u0026#34;: 80, \u0026#34;cidr_blocks\u0026#34;: [\u0026#34;0.0.0.0/0\u0026#34;], }, ], ) ips = [] hostnames = [] for az in aws.get_availability_zones().names: server = aws.ec2.Instance( f\u0026#34;web-server-{az}\u0026#34;, instance_type=\u0026#34;t2.micro\u0026#34;, vpc_security_group_ids=[group.id], ami=ami.id, user_data=\u0026#34;\u0026#34;\u0026#34;#!/bin/bash echo \\\u0026#34;Hello, World -- from {}!\\\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp; \u0026#34;\u0026#34;\u0026#34;.format( az ), tags={ \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34;, }, ) ips.append(server.public_ip) hostnames.append(server.public_dns) pulumi.export(\u0026#34;ips\u0026#34;, ips) pulumi.export(\u0026#34;hostnames\u0026#34;, hostnames) Now run a command to update your stack with the new resource definitions:\npulumi up You will see output like the following:\nUpdating (dev): Type Name Plan pulumi:pulumi:Stack iac-workshop-webservers-dev + ├─ aws:ec2:Instance web-server-us-west-2a create + ├─ aws:ec2:Instance web-server-us-west-2b create + ├─ aws:ec2:Instance web-server-us-west-2c create + ├─ aws:ec2:Instance web-server-us-west-2d create - └─ aws:ec2:Instance web-server delete Outputs: - hostname : \u0026#34;ec2-18-236-225-249.us-west-2.compute.amazonaws.com\u0026#34; + hostnames: [ + [0]: \u0026#34;ec2-34-221-69-215.us-west-2.compute.amazonaws.com\u0026#34; + [1]: \u0026#34;ec2-54-202-104-111.us-west-2.compute.amazonaws.com\u0026#34; + [2]: \u0026#34;ec2-54-244-18-49.us-west-2.compute.amazonaws.com\u0026#34; + [3]: \u0026#34;ec2-18-236-225-249.us-west-2.compute.amazonaws.com\u0026#34; ] - ip : \u0026#34;18.236.225.249\u0026#34; + ips : [ + [0]: \u0026#34;34.221.69.215\u0026#34; + [1]: \u0026#34;54.202.104.111\u0026#34; + [2]: \u0026#34;54.244.18.49\u0026#34; + [3]: \u0026#34;18.236.225.249\u0026#34; ] Resources: + 4 created - 1 deleted 5 changes. 2 unchanged Duration: 1m2s Permalink: https://app.pulumi.com/jaxxstorm/iac-workshop/dev/updates/2 Notice that your original server was deleted and new ones created in its place, because its name changed.\nTo test the changes, curl any of the resulting IP addresses or hostnames:\nfor i in {0..2}; do curl $(pulumi stack output hostnames | jq -r \u0026#34;.[${i}]\u0026#34;); done The count of servers depends on the number of AZs in your region. Adjust the {0..2} accordingly.\nThe pulumi stack output command emits JSON serialized data — hence the use of the jq tool to extract a specific index. If you don\u0026rsquo;t have jq, don\u0026rsquo;t worry; simply copy-and-paste the hostname or IP address from the console output and curl that.\nNote that the webserver number is included in its response:\nHello, World -- from us-west-2a! Hello, World -- from us-west-2b! Hello, World -- from us-west-2c! "
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java/30_deploying_webservers/20_provision_more_ec2.html",
	"title": "2.3 Add more EC2 Instances",
	"tags": [],
	"description": "",
	"content": "Step 1 – Add more EC2 instances Now you will create multiple EC2 instances, each running the same webserver, across all AWS availability zones in your region. Replace the part of your code that creates the webserver and exports the resulting IP address and hostname with the following:\nvar instances = AwsFunctions.getAvailabilityZones().thenApply(response -\u0026gt; response.zoneIds().stream().map(availabilityZone -\u0026gt; new Instance(\u0026#34;web-server-%s\u0026#34;.formatted(availabilityZone), InstanceArgs.builder() .instanceType(\u0026#34;t2.micro\u0026#34;) .vpcSecurityGroupIds(Output.all(securityGroup.getId())) .ami(Output.of(latestAmi)) .userData(\u0026#34;\u0026#34;\u0026#34; #!/bin/bash echo \u0026#34;Hello, World -- from %s!\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp;\u0026#34;\u0026#34;\u0026#34;.formatted(availabilityZone)) .tags(Map.of(\u0026#34;Name\u0026#34;, \u0026#34;web-server-%s\u0026#34;.formatted(availabilityZone))) .build() )).toList() ); var instancesOutput = Output.of(instances); var ipAddresses = instancesOutput.apply(ec2s -\u0026gt; Output.all(ec2s.stream().map(Instance::publicIp).toList())); var hostnames = instancesOutput.apply(ec2s -\u0026gt; Output.all(ec2s.stream().map(Instance::publicDns).toList())); ctx.export(\u0026#34;ips\u0026#34;, ipAddresses); ctx.export(\u0026#34;hostnames\u0026#34;, hostnames); \u0026#x2705; After this change, your App.java should look like this:\npackage myproject; import com.pulumi.Pulumi; import com.pulumi.aws.AwsFunctions; import com.pulumi.aws.ec2.*; import com.pulumi.aws.ec2.inputs.GetAmiArgs; import com.pulumi.aws.ec2.inputs.GetAmiFilter; import com.pulumi.aws.ec2.inputs.GetVpcArgs; import com.pulumi.aws.ec2.inputs.SecurityGroupIngressArgs; import com.pulumi.aws.ec2.outputs.GetAmiResult; import com.pulumi.aws.ec2.outputs.GetVpcResult; import com.pulumi.core.Output; import java.util.Map; public class App3 { public static void main(String[] args) { Pulumi.run(ctx -\u0026gt; { var latestAmi = Ec2Functions .getAmi( GetAmiArgs.builder() .mostRecent(true) .owners(\u0026#34;137112412989\u0026#34;) .filters(GetAmiFilter.builder().name(\u0026#34;name\u0026#34;).values(\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;).build()) .build() ).thenApply(GetAmiResult::id); var defaultVpcId = Ec2Functions .getVpc(GetVpcArgs.builder().default_(true).build()) .thenApply(GetVpcResult::id); var securityGroup = new SecurityGroup(\u0026#34;web-secgrp\u0026#34;, SecurityGroupArgs .builder() .description(\u0026#34;Enable HTTP Access\u0026#34;) .vpcId(Output.of(defaultVpcId)) .ingress( SecurityGroupIngressArgs.builder() .protocol(\u0026#34;tcp\u0026#34;) .fromPort(80) .toPort(80) .cidrBlocks(\u0026#34;0.0.0.0/0\u0026#34;) .build()) .build()); var instances = AwsFunctions.getAvailabilityZones().thenApply(response -\u0026gt; response.zoneIds().stream().map(availabilityZone -\u0026gt; new Instance(\u0026#34;web-server-%s\u0026#34;.formatted(availabilityZone), InstanceArgs.builder() .instanceType(\u0026#34;t2.micro\u0026#34;) .vpcSecurityGroupIds(Output.all(securityGroup.getId())) .ami(Output.of(latestAmi)) .userData(\u0026#34;\u0026#34;\u0026#34; #!/bin/bash echo \u0026#34;Hello, World -- from %s!\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp;\u0026#34;\u0026#34;\u0026#34;.formatted(availabilityZone)) .tags(Map.of(\u0026#34;Name\u0026#34;, \u0026#34;web-server-%s\u0026#34;.formatted(availabilityZone))) .build() )).toList() ); var instancesOutput = Output.of(instances); var ipAddresses = instancesOutput.apply(ec2s -\u0026gt; Output.all(ec2s.stream().map(Instance::publicIp).toList())); var hostnames = instancesOutput.apply(ec2s -\u0026gt; Output.all(ec2s.stream().map(Instance::publicDns).toList())); ctx.export(\u0026#34;ips\u0026#34;, ipAddresses); ctx.export(\u0026#34;hostnames\u0026#34;, hostnames); }); } } Now run a command to update your stack with the new resource definitions:\npulumi up You will see output like the following:\nUpdating (dev) Type Name Status pulumi:pulumi:Stack iac-workshop-webservers-dev + ├─ aws:ec2:Instance web-server-euw1-az3 created + ├─ aws:ec2:Instance web-server-euw1-az1 created + ├─ aws:ec2:Instance web-server-euw1-az2 created - └─ aws:ec2:Instance web-server deleted Outputs: - hostname : \u0026#34;ec2-54-229-215-7.eu-west-1.compute.amazonaws.com\u0026#34; + hostnames: [ + [0]: \u0026#34;ec2-34-253-216-194.eu-west-1.compute.amazonaws.com\u0026#34; + [1]: \u0026#34;ec2-18-203-162-39.eu-west-1.compute.amazonaws.com\u0026#34; + [2]: \u0026#34;ec2-54-155-163-18.eu-west-1.compute.amazonaws.com\u0026#34; ] - ip : \u0026#34;54.229.215.7\u0026#34; + ips : [ + [0]: \u0026#34;34.253.216.194\u0026#34; + [1]: \u0026#34;18.203.162.39\u0026#34; + [2]: \u0026#34;54.155.163.18\u0026#34; ] Resources: + 3 created - 1 deleted 4 changes. 2 unchanged Duration: 3m21s Notice that your original server was deleted and new ones created in its place, because its name changed.\nTo test the changes, curl any of the resulting IP addresses or hostnames. If you have the jq command installed, run the following command:\nfor i in {0..2}; do curl $(pulumi stack output hostnames | jq -r \u0026#34;.[${i}]\u0026#34;); done If you do not have jq installed, we recommend it. You can follow the installation instructions to get jq before continuing.\nThe count of servers depends on the number of AZs in your region. Adjust the {0..2} accordingly.\nThe pulumi stack output command emits JSON serialized data — hence the use of the jq tool to extract a specific index. If you don\u0026rsquo;t have jq, don\u0026rsquo;t worry; simply copy-and-paste the hostname or IP address from the console output and curl that.\nNote that the webserver number is included in its response:\nHello, World -- from euw1-az3! Hello, World -- from euw1-az1! Hello, World -- from euw1-az2! "
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts/30_simple_api_gateway/20_api_gateway_get.html",
	"title": "2.3 API Gateway",
	"tags": [],
	"description": "",
	"content": "Now that you have a project configured to use AWS, you\u0026rsquo;ll create some basic infrastructure in it. Let\u0026rsquo;s use AWS crosswalk to define a lambda function.\nStep 1 — Declare a New Lambda Function Add the following to your index.ts file:\nconst api = new awsx.apigateway.API(\u0026#34;hello-world\u0026#34;, { routes: [{ path: \u0026#34;/\u0026#34;, method: \u0026#34;GET\u0026#34;, eventHandler: async (event) =\u0026gt; { return { statusCode: 200, body: \u0026#34;Hello, world!\u0026#34;, }; }, }], }) The index.ts file should now have the following contents:\nimport * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; const api = new awsx.apigateway.API(\u0026#34;hello-world\u0026#34;, { routes: [{ path: \u0026#34;/\u0026#34;, method: \u0026#34;GET\u0026#34;, eventHandler: async (event) =\u0026gt; { return { statusCode: 200, body: \u0026#34;Hello, world!\u0026#34;, }; }, }], }) Step 2 — Preview Your Changes Now preview your changes:\npulumi up This command evaluates your program, determines the resource updates to make, and shows you an outline of these changes:\nPreviewing update (dev) View Live: https://app.pulumi.com/jaxxstorm/api-gateway/dev/previews/01278a6e-b06c-4301-bff5-ba145f69b68d Type Name Plan + pulumi:pulumi:Stack api-gateway-dev create + └─ aws:apigateway:x:API hello-world create + ├─ aws:iam:Role hello-world4c238266 create + ├─ aws:lambda:Function hello-world4c238266 create + ├─ aws:iam:RolePolicyAttachment hello-world4c238266-32be53a2 create + ├─ aws:apigateway:RestApi hello-world create + ├─ aws:apigateway:Deployment hello-world create + ├─ aws:lambda:Permission hello-world-fa520765 create + └─ aws:apigateway:Stage hello-world create This is a summary view. Select details to view the full set of properties:\n+ pulumi:pulumi:Stack: (create) [urn=urn:pulumi:dev::api-gateway::pulumi:pulumi:Stack::api-gateway-dev] + aws:apigateway:x:API: (create) [urn=urn:pulumi:dev::api-gateway::aws:apigateway:x:API::hello-world] + aws:iam/role:Role: (create) [urn=urn:pulumi:dev::api-gateway::aws:apigateway:x:API$aws:iam/role:Role::hello-world4c238266] [provider=urn:pulumi:dev::api-gateway::pulumi:providers:aws::default_3_17_0::04da6b54-80e4-46f7-96ec-b56ff0331ba9] assumeRolePolicy : \u0026#34;{\\\u0026#34;Version\\\u0026#34;:\\\u0026#34;2012-10-17\\\u0026#34;,\\\u0026#34;Statement\\\u0026#34;:[{\\\u0026#34;Action\\\u0026#34;:\\\u0026#34;sts:AssumeRole\\\u0026#34;,\\\u0026#34;Principal\\\u0026#34;:{\\\u0026#34;Service\\\u0026#34;:\\\u0026#34;lambda.amazonaws.com\\\u0026#34;},\\\u0026#34;Effect\\\u0026#34;:\\\u0026#34;Allow\\\u0026#34;,\\\u0026#34;Sid\\\u0026#34;:\\\u0026#34;\\\u0026#34;}]}\u0026#34; forceDetachPolicies: false maxSessionDuration : 3600 name : \u0026#34;hello-world4c238266-7ca9af6\u0026#34; path : \u0026#34;/\u0026#34; ... The stack resource is a synthetic resource that all resources your program creates are parented to.\nYou\u0026rsquo;ll notice here that despite only defining a single resource, the Pulumi program has many resources inside it. This is because we\u0026rsquo;re using Pulumi Crosswalk to define our function, which is an abstraction around the basic resources. It defines best practices for you out of the box.\nStep 3 — Deploy Your Changes Now that we\u0026rsquo;ve seen the full set of changes, let\u0026rsquo;s deploy them. Select yes:\nUpdating (dev) View Live: https://app.pulumi.com/jaxxstorm/api-gateway/dev/updates/1 Type Name Status + pulumi:pulumi:Stack api-gateway-dev created + └─ aws:apigateway:x:API hello-world created + ├─ aws:iam:Role hello-world4c238266 created + ├─ aws:lambda:Function hello-world4c238266 created + ├─ aws:iam:RolePolicyAttachment hello-world4c238266-32be53a2 created + ├─ aws:apigateway:RestApi hello-world created + ├─ aws:apigateway:Deployment hello-world created + ├─ aws:lambda:Permission hello-world-fa520765 created + └─ aws:apigateway:Stage hello-world created Now our lambda function has been created in our AWS account. Feel free to click the Permalink URL and explore; this will take you to the Pulumi Console, which records your deployment history.\nStep 4 — Export Your API Gateway URL To inspect your new hello world function, you will need the url from the created API gateway. Pulumi records a logical name, hello-world for the resources in the stack, however the resulting AWS API gateway URL is generated on the server side by AWS..\nPrograms can export variables which will be shown in the CLI and recorded for each deployment. Export your API gateway\u0026rsquo;s URL name by adding this line to index.ts:\nexport const url = api.url; The difference between logical and physical names is in part due to \u0026ldquo;auto-naming\u0026rdquo; which Pulumi does to ensure side-by-side projects and zero-downtime upgrades work seamlessly. It can be disabled if you wish; read more about auto-naming here.\nThe index.ts file should now have the following contents:\nimport * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; // Define a new GET endpoint that just returns a 200 and \u0026#34;hello\u0026#34; in the body. const api = new awsx.apigateway.API(\u0026#34;hello-world\u0026#34;, { routes: [{ path: \u0026#34;/\u0026#34;, method: \u0026#34;GET\u0026#34;, eventHandler: async (event) =\u0026gt; { // This code runs in an AWS Lambda anytime `/` is hit. return { statusCode: 200, body: \u0026#34;Hello, world!\u0026#34;, }; }, }], }) // Export the auto-generated API Gateway base URL. export const url = api.url; Now deploy the changes:\npulumi up --yes Notice a new Outputs section is included in the output containing the API Gateway URL:\nOutputs: + url: \u0026#34;https://8i41k0ifjd.execute-api.us-east-1.amazonaws.com/stage/\u0026#34; Step 5 — Inspect Your API Gateway contents We can get a response from our lambda function using curl:\ncurl $(pulumi stack output url) "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/30_deploying_eks_cluster/20_creating_an_eks_cluster.html",
	"title": "2.3 Creating an Amazon EKS Cluster",
	"tags": [],
	"description": "",
	"content": "Add the Pulumi EKS import to your index.ts file:\nimport * as eks from \u0026#34;@pulumi/eks\u0026#34;; Then add the following to your index.ts to create the EKS cluster referencing the previously created vpc and to deploy a fargate profile.\nSee for more details and examples:\nAPI Docs Examples const cluster = new eks.Cluster(\u0026#34;eks\u0026#34;, { vpcId: vpc.id, privateSubnetIds: vpc.privateSubnetIds, publicSubnetIds: vpc.publicSubnetIds, }); We\u0026rsquo;ll need to the cluster\u0026rsquo;s kubeconfig to interact with the cluster.\nWe can retrieve it from the cluster by adding the following to your index.ts:\nexport const kubeconfig = cluster.kubeconfig; The index.ts file should now have the following contents:\nimport * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; import * as eks from \u0026#34;@pulumi/eks\u0026#34;; const vpc = new awsx.ec2.Vpc(\u0026#34;workshop-vpc\u0026#34;, {}); const cluster = new eks.Cluster(\u0026#34;eks\u0026#34;, { vpcId: vpc.id, privateSubnetIds: vpc.privateSubnetIds, publicSubnetIds: vpc.publicSubnetIds, }); export const clusterName = cluster.eksCluster.name export const kubeconfig = cluster.kubeconfig; This will create an Amazon EKS cluster situated in the previously created vpc and deploy a node pool for the cluster then export the kubeconfig for us to use to interact with the cluster\nTo provision the EKS Cluster, run:\npulumi up After confirming, you will see output like the following:\nUpdating (dev): Type Name Status pulumi:pulumi:Stack eks-infrastructure-dev + └─ eks:index:Cluster eks created + ├─ eks:index:ServiceRole eks-eksRole created + │ ├─ aws:iam:Role eks-eksRole-role created + │ ├─ aws:iam:RolePolicyAttachment eks-eksRole-4b490823 created + │ └─ aws:iam:RolePolicyAttachment eks-eksRole-90eb1c99 created + ├─ eks:index:ServiceRole eks-instanceRole created + │ ├─ aws:iam:Role eks-instanceRole-role created + │ ├─ aws:iam:RolePolicyAttachment eks-instanceRole-03516f97 created + │ ├─ aws:iam:RolePolicyAttachment eks-instanceRole-3eb088f2 created + │ └─ aws:iam:RolePolicyAttachment eks-instanceRole-e1b295bd created + ├─ pulumi-nodejs:dynamic:Resource eks-cfnStackName created + ├─ aws:ec2:SecurityGroup eks-eksClusterSecurityGroup created + ├─ aws:iam:InstanceProfile eks-instanceProfile created + ├─ aws:ec2:SecurityGroupRule eks-eksClusterInternetEgressRule created + ├─ aws:eks:Cluster eks-eksCluster created + ├─ aws:ec2:SecurityGroup eks-nodeSecurityGroup created + ├─ aws:ec2:SecurityGroupRule eks-eksClusterIngressRule created + ├─ aws:ec2:SecurityGroupRule eks-eksNodeInternetEgressRule created + ├─ aws:ec2:SecurityGroupRule eks-eksExtApiServerClusterIngressRule created + ├─ aws:ec2:SecurityGroupRule eks-eksNodeIngressRule created + ├─ aws:ec2:SecurityGroupRule eks-eksNodeClusterIngressRule created + ├─ aws:ec2:LaunchConfiguration eks-nodeLaunchConfiguration created + ├─ pulumi:providers:kubernetes eks-eks-k8s created + ├─ pulumi-nodejs:dynamic:Resource eks-vpc-cni created + ├─ kubernetes:core:ConfigMap eks-nodeAccess created + ├─ aws:cloudformation:Stack eks-nodes created + └─ pulumi:providers:kubernetes eks-provider created Outputs: kubeconfig: \u0026#34;{\\\u0026#34;apiVersion\\\u0026#34;: \\\u0026#34;v1\\\u0026#34;, \\\u0026#34;clusters\\\u0026#34;: ...}\u0026#34; Resources: + 27 created 27 changes. 31 unchanged Duration: 14m40s Permalink: https://app.pulumi.com/workshops/eks-infrastructure/dev/updates/2 "
},
{
	"uri": "//localhost:1313/en/50_eks_platform/40_deploy_app/20_build_binary.html",
	"title": "3.2 Build Platform Binary",
	"tags": [],
	"description": "",
	"content": "We\u0026rsquo;ve created an application - how do we get it into our Kubernetes cluster?\nDevelopers often like to use command line tools to deploy applications. We\u0026rsquo;ll build a command line tool locally.\nStep 1 — Clone the Repo Our first step is to clone the Git repository containing the app locally.\ngit clone https://github.com/jaxxstorm/ploy.git Change into this directory now ready to build our application:\ncd ploy Step 2 — Examine the Repo This repo contains Pulumi code which uses the Automation API. A lot of the code is used to build a CLI application using popular the Go package Cobra\nHowever, if you examine the code in pkg/program/program.go you\u0026rsquo;ll notice a Go function NewPloyDeployment.\nThis is a Pulumi component which encapulates a set of Pulumi resources.\nIn order to deploy our application to our Kubernetes cluster, we\u0026rsquo;ll need:\nan ECR repository a Docker Image Kubernetes resources All of this is done via the command line tool.\nWe could also write a Pulumi program that uses the same logic, but this CLI tool can be used with no underlying knowledge of Pulumi.\nStep 3 — Build the binary It might be the case that you\u0026rsquo;re unable to build the binary on the Cloud9 instance. If you\u0026rsquo;re struggling to build it, you can download a pre-built binary from here: https://github.com/jaxxstorm/ploy/releases/download/v0.0.2-alpha/ploy-v0.0.2-alpha-linux-amd64.tar.gz\nWe\u0026rsquo;ll need to build the binary so we can use it. You can do this using the go build command:\ngo build -o ploy ./cmd/ploy/main.go The EC2 Cloud9 instance comes with several Docker Images on it that might mean you run out of space. If this happens, clear out these images - you won\u0026rsquo;t need them:\ndocker rmi $(docker images -q) You should be able to run the ploy command now locally:\n./ploy Deploy your applications Usage: ploy [command] Available Commands: destroy Remove your application get Get all ploy deployed applications help Help about any command up Deploy your application Flags: --debug Enable debug logging -h, --help help for ploy -o, --org string Pulumi org to use for your stack -r, --region string AWS Region to use (default \u0026#34;us-west-2\u0026#34;) Use \u0026#34;ploy [command] --help\u0026#34; for more information about a command. "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/40_deploying_applications_to_eks/20_create_a_namespace.html",
	"title": "3.3 Creating a Namespace",
	"tags": [],
	"description": "",
	"content": "Next, declare a namespace object. This will scope your objects to a name of your choosing, so that in this workshop you won\u0026rsquo;t accidentally interfere with other participants.\nAppend this to your index.ts file, replacing eks-infrastructure with your own name and referencing the Provider created in the previous step:\nconst ns = new k8s.core.v1.Namespace(\u0026#34;app-ns\u0026#34;, { metadata: { name: \u0026#34;eks-demo-apps\u0026#34; }, }, { provider }); The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; const pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); // Get the kubeconfig from the cluster stack output. const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;); // Create the k8s provider with the kubeconfig. const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, { kubeconfig }); const ns = new k8s.core.v1.Namespace(\u0026#34;eks-demo-apps-ns\u0026#34;, { metadata: { name: \u0026#34;eks-demo-apps\u0026#34; }, }, { provider }); "
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java/40_ecs/30_deploy_service.html",
	"title": "3.3 Deploy a Docker Image",
	"tags": [],
	"description": "",
	"content": "Step 1 — Create ECS FargateService In order to create a Fargate service, we need to add an IAM Role and a Task Definition and Service. the ECS Cluster will run the \u0026quot;nginx\u0026quot; image from the Docker Hub.\nLet\u0026rsquo;s define our IAM Role and attach a policy. You should define this at the end of your App.java:\nvar role = new Role(\u0026#34;task-exec-role\u0026#34;, RoleArgs.builder() .assumeRolePolicy(\u0026#34;\u0026#34;\u0026#34; { \u0026#34;Version\u0026#34;: \u0026#34;2008-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: {\u0026#34;Service\u0026#34;: \u0026#34;ecs-tasks.amazonaws.com\u0026#34;}, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] }\u0026#34;\u0026#34;\u0026#34;) .build() ); var policyAttachment = new RolePolicyAttachment(\u0026#34;task-exec-policy\u0026#34;, RolePolicyAttachmentArgs.builder() .role(role.name()) .policyArn(\u0026#34;arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy\u0026#34;) .build() ); Then we can define a task definition for our ECS service and the service itself:\nvar taskDefinition = new TaskDefinition(\u0026#34;app-task\u0026#34;, TaskDefinitionArgs.builder() .family(\u0026#34;fargate-task-definition\u0026#34;) .cpu(\u0026#34;256\u0026#34;) .memory(\u0026#34;512\u0026#34;) .networkMode(\u0026#34;awsvpc\u0026#34;) .requiresCompatibilities(\u0026#34;FARGATE\u0026#34;) .executionRoleArn(role.arn()) .containerDefinitions(\u0026#34;\u0026#34;\u0026#34; [ { \u0026#34;name\u0026#34;: \u0026#34;my-app\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;nginx\u0026#34;, \u0026#34;portMappings\u0026#34;: [{\u0026#34;containerPort\u0026#34;: 80, \u0026#34;hostPort\u0026#34;: 80, \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;}] } ]\u0026#34;\u0026#34;\u0026#34;) .build() ); var service = new Service(\u0026#34;app-svc\u0026#34;, ServiceArgs.builder() .cluster(cluster.arn()) .desiredCount(1) .launchType(\u0026#34;FARGATE\u0026#34;) .taskDefinition(taskDefinition.arn()) .networkConfiguration( ServiceNetworkConfigurationArgs.builder() .assignPublicIp(true) .subnets(Output.of(vpcSubnetsIds)) .securityGroups(Output.all(securityGroup.getId())) .build() ) .loadBalancers( ServiceLoadBalancerArgs.builder() .targetGroupArn(targetGroup.arn()) .containerName(\u0026#34;my-app\u0026#34;) .containerPort(80) .build() ) .build(), CustomResourceOptions.builder() .dependsOn(albListener) .build() ); ctx.export(\u0026#34;url\u0026#34;, loadBalancer.dnsName()); \u0026#x2705; After these changes, your App.java should look like this\npackage myproject; import com.pulumi.Pulumi; import com.pulumi.aws.alb.*; import com.pulumi.aws.alb.inputs.ListenerDefaultActionArgs; import com.pulumi.aws.ec2.Ec2Functions; import com.pulumi.aws.ec2.SecurityGroup; import com.pulumi.aws.ec2.SecurityGroupArgs; import com.pulumi.aws.ec2.inputs.GetSubnetIdsArgs; import com.pulumi.aws.ec2.inputs.GetVpcArgs; import com.pulumi.aws.ec2.inputs.SecurityGroupEgressArgs; import com.pulumi.aws.ec2.inputs.SecurityGroupIngressArgs; import com.pulumi.aws.ec2.outputs.GetSubnetIdsResult; import com.pulumi.aws.ec2.outputs.GetVpcResult; import com.pulumi.aws.ecs.*; import com.pulumi.aws.ecs.inputs.ServiceLoadBalancerArgs; import com.pulumi.aws.ecs.inputs.ServiceNetworkConfigurationArgs; import com.pulumi.aws.iam.Role; import com.pulumi.aws.iam.RoleArgs; import com.pulumi.aws.iam.RolePolicyAttachment; import com.pulumi.aws.iam.RolePolicyAttachmentArgs; import com.pulumi.core.Output; import com.pulumi.resources.CustomResourceOptions; public class App { public static void main(String[] args) { Pulumi.run(ctx -\u0026gt; { var cluster = new Cluster(\u0026#34;cluster\u0026#34;); var defaultVpcId = Ec2Functions .getVpc(GetVpcArgs.builder().default_(true).build()) .thenApply(GetVpcResult::id); var vpcSubnetsIds = defaultVpcId .thenCompose(vpcId -\u0026gt; Ec2Functions.getSubnetIds(GetSubnetIdsArgs.builder().vpcId(vpcId).build())) .thenApply(GetSubnetIdsResult::ids); var securityGroup = new SecurityGroup(\u0026#34;web-secgrp\u0026#34;, SecurityGroupArgs .builder() .description(\u0026#34;Enable HTTP Access\u0026#34;) .vpcId(Output.of(defaultVpcId)) .ingress( SecurityGroupIngressArgs.builder() .protocol(\u0026#34;tcp\u0026#34;) .fromPort(80) .toPort(80) .cidrBlocks(\u0026#34;0.0.0.0/0\u0026#34;) .build()) .egress( SecurityGroupEgressArgs.builder() .protocol(\u0026#34;-1\u0026#34;) .fromPort(0) .toPort(0) .cidrBlocks(\u0026#34;0.0.0.0/0\u0026#34;) .build() ) .build()); var loadBalancer = new LoadBalancer(\u0026#34;app-lb\u0026#34;, LoadBalancerArgs.builder() .internal(false) .securityGroups(Output.all(securityGroup.getId())) .subnets(Output.of(vpcSubnetsIds)) .loadBalancerType(\u0026#34;application\u0026#34;) .build() ); var targetGroup = new TargetGroup(\u0026#34;app-tg\u0026#34;, TargetGroupArgs.builder() .port(80) .protocol(\u0026#34;HTTP\u0026#34;) .targetType(\u0026#34;ip\u0026#34;) .vpcId(Output.of(defaultVpcId)) .build() ); var albListener = new Listener(\u0026#34;web\u0026#34;, ListenerArgs.builder() .loadBalancerArn(loadBalancer.arn()) .port(80) .defaultActions( ListenerDefaultActionArgs.builder() .type(\u0026#34;forward\u0026#34;) .targetGroupArn(targetGroup.arn()) .build()) .build() ); var role = new Role(\u0026#34;task-exec-role\u0026#34;, RoleArgs.builder() .assumeRolePolicy(\u0026#34;\u0026#34;\u0026#34; { \u0026#34;Version\u0026#34;: \u0026#34;2008-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: {\u0026#34;Service\u0026#34;: \u0026#34;ecs-tasks.amazonaws.com\u0026#34;}, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] }\u0026#34;\u0026#34;\u0026#34;) .build() ); var policyAttachment = new RolePolicyAttachment(\u0026#34;task-exec-policy\u0026#34;, RolePolicyAttachmentArgs.builder() .role(role.name()) .policyArn(\u0026#34;arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy\u0026#34;) .build() ); var taskDefinition = new TaskDefinition(\u0026#34;app-task\u0026#34;, TaskDefinitionArgs.builder() .family(\u0026#34;fargate-task-definition\u0026#34;) .cpu(\u0026#34;256\u0026#34;) .memory(\u0026#34;512\u0026#34;) .networkMode(\u0026#34;awsvpc\u0026#34;) .requiresCompatibilities(\u0026#34;FARGATE\u0026#34;) .executionRoleArn(role.arn()) .containerDefinitions(\u0026#34;\u0026#34;\u0026#34; [ { \u0026#34;name\u0026#34;: \u0026#34;my-app\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;nginx\u0026#34;, \u0026#34;portMappings\u0026#34;: [{\u0026#34;containerPort\u0026#34;: 80, \u0026#34;hostPort\u0026#34;: 80, \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;}] } ]\u0026#34;\u0026#34;\u0026#34;) .build() ); var service = new Service(\u0026#34;app-svc\u0026#34;, ServiceArgs.builder() .cluster(cluster.arn()) .desiredCount(1) .launchType(\u0026#34;FARGATE\u0026#34;) .taskDefinition(taskDefinition.arn()) .networkConfiguration( ServiceNetworkConfigurationArgs.builder() .assignPublicIp(true) .subnets(Output.of(vpcSubnetsIds)) .securityGroups(Output.all(securityGroup.getId())) .build() ) .loadBalancers( ServiceLoadBalancerArgs.builder() .targetGroupArn(targetGroup.arn()) .containerName(\u0026#34;my-app\u0026#34;) .containerPort(80) .build() ) .build(), CustomResourceOptions.builder() .dependsOn(albListener) .build() ); ctx.export(\u0026#34;url\u0026#34;, loadBalancer.dnsName()); }); } } Step 2 — Provision the Cluster and Service Deploy the program to stand up your initial cluster and service:\npulumi up This will output the status and resulting load balancer URL:\nUpdating (dev) Type Name Status pulumi:pulumi:Stack java-dev + ├─ aws:iam:Role task-exec-role created + ├─ aws:ecs:TaskDefinition app-task created + ├─ aws:iam:RolePolicyAttachment task-exec-policy created + └─ aws:ecs:Service app-svc created Outputs: + url: \u0026#34;app-lb-598a127-1152695482.eu-west-1.elb.amazonaws.com\u0026#34; Resources: + 4 created 6 unchanged Duration: 9s You can now curl the resulting endpoint:\ncurl $(pulumi stack output url) And you\u0026rsquo;ll see the Nginx default homepage:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; ... Step 3 — Update the Service Now, let\u0026rsquo;s also update the desired container count from 1 to 3.\nTo do this, we need to adjust the ServiceArgsBuilder\n... ServiceArgs.builder() .desiredCount(3) ... Next update the stack:\npulumi up The output should look something like this:\nUpdating (dev) Type Name Status Info pulumi:pulumi:Stack java-dev ~ └─ aws:ecs:Service app-svc updated [diff: ~desiredCount] Outputs: url: \u0026#34;app-lb-598a127-1152695482.eu-west-1.elb.amazonaws.com\u0026#34; Resources: ~ 1 updated 9 unchanged Duration: 6s Step 4 — Destroy Everything Finally, destroy the resources and the stack itself:\npulumi destroy pulumi stack rm "
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts/40_container_thumbnailer/20_create_thumbnailer.html",
	"title": "3.3 Thumbnailer Container",
	"tags": [],
	"description": "",
	"content": "Now that you have a project configured to use AWS, we can create the thumbnailer. We\u0026rsquo;ll use the AWS Lambda Containers for this.\nStep 1 — Create a Docker Image Create a new directory within your Pulumi project called app\nmkdir app Next, create a Dockerfile within the app directory and use it to build ffmpeg into the image:\nFROM amazon/aws-lambda-nodejs:12 ARG FUNCTION_DIR=\u0026#34;/var/task\u0026#34; # Install tar and xz RUN yum install tar xz unzip -y # Install awscli RUN curl \u0026#34;https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\u0026#34; -o \u0026#34;awscliv2.zip\u0026#34; -s RUN unzip -q awscliv2.zip RUN ./aws/install # Install ffmpeg RUN curl https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz -o ffmpeg.tar.xz -s RUN tar -xf ffmpeg.tar.xz RUN mv ffmpeg-4.4-amd64-static/ffmpeg /usr/bin # Create function directory RUN mkdir -p ${FUNCTION_DIR} # Copy handler function and package.json COPY index.js ${FUNCTION_DIR} # Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile) CMD [ \u0026#34;index.handler\u0026#34; ] You\u0026rsquo;ll notice you\u0026rsquo;re specifying an index.handler as the command, but we haven\u0026rsquo;t defined it yet.\nStep 2 — Define your lambda script Inside the app/ directory, let\u0026rsquo;s create index.js which becomes your Lambda entrypoint.\n\u0026#39;use strict\u0026#39;; const { execSync } = require(\u0026#39;child_process\u0026#39;); function run(command) { console.log(command); const result = execSync(command, {stdio: \u0026#39;inherit\u0026#39;}); if (result != null) { console.log(result.toString()); } } exports.handler = async (event) =\u0026gt; { console.log(\u0026#34;Video handler called\u0026#34;); if (!event.Records) { return; } for (const record of event.Records) { const fileName = record.s3.object.key; const bucketName = record.s3.bucket.name; const thumbnailFile = fileName.substring(0, fileName.indexOf(\u0026#34;_\u0026#34;)) + \u0026#34;.jpg\u0026#34;; const framePos = fileName.substring(fileName.indexOf(\u0026#34;_\u0026#34;)+1, fileName.indexOf(\u0026#34;.\u0026#34;)).replace(\u0026#34;-\u0026#34;, \u0026#34;:\u0026#34;); run(`aws s3 cp s3://${bucketName}/${fileName} /tmp/${fileName}`); run(`ffmpeg -v error -i /tmp/${fileName} -ss ${framePos} -vframes 1 -f image2 -an -y /tmp/${thumbnailFile}`); run(`aws s3 cp /tmp/${thumbnailFile} s3://${bucketName}/${thumbnailFile}`); console.log(`*** New thumbnail: file ${fileName} was saved at ${record.eventTime}.`); } }; The app directory should now look like this:\n. ├── Dockerfile └── index.js Step 3 — Build Docker Image \u0026amp; Push to ECR Back inside your Pulumi program (index.ts in the directory above the app directory) we now need to build this Docker image and create a place to push it.\nWe\u0026rsquo;ll use Pulumi Crosswalk to build the image and push it to the ECR repository. Add the following to index.ts:\nconst image = awsx.ecr.buildAndPushImage(\u0026#34;thumbnailer\u0026#34;, { context: \u0026#34;./app\u0026#34;, }); The index.ts file should now look like this:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; const image = awsx.ecr.buildAndPushImage(\u0026#34;thumbnailer\u0026#34;, { context: \u0026#34;./app\u0026#34;, }); This Pulumi component takes care of creating an ECR repository and building the local container image and pushing it.\nStep 4 — Run the Pulumi Program Run your Pulumi program and inspect the resources it\u0026rsquo;ll create:\nPreviewing update (dev) View Live: https://app.pulumi.com/jaxxstorm/thumbnailer/dev/previews/4a0d6e8e-1b71-4c97-8aae-5bfb5c10d419 Type Name Plan + pulumi:pulumi:Stack thumbnailer-dev create + └─ awsx:ecr:Repository thumbnailer create + ├─ aws:ecr:Repository thumbnailer create + └─ aws:ecr:LifecyclePolicy thumbnailer create Resources: + 4 to create Hit yes when you\u0026rsquo;re ready, you should see some output while the image builds in the background (this may take a few minutes):\nUpdating (dev) View Live: https://app.pulumi.com/jaxxstorm/thumbnailer/dev/updates/1 Type Name Status Info + pulumi:pulumi:Stack thumbnailer-dev creating + └─ awsx:ecr:Repository thumbnailer created Executing \u0026#39; docker build ./app -t 12fda807-container\u0026#39; + ├─ aws:ecr:Repository thumbnailer created + └─ aws:ecr:LifecyclePolicy thumbnailer created "
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts/40_container_thumbnailer/30_aws_infra.html",
	"title": "3.4 Define Lambda Container Function",
	"tags": [],
	"description": "",
	"content": "In the previous step, we built and pushed a Lambda container to an ECR repository. Now let\u0026rsquo;s define a lambda function whichs runs this container\nStep 1 — Declare an S3 Bucket and IAM Role Add the following to your index.ts file:\n// A bucket to store videos and thumbnails. const bucket = new aws.s3.Bucket(\u0026#34;thumbnailer\u0026#34;,{ forceDestroy: true, }); const role = new aws.iam.Role(\u0026#34;thumbnailerRole\u0026#34;, { assumeRolePolicy: aws.iam.assumeRolePolicyForPrincipal({ Service: \u0026#34;lambda.amazonaws.com\u0026#34; }), }); const lambdaFullAccess = new aws.iam.RolePolicyAttachment(\u0026#34;lambdaFullAccess\u0026#34;, { role: role.name, policyArn: aws.iam.ManagedPolicy.LambdaFullAccess, }); const lambdaBasicExecutionRole = new aws.iam.RolePolicyAttachment(\u0026#34;basicExecutionRole\u0026#34;, { role: role.name, policyArn: aws.iam.ManagedPolicy.AWSLambdaBasicExecutionRole, }); The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; // A bucket to store videos and thumbnails. const bucket = new aws.s3.Bucket(\u0026#34;thumbnailer\u0026#34;, { forceDestroy: true, }); const image = awsx.ecr.buildAndPushImage(\u0026#34;thumbnailer\u0026#34;, { context: \u0026#34;./app\u0026#34;, }); const role = new aws.iam.Role(\u0026#34;thumbnailerRole\u0026#34;, { assumeRolePolicy: aws.iam.assumeRolePolicyForPrincipal({ Service: \u0026#34;lambda.amazonaws.com\u0026#34; }), }); const lambdaFullAccess = new aws.iam.RolePolicyAttachment(\u0026#34;lambdaFullAccess\u0026#34;, { role: role.name, policyArn: aws.iam.ManagedPolicy.LambdaFullAccess, }); const lambdaBasicExecutionRole = new aws.iam.RolePolicyAttachment(\u0026#34;basicExecutionRole\u0026#34;, { role: role.name, policyArn: aws.iam.ManagedPolicy.AWSLambdaBasicExecutionRole, }); Step 2 — Add the Lambda Function We\u0026rsquo;ve created the role we need, let\u0026rsquo;s now define our Lambda function.\nAdd the following to your index.ts file:\nconst thumbnailer = new aws.lambda.Function(\u0026#34;thumbnailer\u0026#34;, { packageType: \u0026#34;Image\u0026#34;, imageUri: image.imageValue, role: role.arn, timeout: 900, }); The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; // A bucket to store videos and thumbnails. const bucket = new aws.s3.Bucket(\u0026#34;thumbnailer\u0026#34;, { forceDestroy: true, }); const image = awsx.ecr.buildAndPushImage(\u0026#34;thumbnailer\u0026#34;, { context: \u0026#34;./app\u0026#34;, }); const role = new aws.iam.Role(\u0026#34;thumbnailerRole\u0026#34;, { assumeRolePolicy: aws.iam.assumeRolePolicyForPrincipal({ Service: \u0026#34;lambda.amazonaws.com\u0026#34; }), }); const lambdaFullAccess = new aws.iam.RolePolicyAttachment(\u0026#34;lambdaFullAccess\u0026#34;, { role: role.name, policyArn: aws.iam.ManagedPolicy.LambdaFullAccess, }); const lambdaBasicExecutionRole = new aws.iam.RolePolicyAttachment(\u0026#34;basicExecutionRole\u0026#34;, { role: role.name, policyArn: aws.iam.ManagedPolicy.AWSLambdaBasicExecutionRole, }); const thumbnailer = new aws.lambda.Function(\u0026#34;thumbnailer\u0026#34;, { packageType: \u0026#34;Image\u0026#34;, imageUri: image.imageValue, role: role.arn, timeout: 900, }); Notice we\u0026rsquo;re referencing the image we built earlier and passing it to the function.\nStep 3 — Add the Lambda Event We want our Lambda function to trigger when we upload files to it. We can do this inline within our Pulumi program.\nAdd the following to your index.ts file:\n// When a new video is uploaded, run the FFMPEG task on the video file. // Use the time index specified in the filename (e.g. cat_00-01.mp4 uses timestamp 00:01) bucket.onObjectCreated(\u0026#34;onNewVideo\u0026#34;, thumbnailer, { filterSuffix: \u0026#34;.mp4\u0026#34; }); // When a new thumbnail is created, log a message. bucket.onObjectCreated(\u0026#34;onNewThumbnail\u0026#34;, new aws.lambda.CallbackFunction\u0026lt;aws.s3.BucketEvent, void\u0026gt;(\u0026#34;onNewThumbnail\u0026#34;, { callback: async bucketArgs =\u0026gt; { console.log(\u0026#34;onNewThumbnail called\u0026#34;); if (!bucketArgs.Records) { return; } for (const record of bucketArgs.Records) { console.log(`*** New thumbnail: file ${record.s3.object.key} was saved at ${record.eventTime}.`); } }, policies: [ aws.iam.ManagedPolicy.LambdaFullAccess, // Provides wide access to \u0026#34;serverless\u0026#34; services (Dynamo, S3, etc.) aws.iam.ManagedPolicy.AWSLambdaBasicExecutionRole, ], }), { filterSuffix: \u0026#34;.jpg\u0026#34; }); The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; // A bucket to store videos and thumbnails. const bucket = new aws.s3.Bucket(\u0026#34;thumbnailer\u0026#34;, { forceDestroy: true, }); const image = awsx.ecr.buildAndPushImage(\u0026#34;thumbnailer\u0026#34;, { context: \u0026#34;./app\u0026#34;, }); const role = new aws.iam.Role(\u0026#34;thumbnailerRole\u0026#34;, { assumeRolePolicy: aws.iam.assumeRolePolicyForPrincipal({ Service: \u0026#34;lambda.amazonaws.com\u0026#34; }), }); const lambdaFullAccess = new aws.iam.RolePolicyAttachment(\u0026#34;lambdaFullAccess\u0026#34;, { role: role.name, policyArn: aws.iam.ManagedPolicy.LambdaFullAccess, }); const lambdaBasicExecutionRole = new aws.iam.RolePolicyAttachment(\u0026#34;basicExecutionRole\u0026#34;, { role: role.name, policyArn: aws.iam.ManagedPolicy.AWSLambdaBasicExecutionRole, }); const thumbnailer = new aws.lambda.Function(\u0026#34;thumbnailer\u0026#34;, { packageType: \u0026#34;Image\u0026#34;, imageUri: image.imageValue, role: role.arn, timeout: 900, }); bucket.onObjectCreated(\u0026#34;onNewVideo\u0026#34;, thumbnailer, { filterSuffix: \u0026#34;.mp4\u0026#34; }); bucket.onObjectCreated(\u0026#34;onNewThumbnail\u0026#34;, new aws.lambda.CallbackFunction\u0026lt;aws.s3.BucketEvent, void\u0026gt;(\u0026#34;onNewThumbnail\u0026#34;, { callback: async bucketArgs =\u0026gt; { console.log(\u0026#34;onNewThumbnail called\u0026#34;); if (!bucketArgs.Records) { return; } for (const record of bucketArgs.Records) { console.log(`*** New thumbnail: file ${record.s3.object.key} was saved at ${record.eventTime}.`); } }, policies: [ aws.iam.ManagedPolicy.LambdaFullAccess, aws.iam.ManagedPolicy.AWSLambdaBasicExecutionRole, ], }), { filterSuffix: \u0026#34;.jpg\u0026#34; }); We\u0026rsquo;ve added two events here. One of the events waits for videos to be uploaded to our S3 bucket with the suffix .mp4 and if that happenes, it triggers the thumbnailer lambda container.\nThe second function waits for a thumbnail to be written and defines an inline Lambda callback function which logs a message for us to read.\nStep 4 — Export the Bucket name We need to know where to upload our videos to, so let\u0026rsquo;s export our bucket name from our Pulumi program. Add the following line to the end of your `index.ts\n// Export the bucket name. export const bucketName = bucket.id; The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; // A bucket to store videos and thumbnails. const bucket = new aws.s3.Bucket(\u0026#34;thumbnailer\u0026#34;, { forceDestroy: true, }); const image = awsx.ecr.buildAndPushImage(\u0026#34;thumbnailer\u0026#34;, { context: \u0026#34;./app\u0026#34;, }); const role = new aws.iam.Role(\u0026#34;thumbnailerRole\u0026#34;, { assumeRolePolicy: aws.iam.assumeRolePolicyForPrincipal({ Service: \u0026#34;lambda.amazonaws.com\u0026#34; }), }); const lambdaFullAccess = new aws.iam.RolePolicyAttachment(\u0026#34;lambdaFullAccess\u0026#34;, { role: role.name, policyArn: aws.iam.ManagedPolicy.LambdaFullAccess, }); const lambdaBasicExecutionRole = new aws.iam.RolePolicyAttachment(\u0026#34;basicExecutionRole\u0026#34;, { role: role.name, policyArn: aws.iam.ManagedPolicy.AWSLambdaBasicExecutionRole, }); const thumbnailer = new aws.lambda.Function(\u0026#34;thumbnailer\u0026#34;, { packageType: \u0026#34;Image\u0026#34;, imageUri: image.imageValue, role: role.arn, timeout: 900, }); bucket.onObjectCreated(\u0026#34;onNewVideo\u0026#34;, thumbnailer, { filterSuffix: \u0026#34;.mp4\u0026#34; }); bucket.onObjectCreated(\u0026#34;onNewThumbnail\u0026#34;, new aws.lambda.CallbackFunction\u0026lt;aws.s3.BucketEvent, void\u0026gt;(\u0026#34;onNewThumbnail\u0026#34;, { callback: async bucketArgs =\u0026gt; { console.log(\u0026#34;onNewThumbnail called\u0026#34;); if (!bucketArgs.Records) { return; } for (const record of bucketArgs.Records) { console.log(`*** New thumbnail: file ${record.s3.object.key} was saved at ${record.eventTime}.`); } }, policies: [ aws.iam.ManagedPolicy.LambdaFullAccess, aws.iam.ManagedPolicy.AWSLambdaBasicExecutionRole, ], }), { filterSuffix: \u0026#34;.jpg\u0026#34; }); export const bucketName = bucket.id; Step 4 — Provision your function At this stage we\u0026rsquo;re ready to provision our infrastructrue again. Run pulumi up and observe the resources we\u0026rsquo;re going to provision:\nPreviewing update (dev) View Live: https://app.pulumi.com/jaxxstorm/thumbnailer/dev/previews/40e76859-5ef4-4a79-a7cf-abc39108c0cb Type Name Plan Info pulumi:pulumi:Stack thumbnailer-dev + ├─ aws:s3:Bucket thumbnailer create + │ ├─ aws:s3:BucketEventSubscription onNewThumbnail create + │ │ └─ aws:lambda:Permission onNewThumbnail create + │ ├─ aws:s3:BucketEventSubscription onNewVideo create + │ │ └─ aws:lambda:Permission onNewVideo create + │ └─ aws:s3:BucketNotification onNewVideo create + ├─ aws:iam:Role onNewThumbnail create + ├─ aws:iam:Role thumbnailerRole create + ├─ aws:iam:RolePolicyAttachment lambdaFullAccess create + ├─ aws:iam:RolePolicyAttachment onNewThumbnail-32be53a2 create ├─ awsx:ecr:Repository thumbnailer 1 warning + ├─ aws:lambda:Function onNewThumbnail create + └─ aws:lambda:Function thumbnailer create Hit yes and provision your infrastructure. You should see your bucket name displayed as an Output:\nOutputs: + bucketName: \u0026#34;thumbnailer-f91a64e\u0026#34; Resources: + 12 created 4 unchanged Step 5 — Upload an example video If you need an exampe video, try the one in our examples repo: https://github.com/pulumi/examples/tree/master/aws-ts-lambda-thumbnailer/sample\nLet\u0026rsquo;s trigger our function by uploading an .mp4 video to the bucket:\naws s3 cp ./sample/cat.mp4 s3://$(pulumi stack output bucketName)/cat_00-01.mp4 You should see the file get uploaded to s3:\nupload: sample/cat.mp4 to s3://thumbnailer-f91a64e/cat_00-01.mp4 You can view the logs from your function to see if the functions were triggered:\n2020-12-02T14:38:18.423-08:00[ thumbnailer-8d60c20] START RequestId: 07106ad0-f7dd-440e-99dd-984d90b50f3c Version: $LATEST 2020-12-02T14:38:18.428-08:00[ thumbnailer-8d60c20] 2020-12-02T22:38:18.425Z\t07106ad0-f7dd-440e-99dd-984d90b50f3c\tINFO\tVideo handler called 2020-12-02T14:38:18.449-08:00[ thumbnailer-8d60c20] 2020-12-02T22:38:18.449Z\t07106ad0-f7dd-440e-99dd-984d90b50f3c\tINFO\taws s3 cp s3://thumbnailer-f91a64e/cat_00-01.mp4 /tmp/cat_00-01.mp4 download: s3://thumbnailer-f91a64e/cat_00-01.mp4 to ../../tmp/cat_00-01.mp46.0 KiB/666.5 KiB (1.1 MiB/s) with 1 file(s) remaining 2020-12-02T14:38:34.789-08:00[ thumbnailer-8d60c20] 2020-12-02T22:38:34.788Z\t07106ad0-f7dd-440e-99dd-984d90b50f3c\tINFO\tffmpeg -v error -i /tmp/cat_00-01.mp4 -ss 00:01 -vframes 1 -f image2 -an -y /tmp/cat.jpg 2020-12-02T14:38:45.198-08:00[ thumbnailer-8d60c20] 2020-12-02T22:38:45.197Z\t07106ad0-f7dd-440e-99dd-984d90b50f3c\tINFO\taws s3 cp /tmp/cat.jpg s3://thumbnailer-f91a64e/cat.jpg upload: ../../tmp/cat.jpg to s3://thumbnailer-f91a64e/cat.jpg pleted 86.6 KiB/86.6 KiB (280.9 KiB/s) with 1 file(s) remaining 2020-12-02T14:38:55.910-08:00[ thumbnailer-8d60c20] 2020-12-02T22:38:55.910Z\t07106ad0-f7dd-440e-99dd-984d90b50f3c\tINFO\t*** New thumbnail: file cat_00-01.mp4 was saved at 2020-12-02T22:38:11.842Z. 2020-12-02T14:38:55.939-08:00[ thumbnailer-8d60c20] END RequestId: 07106ad0-f7dd-440e-99dd-984d90b50f3c 2020-12-02T14:38:55.939-08:00[ thumbnailer-8d60c20] REPORT RequestId: 07106ad0-f7dd-440e-99dd-984d90b50f3c\tDuration: 37508.62 ms\tBilled Duration: 38316 ms\tMemory Size: 128 MB\tMax Memory Used: 128 MB\tInit Duration: 807.08 ms 2020-12-02T14:38:56.144-08:00[ onNewThumbnail-1cb1a7d] START RequestId: 6a5ead91-f030-4b3b-a22a-c3cc16ce7864 Version: $LATEST 2020-12-02T14:38:56.158-08:00[ onNewThumbnail-1cb1a7d] 2020-12-02T22:38:56.158Z\t6a5ead91-f030-4b3b-a22a-c3cc16ce7864\tINFO\tonNewThumbnail called 2020-12-02T14:38:56.158-08:00[ onNewThumbnail-1cb1a7d] 2020-12-02T22:38:56.158Z\t6a5ead91-f030-4b3b-a22a-c3cc16ce7864\tINFO\t*** New thumbnail: file cat.jpg was saved at 2020-12-02T22:38:49.839Z. 2020-12-02T14:38:56.175-08:00[ onNewThumbnail-1cb1a7d] END RequestId: 6a5ead91-f030-4b3b-a22a-c3cc16ce7864 2020-12-02T14:38:56.175-08:00[ onNewThumbnail-1cb1a7d] REPORT RequestId: 6a5ead91-f030-4b3b-a22a-c3cc16ce7864\tDuration: 30.58 ms\tBilled Duration: 31 ms\tMemory Size: 128 MB\tMax Memory Used: 64 MB\tInit Duration: 160.74 ms You can see that the thumbnailer generated a cat.jpg for our video! Let\u0026rsquo;s download it:\naws s3 cp s3://$(pulumi stack output bucketName)/cat.jpg . "
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python/40_ecs/30_deploy_service.html",
	"title": "3.4 Deploy a Fargate Service",
	"tags": [],
	"description": "",
	"content": "In order to create a Fargate service, we need to add an IAM Role and a Task Definition and Service. the ECS Cluster will run the nginx image from Docker Hub.\nStep 1 — Create an ECS Task Execution Role First, we need to add a new import at the top of our file. We\u0026rsquo;ll use this when defining our ECS task\u0026rsquo;s execution role.\nAdd the following to the top of your __main__.py file, near the other imports:\nimport json Now let\u0026rsquo;s define our IAM execution role and attach a policy. Add the following to your __main.py__:\nrole = aws.iam.Role( \u0026#34;task-exec-role\u0026#34;, assume_role_policy=json.dumps({ \u0026#34;Version\u0026#34;: \u0026#34;2008-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [{ \u0026#34;Sid\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;ecs-tasks.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34;, }] }), ) aws.iam.RolePolicyAttachment( \u0026#34;task-exec-policy\u0026#34;, role=role.name, policy_arn=\u0026#34;arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy\u0026#34;, ) Step 2 — Create an ECS Task Definition Now we define a task definition for our ECS service and add the DNS name of the ALB we defined earlier so we can get the public URL for our service.\nAdd the following to your __main__.py:\ntask_definition = aws.ecs.TaskDefinition( \u0026#34;app-task\u0026#34;, family=\u0026#34;fargate-task-definition\u0026#34;, cpu=\u0026#34;256\u0026#34;, memory=\u0026#34;512\u0026#34;, network_mode=\u0026#34;awsvpc\u0026#34;, requires_compatibilities=[\u0026#34;FARGATE\u0026#34;], execution_role_arn=role.arn, container_definitions=json.dumps([{ \u0026#34;name\u0026#34;: \u0026#34;my-app\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;nginx\u0026#34;, \u0026#34;portMappings\u0026#34;: [{ \u0026#34;containerPort\u0026#34;: 80, \u0026#34;hostPort\u0026#34;: 80, \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34; }] }]) ) service = aws.ecs.Service( \u0026#34;app-svc\u0026#34;, cluster=cluster.arn, desired_count=1, launch_type=\u0026#34;FARGATE\u0026#34;, task_definition=task_definition.arn, network_configuration={ \u0026#34;assign_public_ip\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;subnets\u0026#34;: vpc.private_subnet_ids, \u0026#34;security_groups\u0026#34;: [group.id] }, load_balancers=[{ \u0026#34;target_group_arn\u0026#34;: target_group.arn, \u0026#34;container_name\u0026#34;: \u0026#34;my-app\u0026#34;, \u0026#34;container_port\u0026#34;: 80 }], opts=pulumi.ResourceOptions(depends_on=[listener]) ) pulumi.export(\u0026#34;url\u0026#34;, pulumi.Output.concat( \u0026#34;http://\u0026#34;, alb.dns_name)) \u0026#x2705; After these changes, your __main__.py should look like this\nimport pulumi as pulumi import pulumi_aws as aws import pulumi_awsx as awsx import json cluster = aws.ecs.Cluster(\u0026#34;cluster\u0026#34;) vpc = awsx.ec2.Vpc(\u0026#34;my-vpc\u0026#34;) group = aws.ec2.SecurityGroup( \u0026#34;web-secgrp\u0026#34;, vpc_id=vpc.vpc_id, description=\u0026#34;Enable HTTP access\u0026#34;, ingress=[aws.ec2.SecurityGroupIngressArgs( protocol=\u0026#34;tcp\u0026#34;, from_port=80, to_port=80, cidr_blocks=[\u0026#34;0.0.0.0/0\u0026#34;], )], egress=[aws.ec2.SecurityGroupEgressArgs( protocol=\u0026#34;-1\u0026#34;, from_port=0, to_port=0, cidr_blocks=[\u0026#34;0.0.0.0/0\u0026#34;], )], ) alb = aws.lb.LoadBalancer( \u0026#34;app-lb\u0026#34;, security_groups=[group.id], subnets=vpc.public_subnet_ids, ) target_group = aws.lb.TargetGroup( \u0026#34;app-tg\u0026#34;, port=80, protocol=\u0026#34;HTTP\u0026#34;, target_type=\u0026#34;ip\u0026#34;, vpc_id=vpc.vpc_id, ) listener = aws.lb.Listener( \u0026#34;web\u0026#34;, load_balancer_arn=alb.arn, port=80, default_actions=[aws.lb.ListenerDefaultActionArgs( type=\u0026#34;forward\u0026#34;, target_group_arn=target_group.arn, )], ) role = aws.iam.Role( \u0026#34;task-exec-role\u0026#34;, assume_role_policy=json.dumps({ \u0026#34;Version\u0026#34;: \u0026#34;2008-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [{ \u0026#34;Sid\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;ecs-tasks.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34;, }] }), ) aws.iam.RolePolicyAttachment( \u0026#34;task-exec-policy\u0026#34;, role=role.name, policy_arn=\u0026#34;arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy\u0026#34;, ) # Spin up a load balanced service running our container image. task_definition = aws.ecs.TaskDefinition( \u0026#34;app-task\u0026#34;, family=\u0026#34;fargate-task-definition\u0026#34;, cpu=\u0026#34;256\u0026#34;, memory=\u0026#34;512\u0026#34;, network_mode=\u0026#34;awsvpc\u0026#34;, requires_compatibilities=[\u0026#34;FARGATE\u0026#34;], execution_role_arn=role.arn, container_definitions=json.dumps([{ \u0026#34;name\u0026#34;: \u0026#34;my-app\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;nginx\u0026#34;, \u0026#34;portMappings\u0026#34;: [{ \u0026#34;containerPort\u0026#34;: 80, \u0026#34;hostPort\u0026#34;: 80, \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34; }] }]) ) aws.ecs.Service( \u0026#34;app-svc\u0026#34;, cluster=cluster.arn, desired_count=1, launch_type=\u0026#34;FARGATE\u0026#34;, task_definition=task_definition.arn, network_configuration=aws.ecs.ServiceNetworkConfigurationArgs( assign_public_ip=True, subnets=vpc.private_subnet_ids, security_groups=[group.id], ), load_balancers=[aws.ecs.ServiceLoadBalancerArgs( target_group_arn=target_group.arn, container_name=\u0026#34;my-app\u0026#34;, container_port=80, )], opts=pulumi.ResourceOptions( depends_on=[listener] ), ) pulumi.export(\u0026#34;url\u0026#34;, pulumi.Output.concat( \u0026#34;http://\u0026#34;, alb.dns_name)) Step 3 — Provision the Cluster and Service Deploy the program to stand up your initial cluster and service:\npulumi up You can now curl the resulting endpoint:\ncurl $(pulumi stack output url) And you\u0026rsquo;ll see the Nginx default homepage:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; ... Step 4 — Update the Service Now, let update the desired container count from 1 to 3:\n... desiredCount: 3, ... \u0026#x2705; After this change, your __main__.py should look like this:\nNext update the stack:\npulumi up After the command completes, you should be able to view the NGINX default index page by running the following command:\ncurl $(pulumi stack output url) Step 4 — Cleaning Up Now that we\u0026rsquo;re done we can destroy the resources we created and the stack itself:\npulumi destroy pulumi stack rm dev "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/45_componens/20_use_component.html",
	"title": "4.3 Use our Component",
	"tags": [],
	"description": "",
	"content": "Next, we\u0026rsquo;ll use our new ServiceDeployment component.\nStart by deleting all of the code in index.ts after the namespace so that you left with just:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; import { ServiceDeployment } from \u0026#34;./servicedeployment\u0026#34;; const config = new pulumi.Config(); const clusterStackRef = new pulumi.StackReference(config.require(\u0026#34;clusterStackRef\u0026#34;)); const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;).apply(JSON.stringify); const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, { kubeconfig }); const ns = new k8s.core.v1.Namespace(\u0026#34;app-ns\u0026#34;, { metadata: { name: \u0026#34;eks-demo-apps\u0026#34;}, }, { provider }); Then add a new import at the top of the file:\nimport { ServiceDeployment } from \u0026#34;./servicedeployment\u0026#34;; This imports the component we just defined. Now we\u0026rsquo;ll create an instance of this component that matches what we had previously.\nAdd the following at the end of the file:\nconst bootcamp = new ServiceDeployment(\u0026#34;eks-demo-app\u0026#34;, { image: \u0026#34;jocatalin/kubernetes-bootcamp:v2\u0026#34;, port: { port:3000, targetPort: 8080 }, namespace: ns.metadata.name, }, { provider}); export const url = bootcamp.url; The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; import { ServiceDeployment } from \u0026#34;./servicedeployment\u0026#34;; const config = new pulumi.Config(); const clusterStackRef = new pulumi.StackReference(config.require(\u0026#34;clusterStackRef\u0026#34;)); const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;).apply(JSON.stringify); const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, { kubeconfig }); const ns = new k8s.core.v1.Namespace(\u0026#34;app-ns\u0026#34;, { metadata: { name: \u0026#34;eks-demo-apps\u0026#34;}, }, { provider }); const bootcamp = new ServiceDeployment(\u0026#34;eks-demo-app\u0026#34;, { image: \u0026#34;jocatalin/kubernetes-bootcamp:v2\u0026#34;, port: { port:3000, targetPort: 8080 }, namespace: ns.metadata.name, }, { provider}); export const url = bootcamp.url; "
},
{
	"uri": "//localhost:1313/en/additional-content/150_deploying_argocd_to_eks/20_create_a_namespace.html",
	"title": "Creating a Namespace",
	"tags": [],
	"description": "",
	"content": "Next, declare a namespace object. This will allow scoping the deployment of the ArcoCD components to that namespace.\nTo do this, we need to create a stack reference to the project where we created the eks infrastructure so we can get the Kubeconfig and be able to build the correct kubernetes provider. We are going to make the stack reference name configurable:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; const pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); Now we can get the kubeconfig from the eks cluster for use in our provider. Append this to your index.ts file:\nconst provider = new k8s.Provider(\u0026#34;k8s\u0026#34;, { kubeconfig: eks.getOutput(\u0026#34;kubeconfig\u0026#34;) }); Now we can create the namespace using the provider we just created. Append this to your index.ts file:\nconst name = \u0026#34;argocd\u0026#34; const ns = new k8s.core.v1.Namespace(\u0026#34;argocd-ns\u0026#34;, { metadata: { name: name }, }, { provider }); The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; const pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); const provider = new k8s.Provider(\u0026#34;k8s\u0026#34;, { kubeconfig: clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;) }); const name = \u0026#34;argocd\u0026#34; const ns = new k8s.core.v1.Namespace(\u0026#34;argocd-ns\u0026#34;, { metadata: { name: name }, }, { provider }); "
},
{
	"uri": "//localhost:1313/en/additional-content/160_gitops_for_socks_shop/20_create_a_namespace.html",
	"title": "Creating a Namespace",
	"tags": [],
	"description": "",
	"content": "Next, declare a namespace object. This will allow scoping the deployment of the Sock Shop\u0026rsquo;s components to that namespace.\nTo do this, we need to create a stack reference to the project where we created the eks infrastructure so we can get the Kubeconfig and be able to build the correct kubernetes provider. We are going to make the stack reference name configurable:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; const pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); const argoStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;argoCDStackRef\u0026#34;)) Now we can get the kubeconfig from the eks cluster for use in our provider. Append this to your index.ts file:\n// Get the kubeconfig from the cluster stack output. const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;); // Create the k8s provider with the kubeconfig. const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, { kubeconfig }); Now we can create the namespace using the provider we just created. Append this to your index.ts file:\nconst name = \u0026#34;sock-shop\u0026#34; const ns = new k8s.core.v1.Namespace(\u0026#34;sock-shop-ns\u0026#34;, { metadata: { name: name }, }, { provider }); The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; const pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); const argoStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;argoCDStackRef\u0026#34;)) // Get the kubeconfig from the cluster stack output. const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;); // Create the k8s provider with the kubeconfig. const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, { kubeconfig }); const name = \u0026#34;sock-shop\u0026#34; const ns = new k8s.core.v1.Namespace(\u0026#34;sock-shop-ns\u0026#34;, { metadata: { name: name }, }, { provider }); "
},
{
	"uri": "//localhost:1313/en/additional-content/120_serverless_application_patterns/20_creating_iam_policies.html",
	"title": "Creating IAM Policies",
	"tags": [],
	"description": "",
	"content": "Before creating your website, the Lambda will need a certain IAM role and permission. This permits the Lambda\u0026rsquo;s function to assume the right identity at runtime, log into CloudWatch to aid with debugging, and to use the DynamoDB table defined in the previous step:\nconst handlerRole = new aws.iam.Role(\u0026#34;handler-role\u0026#34;, { assumeRolePolicy: { Version: \u0026#34;2012-10-17\u0026#34;, Statement: [{ Action: \u0026#34;sts:AssumeRole\u0026#34;, Principal: { Service: \u0026#34;lambda.amazonaws.com\u0026#34; }, Effect: \u0026#34;Allow\u0026#34;, Sid: \u0026#34;\u0026#34;, }], }, }); const handlerPolicy = new aws.iam.RolePolicy(\u0026#34;handler-policy\u0026#34;, { role: handlerRole, policy: hits.arn.apply(arn =\u0026gt; JSON.stringify({ Version: \u0026#34;2012-10-17\u0026#34;, Statement: [ { Action: [ \u0026#34;dynamodb:UpdateItem\u0026#34;, \u0026#34;dynamodb:PutItem\u0026#34;, \u0026#34;dynamodb:GetItem\u0026#34;, \u0026#34;dynamodb:DescribeTable\u0026#34;, ], Resource: arn, Effect: \u0026#34;Allow\u0026#34;, }, { Action: [\u0026#34;logs:*\u0026#34;, \u0026#34;cloudwatch:*\u0026#34;], Resource: \u0026#34;*\u0026#34;, Effect: \u0026#34;Allow\u0026#34;, }, ], })), }); The index.ts file should now have the following contents:\nimport * as AWS from \u0026#34;aws-sdk\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; import * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; const hits = new aws.dynamodb.Table(\u0026#34;hits\u0026#34;, { attributes: [{ name: \u0026#34;Site\u0026#34;, type: \u0026#34;S\u0026#34; }], hashKey: \u0026#34;Site\u0026#34;, billingMode: \u0026#34;PAY_PER_REQUEST\u0026#34;, }); const handlerRole = new aws.iam.Role(\u0026#34;handler-role\u0026#34;, { assumeRolePolicy: { Version: \u0026#34;2012-10-17\u0026#34;, Statement: [{ Action: \u0026#34;sts:AssumeRole\u0026#34;, Principal: { Service: \u0026#34;lambda.amazonaws.com\u0026#34; }, Effect: \u0026#34;Allow\u0026#34;, Sid: \u0026#34;\u0026#34;, }], }, }); const handlerPolicy = new aws.iam.RolePolicy(\u0026#34;handler-policy\u0026#34;, { role: handlerRole, policy: hits.arn.apply(arn =\u0026gt; JSON.stringify({ Version: \u0026#34;2012-10-17\u0026#34;, Statement: [ { Action: [ \u0026#34;dynamodb:UpdateItem\u0026#34;, \u0026#34;dynamodb:PutItem\u0026#34;, \u0026#34;dynamodb:GetItem\u0026#34;, \u0026#34;dynamodb:DescribeTable\u0026#34;, ], Resource: arn, Effect: \u0026#34;Allow\u0026#34;, }, { Action: [\u0026#34;logs:*\u0026#34;, \u0026#34;cloudwatch:*\u0026#34;], Resource: \u0026#34;*\u0026#34;, Effect: \u0026#34;Allow\u0026#34;, }, ], })), }); "
},
{
	"uri": "//localhost:1313/en/additional-content/100_provision_ec2_virtual_machines/20_create_multiple_vms.html",
	"title": "Creating Multiple VMs",
	"tags": [],
	"description": "",
	"content": "Now you will create multiple VM instances, each running the same Python webserver, across all AWS availability zones in your region. Replace the part of your code that creates the webserver and exports the resulting IP address and hostname with the following:\nconst ips: any[] = []; const hostnames: any[] = []; const azs = await aws.getAvailabilityZones() for (const az of azs.names) { const server = new aws.ec2.Instance(`web-server-${az}`, { instanceType: \u0026#34;t3.micro\u0026#34;, securityGroups: [ sg.name ], ami: ami, availabilityZone: az, userData: \u0026#34;#!/bin/bash\\n\u0026#34;+ `echo \u0026#39;Hello, World -- from ${az}!\u0026#39; \u0026gt; index.html\\n` + \u0026#34;nohup python -m SimpleHTTPServer 80 \u0026amp;\u0026#34;, tags: { \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34; }, }); ips.push(server.publicIp); hostnames.push(server.publicDns); } The index.ts file should now have the following contents - please note the wrapping with the async function!:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; export = async () =\u0026gt; { const ami = aws.getAmi({ filters: [{ name: \u0026#34;name\u0026#34;, values: [\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;] }], owners: [ \u0026#34;137112412989\u0026#34; ], mostRecent: true, }).then(ami =\u0026gt; ami.id); const sg = new aws.ec2.SecurityGroup(\u0026#34;web-secgrp\u0026#34;, { ingress: [ { protocol: \u0026#34;icmp\u0026#34;, fromPort: 8, toPort: 0, cidrBlocks: [\u0026#34;0.0.0.0/0\u0026#34;] }, { protocol: \u0026#34;tcp\u0026#34;, fromPort: 80, toPort: 80, cidrBlocks: [\u0026#34;0.0.0.0/0\u0026#34;] }, ], }); const ips: any[] = []; const hostnames: any[] = []; const azs = await aws.getAvailabilityZones() for (const az of azs.names) { const server = new aws.ec2.Instance(`web-server-${az}`, { instanceType: \u0026#34;t3.micro\u0026#34;, securityGroups: [ sg.name ], ami: ami, availabilityZone: az, userData: \u0026#34;#!/bin/bash\\n\u0026#34;+ `echo \u0026#39;Hello, World -- from ${az}!\u0026#39; \u0026gt; index.html\\n` + \u0026#34;nohup python -m SimpleHTTPServer 80 \u0026amp;\u0026#34;, tags: { \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34; }, }); ips.push(server.publicIp); hostnames.push(server.publicDns); } return { ips: ips, hostnames: hostnames, }; } Now run a command to update your stack with the new resource definitions:\npulumi up You will see output like the following:\nUpdating (dev): Type Name Status pulumi:pulumi:Stack iac-workshop-dev + ├─ aws:ec2:Instance web-server-us-west-2a created + ├─ aws:ec2:Instance web-server-us-west-2b created + ├─ aws:ec2:Instance web-server-us-west-2c created - └─ aws:ec2:Instance web-server deleted Outputs: + hostnames : [ + [0]: \u0026#34;ec2-18-197-184-46.us-west-2.compute.amazonaws.com\u0026#34; + [1]: \u0026#34;ec2-18-196-225-191.us-west-2.compute.amazonaws.com\u0026#34; + [2]: \u0026#34;ec2-35-158-83-62.us-west-2.compute.amazonaws.com\u0026#34; ] + ips : [ + [0]: \u0026#34;18.197.184.46\u0026#34; + [1]: \u0026#34;18.196.225.191\u0026#34; + [2]: \u0026#34;35.158.83.62\u0026#34; ] - publicHostname: \u0026#34;ec2-52-57-250-206.us-west-2.compute.amazonaws.com\u0026#34; - publicIp : \u0026#34;52.57.250.206\u0026#34; Resources: + 3 created - 1 deleted 4 changes. 2 unchanged Duration: 1m2s Permalink: https://app.pulumi.com/workshops/ec2-workshop/dev/updates/2 Notice that your original server was deleted and new ones created in its place, because its name changed.\nTo test the changes, curl any of the resulting IP addresses or hostnames:\nfor i in {0..2}; do curl $(pulumi stack output hostnames | jq -r \u0026#34;.[${i}]\u0026#34;); done The count of servers depends on the number of AZs in your region. Adjust the {0..2} accordingly.\nThe pulumi stack output command emits JSON serialized data — hence the use of the jq tool to extract a specific index. If you don\u0026rsquo;t have jq, don\u0026rsquo;t worry; simply copy-and-paste the hostname or IP address from the console output and curl that.\nNote that the webserver number is included in its response:\nHello, World -- from us-west-2a! Hello, World -- from us-west-2b! Hello, World -- from us-west-2c! "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts.html",
	"title": "Intro to Modern IaC with AWS &amp; Pulumi (TypeScript)",
	"tags": [],
	"description": "",
	"content": "Introduction to Modern Infrastructure as Code with AWS and Pulumi (TypeScript) Learning Objectives Getting started with Pulumi Deploy a website on Amazon S3 Deploy Amazon EKS Infrastructure Deploy an application on Amazon EKS Create a reusable infrastructure component In this workshop, we have selected containers and various other technologies to demonstrante the strength of IaC. At the end of the workshop you can continue to the additional content section, where you can find more labs to explore other components to work with such as serverless and EC2.\nThe examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various cloud services can be used to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments. "
},
{
	"uri": "//localhost:1313/en/50_eks_platform/20_provision_cluster.html",
	"title": "Module 01: EKS Cluster",
	"tags": [],
	"description": "",
	"content": "Provision a VPC \u0026amp; EKS Cluster You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will use Pulumi to create an Amazon EKS cluster.\n1.1 Creating a New Project 1.2 Configuring AWS 1.3 Create an EKS Cluster "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/20_getting_started_with_pulumi.html",
	"title": "Module 01: S3 Website",
	"tags": [],
	"description": "",
	"content": "Getting Started with Pulumi You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will use Pulumi to create a static website served from AWS S3.\n1.1 Creating a New Project 1.2 Configuring AWS 1.3 Provisioning Infrastructure 1.4 Updating Infrastructure "
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python/20_getting_started_with_pulumi.html",
	"title": "Module 01: S3 Website",
	"tags": [],
	"description": "",
	"content": "Getting Started with Pulumi You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will use Pulumi to create a static website served from AWS S3.\n1.1 Creating a New Project 1.2 Configuring AWS 1.3 Provisioning Infrastructure 1.4 Updating Infrastructure "
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java/20_getting_started_with_pulumi.html",
	"title": "Module 01: S3 Website",
	"tags": [],
	"description": "",
	"content": "Getting Started with Pulumi You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will use Pulumi to create a static website served from AWS S3.\n1.1 Creating a New Project 1.2 Configuring AWS 1.3 Provisioning Infrastructure 1.4 Updating Infrastructure "
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts/20_getting_started_with_pulumi.html",
	"title": "Module 01: Simple Lambda Function",
	"tags": [],
	"description": "",
	"content": "Getting Started with Pulumi You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will use Pulumi to create a a very simple lambda function. We\u0026rsquo;ll discover how Pulumi can make it possible to provision code inline within your infrastructure code.\n1.1 Creating a New Project 1.2 Configuring AWS 1.3 Provisioning a Lambda Function "
},
{
	"uri": "//localhost:1313/en/50_eks_platform/30_deploy_ingress_controller.html",
	"title": "Module 02: AWS LoadBalancer Controller",
	"tags": [],
	"description": "",
	"content": "Provision AWS Load Balancer Controller You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will use Pulumi \u0026amp; Helm to provision the AWS Load Balancer Controller. We\u0026rsquo;ll discover how Pulumi let\u0026rsquo;s you provision AWS resources \u0026amp; Kubernetes resources in the same program.\n2.1 Creating a New Project 2.2 Create an IAM Role 2.3 Deploy Ingress Controller "
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python.html",
	"title": "Intro to Modern IaC with AWS &amp; Pulumi (Python)",
	"tags": [],
	"description": "",
	"content": "Introduction to Modern Infrastructure as Code with AWS and Pulumi (Python) Learning Objectives Getting started with Pulumi Deploy a website on Amazon S3 Deploy load balanced Amazon EC2 Instances and an Application Load Balancer Deploy an application on Amazon ECS on AWS Fargate In this workshop, we have selected containers and various other technologies to demonstrate the strength of IaC. At the end of the workshop you can continue to the additional content section, where you can find more labs to explore other components to work with such as serverless and EC2.\nThe examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various cloud services can be used to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments.\n"
},
{
	"uri": "//localhost:1313/en/10_prerequisites/volume_resize.html",
	"title": "Resize workspace&#39;s EBS volume",
	"tags": [],
	"description": "",
	"content": " The Cloud9 workspace volume should be resized by an IAM user with Administrator privileges, not the root account user. Please ensure you are logged in as an IAM user, not the root account user.\nThis workshop was designed to run in the Oregon (us-west-2) region. Please don\u0026rsquo;t run in any other region. Future versions of this workshop will expand region availability, and this message will be removed.\nSet up resize script: Create a file called resize.sh to resize the root EBS volume of the Cloud9 instance. $ touch resize.sh \u0026amp;\u0026amp; chmod +x resize.sh Double click resize.sh on the file bar on the left and copy in the script below. Make sure to save it. #!/bin/bash # Specify the desired volume size in GiB as a command line argument. If not specified, default to 20 GiB. SIZE=${1:-20} # Get the ID of the environment host Amazon EC2 instance. INSTANCEID=$(curl http://169.254.169.254/latest/meta-data/instance-id) # Get the ID of the Amazon EBS volume associated with the instance. VOLUMEID=$(aws ec2 describe-instances \\ --instance-id $INSTANCEID \\ --query \u0026#34;Reservations[0].Instances[0].BlockDeviceMappings[0].Ebs.VolumeId\u0026#34; \\ --output text) echo Modify volume ${VOLUMEID} # Resize the EBS volume. aws ec2 modify-volume --volume-id $VOLUMEID --size $SIZE # Wait for the resize to finish. seconds=1 while [ \\ \u0026#34;$(aws ec2 describe-volumes-modifications \\ --volume-id $VOLUMEID \\ --filters Name=modification-state,Values=\u0026#34;optimizing\u0026#34;,\u0026#34;completed\u0026#34; \\ --query \u0026#34;length(VolumesModifications)\u0026#34;\\ --output text)\u0026#34; != \u0026#34;1\u0026#34; ]; do sleep 1 let seconds++ done echo ${seconds} seconds to resize disk #Check if we\u0026#39;re on an NVMe filesystem if [ $(readlink -f /dev/xvda) = \u0026#34;/dev/xvda\u0026#34; ] then # Rewrite the partition table so that the partition takes up all the space that it can. sudo growpart /dev/xvda 1 # Expand the size of the file system. # Check if we are on AL2 STR=$(cat /etc/os-release) SUB=\u0026#34;VERSION_ID=\\\u0026#34;2\\\u0026#34;\u0026#34; if [[ \u0026#34;$STR\u0026#34; == *\u0026#34;$SUB\u0026#34;* ]] then sudo xfs_growfs -d / else sudo resize2fs /dev/xvda1 fi else # Rewrite the partition table so that the partition takes up all the space that it can. sudo growpart /dev/nvme0n1 1 # Expand the size of the file system. # Check if we\u0026#39;re on AL2 STR=$(cat /etc/os-release) SUB=\u0026#34;VERSION_ID=\\\u0026#34;2\\\u0026#34;\u0026#34; if [[ \u0026#34;$STR\u0026#34; == *\u0026#34;$SUB\u0026#34;* ]] then sudo xfs_growfs -d / else sudo resize2fs /dev/nvme0n1p1 fi fi Increase the volume size Going back to the terminal, run resize.sh using the command bellow. This will resize the volume to 20 GiB $ ./resize.sh 20 The script may take some time to complete. Verify the volume was resized succesffully. Run lsblk to ensure that the disk is partitioned properly. The size of the partition with the/ mountpoint and the overarching drive should be 20G. $ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT nvme0n1 259:0 0 20G 0 disk ├─nvme0n1p1 259:1 0 20G 0 part / └─nvme0n1p128 259:2 0 1M 0 part "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/20_getting_started_with_pulumi/30_updating_infrastructure.html",
	"title": "1.4 Updating Infrastructure",
	"tags": [],
	"description": "",
	"content": "We just saw how to create new infrastructure. Next, let\u0026rsquo;s make a few updates.\nThis exercise demonstrates how declarative infrastructure as code tools can be used not just for initial provisioning, but also subsequent changes to existing resources.\nStep 1 — Create Website Files Create a directory www/ and add a new index.html file with the following contents:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello, Pulumi!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Hello, S3!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Made with ❤️ with \u0026lt;a href=\u0026#34;https://pulumi.com\u0026#34;\u0026gt;Pulumi\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Hosted with ❤️ by AWS!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Now that we have our website file, we\u0026rsquo;re ready to upload these files to our S3 bucket website.\nStep 2 — Upload the Bucket Contents Back in our Pulumi program, let\u0026rsquo;s add a resource for our index file for our static site. Add the following code to the bottom of your index.ts file:\nnew aws.s3.BucketObject(\u0026#34;index.html\u0026#34;, { bucket: bucket, source: new pulumi.asset.FileAsset(\u0026#34;www/index.html\u0026#34;), acl: \u0026#34;public-read\u0026#34;, contentType: \u0026#34;text/html\u0026#34;, }); We also would like the name of our bucket to be visible outside of our Pulumi program so that we can list the contents of the bucket to verify that our local files have indeed been written to the bucket.\nWe verify the creation of resources here for the purpose of demonstration in this tutorial, but once you\u0026rsquo;re comfortable using Pulumi, verifying the creation of resources is not necessary.\nIn order to make values in a Pulumi program visible to the outside world, we use the pulumi.export method. This creates a Stack Output and its value can be obtained via the command line by using the pulumi stack output command. For more information, see Stack Outputs in the Pulumi docs.\nAdd the following to your index.ts:\nexport const bucketName = bucket.bucket; At this point, your index.ts should look like the following:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; const bucket = new aws.s3.Bucket(\u0026#34;my-website-bucket\u0026#34;, { website: { indexDocument: \u0026#34;index.html\u0026#34;, }, }); new aws.s3.BucketObject(\u0026#34;index.html\u0026#34;, { bucket: bucket, source: new pulumi.asset.FileAsset(\u0026#34;www/index.html\u0026#34;), acl: \u0026#34;public-read\u0026#34;, contentType: \u0026#34;text/html\u0026#34;, }); export const bucketName = bucket.bucket; Deploy the changes:\npulumi up This will give you a preview similar to the following:\nPreviewing update (dev) View in Browser (Ctrl+O): https://app.pulumi.com/jkodrofftest/iac-workshop-ts/dev/previews/03c1110d-2919-4e82-bef4-02c9db3b503f Type Name Plan pulumi:pulumi:Stack iac-workshop-ts-dev + └─ aws:s3:BucketObject index.html create Outputs: + bucketName: \u0026#34;my-website-bucket-5d3569c\u0026#34; Resources: + 1 to create 2 unchanged Do you want to perform this update? yes Note that our output lists 1 item to create (our bucket object we just defined), but no changes are applied to our stack or S3 bucket. This is because Pulumi is declarative: we declare the desired end state of our infrastructure, and Pulumi figures out the steps necessary to get our infrastructure to that desired state. To put it another way, with Pulumi we declare what we want and Pulumi will determine how (i.e., the individual changes necessary) to get what we want.\nSelect yes to deploy the bucket object.\nWe can now list the contents of our bucket using the AWS CLI (or via the AWS Console) and see the files have been uploaded:\n$ aws s3 ls $(pulumi stack output bucketName) 2023-04-03 19:37:54 231 index.html Step 3 — Add a Bucket Policy Now that we have an S3 bucket and an object in it, we need to make the bucket accessible so we can see it. Currently, the objects in the bucket are private.\nThere are a few methods to manage this, but we\u0026rsquo;re going to do it by adding a bucket policy to the bucket that allows objects to be read.\nCreate a new bucket policy object in your Pulumi program like so:\nnew aws.s3.BucketPolicy(\u0026#34;bucket-policy\u0026#34;, { bucket: bucket.id, policy: pulumi.jsonStringify({ Version: \u0026#34;2012-10-17\u0026#34;, Statement: [{ Effect: \u0026#34;Allow\u0026#34;, Principal: \u0026#34;*\u0026#34;, Action: [\u0026#34;s3:GetObject\u0026#34;], Resource: [ pulumi.interpolate`${bucket.arn}/*`, ], }] }) }); In the code above, notice that we use pulumi.jsonStringify instead of JSON.stringify. Because the ARN of the S3 bucket is not known until after it\u0026rsquo;s created, we can\u0026rsquo;t use a plain string to represent its value. Instead, bucket.arn is a Pulumi Output. (Pulumi Inputs and Outputs are similar to promises, but they also include information that helps track the order of dependencies in Pulumi resources. This is a large part of how Pulumi works in a declarative fashion: by keeping track of dependencies in inputs and outputs.) In the example above, we use the ARN of the bucket to formulate the bucket policy which allows all objects in the bucket to be read by anyone. For more information on this topic, see Inputs and Outputs.\nBefore we update our Pulumi program, let\u0026rsquo;s add one final line of code to give us the URL of our static site. Add the following at the end of your index.ts:\nexport const bucketUrl = pulumi.interpolate`http://${bucket.websiteEndpoint}`; This exports the website endpoint so we can view the contents of our bucket. Note that pulumi.interpolate as it allows us to create a regular string from a Pulumi Output (a value which is not known until after a resource is created).\nYour index.ts should look like the following:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; const bucket = new aws.s3.Bucket(\u0026#34;my-website-bucket\u0026#34;, { website: { indexDocument: \u0026#34;index.html\u0026#34;, }, }); new aws.s3.BucketObject(\u0026#34;index.html\u0026#34;, { bucket: bucket, source: new pulumi.asset.FileAsset(\u0026#34;www/index.html\u0026#34;), acl: \u0026#34;public-read\u0026#34;, contentType: \u0026#34;text/html\u0026#34;, }); new aws.s3.BucketPolicy(\u0026#34;bucket-policy\u0026#34;, { bucket: bucket.id, policy: pulumi.jsonStringify({ Version: \u0026#34;2012-10-17\u0026#34;, Statement: [{ Effect: \u0026#34;Allow\u0026#34;, Principal: \u0026#34;*\u0026#34;, Action: [\u0026#34;s3:GetObject\u0026#34;], Resource: [ pulumi.interpolate`${bucket.arn}/*`, ], }] }) }); export const bucketName = bucket.bucket; export const websiteUrl = pulumi.interpolate`http://${bucket.websiteEndpoint}`; Deploy the changes:\npulumi up You\u0026rsquo;ll see the BucketPolicy get added. You\u0026rsquo;ll also get a URL as an output. We can now view the contents of that URL using curl:\ncurl $(pulumi stack output websiteUrl) You should also be able to view the contents in your browser, take a look!\nStep 4 — Destroy your Infrastructure We\u0026rsquo;re done with this module of the workshop! Let\u0026rsquo;s tear everything down.\npulumi destroy Pulumi will give you a warning. Select yes to continue and delete all resources in the stack.\nFinally, you can optionally remove the stack:\npulumi stack rm dev "
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python/20_getting_started_with_pulumi/30_updating_infrastructure.html",
	"title": "1.4 Updating Infrastructure",
	"tags": [],
	"description": "",
	"content": "We just saw how to create new infrastructure. Next, let\u0026rsquo;s make a few updates.\nThis exercise demonstrates how declarative infrastructure as code tools can be used not just for initial provisioning, but also subsequent changes to existing resources.\nStep 1 — Create Website Files Create a directory www/ and add a new index.html file with the following contents:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello, Pulumi!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Hello, S3!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Made with ❤️ with \u0026lt;a href=\u0026#34;https://pulumi.com\u0026#34;\u0026gt;Pulumi\u0026lt;/a\u0026gt; and Python\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Hosted with ❤️ by AWS!\u0026lt;/p\u0026gt; \u0026lt;img src=\u0026#34;python.png\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Next, download a python image to the www directory:\ncurl https://raw.githubusercontent.com/pulumi/examples/ec43670866809bfd64d3a39f68451f957d3c1e1d/aws-py-s3-folder/www/python.png -o www/python.png Now that we have our website files, we\u0026rsquo;re ready to upload these files to our S3 bucket website.\nStep 2 — Upload the Bucket Contents Back in our Pulumi program, let\u0026rsquo;s add two new imports near the top of our __main__.py with the rest of our imports:\nimport mimetypes import os Next, we\u0026rsquo;ll list the files in the www directory and add a new s3.BucketObject resource for each file. Because Pulumi allows us to use real programming languages to define our infrastructure, we can use regular Python libraries like mimetypes and os along with language constructs like for loops.\nAdd the following code to the bottom of your __main__.py file:\ncontent_dir = \u0026#34;www\u0026#34; for file in os.listdir(content_dir): filepath = os.path.join(content_dir, file) mime_type, _ = mimetypes.guess_type(filepath) obj = aws.s3.BucketObject( file, bucket=bucket.id, source=pulumi.FileAsset(filepath), content_type=mime_type, ) We also would like the name of our bucket to be visible outside of our Pulumi program so that we can list the contents of the bucket to verify that our local files have indeed been written to the bucket. (We do this for the purposes of demonstration in this tutorial, but once you\u0026rsquo;re comfortable using Pulumi, verifying the creation of resources is not necessary.)\nIn order to make values in a Pulumi program visible to the outside world, we use the pulumi.export method. This creates a Stack Output and its value can be obtained via the command line by using the pulumi stack output command. For more information, see Stack Outputs in the Pulumi docs.\nAdd the following to your __main__.py:\npulumi.export(\u0026#34;bucket_name\u0026#34;, bucket.bucket) At this point, your __main.py__ should look like the following:\n\u0026#34;\u0026#34;\u0026#34;A Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws import mimetypes import os bucket = aws.s3.Bucket( \u0026#34;my-website-bucket\u0026#34;, aws.s3.BucketArgs( website=aws.s3.BucketWebsiteArgs( index_document=\u0026#34;index.html\u0026#34; ) ) ) content_dir = \u0026#34;www\u0026#34; for file in os.listdir(content_dir): filepath = os.path.join(content_dir, file) mime_type, _ = mimetypes.guess_type(filepath) obj = aws.s3.BucketObject( file, aws.s3.BucketObjectArgs( bucket=bucket.id, source=pulumi.FileAsset(filepath), content_type=mime_type, ) ) pulumi.export(\u0026#34;bucket_name\u0026#34;, bucket.bucket) Deploy the changes:\npulumi up This will give you a preview similar to the following:\nPreviewing update (dev) View Live: https://app.pulumi.com/user/iac-workshop/dev/previews/3b99429c-bcf4-4a52-a831-08173f962756 Type Name Plan pulumi:pulumi:Stack iac-workshop-dev + ├─ aws:s3:BucketObject index.html create + └─ aws:s3:BucketObject python.png create Resources: + 2 to create 2 unchanged Do you want to perform this update? yes Note that our output lists 2 items to create (our bucket objects we just defined), but no changes are applied to our stack or S3 bucket. This is because Pulumi is declarative: we declare the desired end state of our infrastructure, and Pulumi figures out the steps necessary to get our infrastructure to that desired state. To put it another way, with Pulumi we declare what we want and Pulumi will determine how (i.e., the individual changes necessary) to get what we want.\nSelect yes to deploy the bucket objects.\nWe can now list the contents of our bucket using the AWS CLI (or via the AWS Console) and see the files have been uploaded:\naws s3 ls $(pulumi stack output bucket_name) Step 3 — Add a Bucket Policy Now that we have an S3 bucket and some objects in it, we need to make the bucket accessible so we can see it. Currently, the objects in the bucket are private.\nThere are a few methods to manage this, but we\u0026rsquo;re going to do it by adding a bucket policy to the bucket that allows objects to be read.\nWe\u0026rsquo;re going to be dealing with a JSON string here, so let\u0026rsquo;s add a new import so we can deal structured JSON:\nimport json Create a new bucket policy object in your Pulumi program like so:\nbucket_policy = aws.s3.BucketPolicy( \u0026#34;my-website-bucket-policy\u0026#34;, bucket=bucket.id, policy=bucket.arn.apply( lambda arn: json.dumps({ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [{ \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ f\u0026#34;{arn}/*\u0026#34; ] }] })), ) In the code above, we need to make use of a special Pulumi method called apply. Because the ARN of the S3 bucket is not known until after it\u0026rsquo;s created, we can\u0026rsquo;t use a plain string to represent its value. Instead, bucket.arn is a Pulumi Output. (If you\u0026rsquo;re familiar with JavaScript, Pulumi Outputs are similar to promises.) All Pulumi Outputs have a special function called apply which allows us to use the value of the output once it\u0026rsquo;s known. In the example above, we use the ARN of the bucket to formulate the bucket policy which allows all objects in the bucket to be read by anyone.\nNote that we\u0026rsquo;re also using the bucket.id Output as an Input to the bucket policy. In most cases, we can seamlessly use an Output of one resource as the Input of another resource, but because we have to embed the value of the ARN in the bucket policy, we need to use apply when creating the policy. (The most common need for apply in AWS is when we\u0026rsquo;re creating policies, like S3 bucket policies or IAM polices.) For additional information on Pulumi Inputs and Outputs, see Inputs and Outputs in the Pulumi docs.\nBefore we update our Pulumi program, let\u0026rsquo;s add one final line of code to give us the URL of our static site. Add the following at the end of your __main__.py:\npulumi.export(\u0026#34;website_url\u0026#34;, pulumi.Output.concat( \u0026#34;http://\u0026#34;, bucket.website_endpoint)) This exports the website endpoint so we can view the contents of our bucket. Note that pulumi.Output.concat is a helper function that allows us to create a regular string from a Pulumi Output (a value which is not known until after a resource is created). It\u0026rsquo;s a convenient helper function that works very similarly to apply.\nYour __main__.py should look like the following:\n\u0026#x2705; After this change, your __main__.py should look like this:\n\u0026#34;\u0026#34;\u0026#34;A Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws import mimetypes import os import json bucket = aws.s3.Bucket( \u0026#34;my-website-bucket\u0026#34;, aws.s3.BucketArgs( acl=\u0026#34;public-read\u0026#34;, website=aws.s3.BucketWebsiteArgs( index_document=\u0026#34;index.html\u0026#34; ) ) ) content_dir = \u0026#34;www\u0026#34; for file in os.listdir(content_dir): filepath = os.path.join(content_dir, file) mime_type, _ = mimetypes.guess_type(filepath) obj = aws.s3.BucketObject( file, aws.s3.BucketObjectArgs( bucket=bucket.id, source=pulumi.FileAsset(filepath), content_type=mime_type, ) ) pulumi.export(\u0026#34;bucket_name\u0026#34;, bucket.bucket) aws.s3.BucketPolicy( \u0026#34;my-website-bucket-policy\u0026#34;, aws.s3.BucketPolicyArgs( bucket=bucket.id, policy=bucket.arn.apply( lambda arn: json.dumps({ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [{ \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ f\u0026#34;{arn}/*\u0026#34; ] }] })), ) ) pulumi.export(\u0026#34;website_url\u0026#34;, pulumi.Output.concat( \u0026#34;http://\u0026#34;, bucket.website_endpoint)) Deploy the changes:\npulumi up You\u0026rsquo;ll see the BucketPolicy get added. You\u0026rsquo;ll also get a URL as an output. We can now view the contents of that URL using curl:\ncurl $(pulumi stack output website_url) You should also be able to view the contents in your browser, take a look!\nStep 4 — Destroy your Infrastructure We\u0026rsquo;re done with this section of the workshop! Let\u0026rsquo;s tear everything down.\npulumi destroy Pulumi will give you a warning. Select yes to continue and delete all resources in the stack.\nFinally, you can remove the stack:\npulumi stack rm dev "
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java/20_getting_started_with_pulumi/30_updating_infrastructure.html",
	"title": "1.4 Updating Infrastructure",
	"tags": [],
	"description": "",
	"content": "We just saw how to create new infrastructure from scratch. Next, let\u0026rsquo;s make a few updates:\nAdd an object to your bucket. Serve content from your bucket as a website. Programmatically create infrastructure. This demonstrates how declarative infrastrucutre as code tools can be used not just for initial provisioning, but also subsequent changes to existing resources.\nStep 1 — Add an Object to Your Bucket Create a directory src/main/resources/www and add a new index.html file with the following contents:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello, Pulumi!\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Hello, S3!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Made with ❤️ with \u0026lt;a href=\u0026#34;https://pulumi.com\u0026#34;\u0026gt;Pulumi\u0026lt;/a\u0026gt; and Java\u0026lt;/p\u0026gt; \u0026lt;img src=\u0026#34;java.png\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; Next, download a java image to the src/main/resources/www directory:\ncurl https://upload.wikimedia.org/wikipedia/en/thumb/3/30/Java_programming_language_logo.svg/1200px-Java_programming_language_logo.svg.png -o src/main/resources/www/java.png Now we\u0026rsquo;ve created our example website, we\u0026rsquo;re ready to upload these files to our s3 bucket website.\nStep 2 — Upload the Bucket Contents Back inside our Pulumi program, we now need to upload these contents to our bucket.\nWe\u0026rsquo;ll list the contents of the www directory, and, for each file, we\u0026rsquo;ll add a new Pulumi resource called BucketObject. We\u0026rsquo;ll add two new functions to help us: readFilesFromDirectory and guessContentType. Add the following code:\n// ... in the imports import com.pulumi.aws.s3.BucketObject; import com.pulumi.aws.s3.BucketObjectArgs; import java.io.IOException; import java.net.URISyntaxException; import java.nio.file.Files; import java.nio.file.Path; import java.util.Objects; import java.util.stream.Stream; // ... // ... in main() after the bucket creation readFilesFromDirectory(\u0026#34;www\u0026#34;).forEach(path -\u0026gt; new BucketObject(path.getFileName().toString(), BucketObjectArgs.builder() .bucket(bucket.getId()) .source(new FileAsset(path.toString())) .contentType(guessContentType(path)) .build(), CustomResourceOptions.builder() .dependsOn(bucket) .build() )); // ... // ... then, after main() within the App() class private static Stream\u0026lt;Path\u0026gt; readFilesFromDirectory(String classPathDir) { try { var normalizedPath = classPathDir.startsWith(\u0026#34;/\u0026#34;) ? classPathDir : \u0026#34;/\u0026#34; + classPathDir; var directoryPath = Path.of(Objects.requireNonNull(App.class.getResource(normalizedPath)).toURI()); return Files.walk(directoryPath).filter(Files::isRegularFile); } catch (IOException | URISyntaxException error) { throw new RuntimeException(error); } } private static String guessContentType(Path file) { try { return Files.probeContentType(file); } catch (IOException error) { throw new RuntimeException(error); } } Deploy the changes:\npulumi up This will give you a preview and selecting yes will apply the changes:\nType Name Plan pulumi:pulumi:Stack iac-workshop-dev └─ aws-native:s3:Bucket my-website-bucket + ├─ aws:s3:BucketObject java.png create + └─ aws:s3:BucketObject index.html create Resources: + 2 to create 2 unchanged We can now list the contents of our bucket again and see the files have been uploaded:\n$ aws s3 ls $(pulumi stack output bucket_name) 2022-05-04 16:51:58 218 index.html 2022-05-04 16:52:00 118587 java.png Step 3 — Add a Bucket Policy Now we have an S3 bucket and some objects in it, we need to make the bucket accessible so you can see it. Currently, the objects in the bucket are private.\nThere are a few methods to manage this, but we\u0026rsquo;re going to do it by adding a bucket policy to the bucket that allows objects to be read.\nWe\u0026rsquo;re going to be dealing with a JSON string here, so let\u0026rsquo;s add a new import so we can deal structured json:\nCreate a new bucket policy object in your Pulumi program like so:\n//... in the imports import com.pulumi.aws.s3.BucketPolicy; import com.pulumi.aws.s3.BucketPolicyArgs; // ... in the main() call var bucketPolicy = new BucketPolicy(\u0026#34;my-website-bucket-policy\u0026#34;, BucketPolicyArgs.builder() .bucket(bucket.getId()) .policy(bucket.arn().applyValue(arn -\u0026gt; \u0026#34;\u0026#34;\u0026#34; { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: [\u0026#34;s3:GetObject\u0026#34;], \u0026#34;Resource\u0026#34;: [\u0026#34;%s/*\u0026#34;] } ] }\u0026#34;\u0026#34;\u0026#34;.formatted(arn))) .build() ); Make a note of the policy object here. For the \u0026lsquo;policy\u0026rsquo; argument, you can either pass a raw java String or an Output\u0026laquo;String\u0026gt;String\u0026gt;. The latter pattern lets you reference things that will be only available once the entire stack is run - in this particular example, we construct the policy based on bucket.arn(), which is not yet known at the time we write the code (and thus, it\u0026rsquo;s return type is Output\u0026laquo;String\u0026gt;String\u0026gt;).\nYour workshop host will explain Outputs here. If you\u0026rsquo;re following along on your own, please see this video for an explanation\n\u0026#x2705; After this change, your App.java should look like this:\npackage myproject; import com.pulumi.Pulumi; import com.pulumi.asset.FileAsset; import com.pulumi.aws.s3.Bucket; import com.pulumi.aws.s3.BucketObject; import com.pulumi.aws.s3.BucketObjectArgs; import com.pulumi.aws.s3.BucketPolicy; import com.pulumi.aws.s3.BucketPolicyArgs; import com.pulumi.aws.s3.inputs.BucketWebsiteArgs; import com.pulumi.resources.CustomResourceOptions; import java.io.IOException; import java.net.URISyntaxException; import java.nio.file.Files; import java.nio.file.Path; import java.util.Objects; import java.util.stream.Stream; public class App { public static void main(String[] args) { Pulumi.run(ctx -\u0026gt; { var bucket = new Bucket(\u0026#34;my-website-bucket\u0026#34;, BucketArgs.builder() .website(BucketWebsiteArgs.builder().indexDocument(\u0026#34;index.html\u0026#34;).build()) .build() ); var bucketPolicy = new BucketPolicy(\u0026#34;my-website-bucket-policy\u0026#34;, BucketPolicyArgs.builder() .bucket(bucket.getId()) .policy(bucket.arn().applyValue(arn -\u0026gt; \u0026#34;\u0026#34;\u0026#34; { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: [\u0026#34;s3:GetObject\u0026#34;], \u0026#34;Resource\u0026#34;: [\u0026#34;%s/*\u0026#34;] } ] }\u0026#34;\u0026#34;\u0026#34;.formatted(arn))) .build() ); readFilesFromDirectory(\u0026#34;www\u0026#34;).forEach(path -\u0026gt; new BucketObject(path.getFileName().toString(), BucketObjectArgs.builder() .bucket(bucket.getId()) .source(new FileAsset(path.toString())) .contentType(guessContentType(path)) .build(), CustomResourceOptions.builder() .dependsOn(bucket) .build() )); ctx.export(\u0026#34;bucket_name\u0026#34;, bucket.bucket()); }); } private static Stream\u0026lt;Path\u0026gt; readFilesFromDirectory(String classPathDir) { try { var normalizedPath = classPathDir.startsWith(\u0026#34;/\u0026#34;) ? classPathDir : \u0026#34;/\u0026#34; + classPathDir; var directoryPath = Path.of(Objects.requireNonNull(App.class.getResource(normalizedPath)).toURI()); return Files.walk(directoryPath).filter(Files::isRegularFile); } catch (IOException | URISyntaxException error) { throw new RuntimeException(error); } } private static String guessContentType(Path file) { try { return Files.probeContentType(file); } catch (IOException error) { throw new RuntimeException(error); } } } Before we update our pulumi program, let\u0026rsquo;s add one final line of code.\n// ... below the other export, add this line ctx.export(\u0026#34;website_url\u0026#34;, bucket.websiteEndpoint()); This exports the website endpoint so we can view the contents of our bucket.\nDeploy the changes:\npulumi up And you\u0026rsquo;ll see the BucketPolicy get added. You\u0026rsquo;ll also get a URL as an output. We can now view the contents of that URL using curl:\ncurl $(pulumi stack output website_url) You should also be able to view the contents in your browser, take a look!\nStep 4 — Destroy your Infrastructure We\u0026rsquo;re done with this section of the workshop! Let\u0026rsquo;s tear everything down.\npulumi destroy You\u0026rsquo;ll see Pulumi tell you it\u0026rsquo;s destroying infrastructure:\nPreviewing destroy (dev) View Live: https://app.pulumi.com/jaxxstorm/iac-workshop/dev/previews/33ce7a73-6d53-42df-854e-296a6276231d Type Name Plan - pulumi:pulumi:Stack iac-workshop-dev delete - ├─ aws:s3:BucketPolicy my-website-bucket-policy delete - └─ aws-native:s3:Bucket my-website-bucket delete - ├─ aws:s3:BucketObject java.png delete - └─ aws:s3:BucketObject index.html delete Outputs: - bucket_name: \u0026#34;my-website-bucket-4d8d96b\u0026#34; - website_url: \u0026#34;my-website-bucket-4d8d96b.s3-website-us-west-2.amazonaws.com\u0026#34; Resources: - 5 to delete Hit yes, and watch your bucket disappear.\nFinally, remove the stack:\npulumi stack rm dev "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/30_deploying_webservers/30_add_loadbalancer.html",
	"title": "2.4 Add a LoadBalancer",
	"tags": [],
	"description": "",
	"content": "Needing to loop over the webservers isn\u0026rsquo;t very realistic. You will now create a load balancer over them to distribute load evenly.\nStep 1 — Update our Security Group We need to add an egress rule to our security group. Whenever you add a listener to your load balancer or update the health check port for a target group used by the load balancer to route requests, you must verify that the security groups associated with the load balancer allow traffic on the new port in both directions.\n... group = aws.ec2.SecurityGroup( \u0026#34;web-secgrp\u0026#34;, ingress=[ { \u0026#39;protocol\u0026#39;: \u0026#39;icmp\u0026#39;, \u0026#39;from_port\u0026#39;: 8, \u0026#39;to_port\u0026#39;: 0, \u0026#39;cidr_blocks\u0026#39;: [\u0026#39;0.0.0.0/0\u0026#39;] }, { \u0026#39;protocol\u0026#39;: \u0026#39;tcp\u0026#39;, \u0026#39;from_port\u0026#39;: 80, \u0026#39;to_port\u0026#39;: 80, \u0026#39;cidr_blocks\u0026#39;: [\u0026#39;0.0.0.0/0\u0026#39;] }, ], egress=[ { \u0026#39;protocol\u0026#39;: \u0026#39;tcp\u0026#39;, \u0026#39;from_port\u0026#39;: 80, \u0026#39;to_port\u0026#39;: 80, \u0026#39;cidr_blocks\u0026#39;: [\u0026#39;0.0.0.0/0\u0026#39;] }, ] ) ... This is required to ensure the security group ingress rules don\u0026rsquo;t conflict with the load balancer\u0026rsquo;s.\nStep 2 — Define the ALB Now right after the security group creation, and before the EC2 creation block, add the load balancer creation steps:\n... vpc = aws.ec2.get_vpc(default=True) vpc_subnets = aws.ec2.get_subnet_ids(vpc_id=vpc.id) lb = aws.lb.LoadBalancer( \u0026#34;loadbalancer\u0026#34;, internal=False, security_groups=[group.id], subnets=vpc_subnets.ids, load_balancer_type=\u0026#34;application\u0026#34;, ) target_group = aws.lb.TargetGroup( \u0026#34;target-group\u0026#34;, port=80, protocol=\u0026#34;HTTP\u0026#34;, target_type=\u0026#34;ip\u0026#34;, vpc_id=vpc.id ) listener = aws.lb.Listener( \u0026#34;listener\u0026#34;, load_balancer_arn=lb.arn, port=80, default_actions=[{\u0026#34;type\u0026#34;: \u0026#34;forward\u0026#34;, \u0026#34;target_group_arn\u0026#34;: target_group.arn}], ) ... Here, we\u0026rsquo;ve defined the ALB, its TargetGroup and some Listeners, but we haven\u0026rsquo;t actually added the EC2 instances to the ALB.\nStep 3 — Add the Instances to the ALB Replace the EC2 creation block with the following:\n... ips = [] hostnames = [] for az in aws.get_availability_zones().names: server = aws.ec2.Instance(f\u0026#39;web-server-{az}\u0026#39;, instance_type=\u0026#34;t2.micro\u0026#34;, security_groups=[group.name], ami=ami.id, user_data=\u0026#34;\u0026#34;\u0026#34;#!/bin/bash echo \\\u0026#34;Hello, World -- from {}!\\\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp; \u0026#34;\u0026#34;\u0026#34;.format(az), availability_zone=az, tags={ \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34;, }, ) ips.append(server.public_ip) hostnames.append(server.public_dns) attachment = aws.lb.TargetGroupAttachment(f\u0026#39;web-server-{az}\u0026#39;, target_group_arn=target_group.arn, target_id=server.private_ip, port=80, ) export(\u0026#39;ips\u0026#39;, ips) export(\u0026#39;hostnames\u0026#39;, hostnames) export(\u0026#34;url\u0026#34;, lb.dns_name) \u0026#x2705; After this change, your __main__.py should look like this:\n\u0026#34;\u0026#34;\u0026#34;An AWS Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws ami = aws.get_ami( most_recent=\u0026#34;true\u0026#34;, owners=[\u0026#34;137112412989\u0026#34;], filters=[{\u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;values\u0026#34;: [\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;]}], ) vpc = aws.ec2.get_vpc(default=True) vpc_subnets = aws.ec2.get_subnet_ids(vpc_id=vpc.id) group = aws.ec2.SecurityGroup( \u0026#34;web-secgrp\u0026#34;, description=\u0026#34;Enable HTTP Access\u0026#34;, vpc_id=vpc.id, ingress=[ { \u0026#34;protocol\u0026#34;: \u0026#34;icmp\u0026#34;, \u0026#34;from_port\u0026#34;: 8, \u0026#34;to_port\u0026#34;: 0, \u0026#34;cidr_blocks\u0026#34;: [\u0026#34;0.0.0.0/0\u0026#34;], }, { \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;from_port\u0026#34;: 80, \u0026#34;to_port\u0026#34;: 80, \u0026#34;cidr_blocks\u0026#34;: [\u0026#34;0.0.0.0/0\u0026#34;], }, ], egress=[ { \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;from_port\u0026#34;: 80, \u0026#34;to_port\u0026#34;: 80, \u0026#34;cidr_blocks\u0026#34;: [\u0026#34;0.0.0.0/0\u0026#34;], } ], ) lb = aws.lb.LoadBalancer( \u0026#34;loadbalancer\u0026#34;, internal=False, security_groups=[group.id], subnets=vpc_subnets.ids, load_balancer_type=\u0026#34;application\u0026#34;, ) target_group = aws.lb.TargetGroup( \u0026#34;target-group\u0026#34;, port=80, protocol=\u0026#34;HTTP\u0026#34;, target_type=\u0026#34;ip\u0026#34;, vpc_id=vpc.id ) listener = aws.lb.Listener( \u0026#34;listener\u0026#34;, load_balancer_arn=lb.arn, port=80, default_actions=[{\u0026#34;type\u0026#34;: \u0026#34;forward\u0026#34;, \u0026#34;target_group_arn\u0026#34;: target_group.arn}], ) ips = [] hostnames = [] for az in aws.get_availability_zones().names: server = aws.ec2.Instance( f\u0026#34;web-server-{az}\u0026#34;, instance_type=\u0026#34;t2.micro\u0026#34;, vpc_security_group_ids=[group.id], ami=ami.id, user_data=\u0026#34;\u0026#34;\u0026#34;#!/bin/bash echo \\\u0026#34;Hello, World -- from {}!\\\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp; \u0026#34;\u0026#34;\u0026#34;.format( az ), tags={ \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34;, }, ) ips.append(server.public_ip) hostnames.append(server.public_dns) attachment = aws.lb.TargetGroupAttachment( f\u0026#34;web-server-{az}\u0026#34;, target_group_arn=target_group.arn, target_id=server.private_ip, port=80, ) pulumi.export(\u0026#34;ips\u0026#34;, ips) pulumi.export(\u0026#34;hostnames\u0026#34;, hostnames) pulumi.export(\u0026#34;url\u0026#34;, lb.dns_name) This is all the infrastructure we need for our load balanced webserver. Let\u0026rsquo;s apply it.\nStep 4 — Deploy your Changes Deploy these updates:\npulumi up This should result in a fairly large update and, if all goes well, the load balancer\u0026rsquo;s resulting endpoint URL:\nUpdating (dev): Type Name Status pulumi:pulumi:Stack python-testing-dev created ~ ├─ aws:ec2:SecurityGroup web-secgrp updated [diff: ~ingress, ~egress] + ├─ aws:lb:TargetGroup target-group created + ├─ aws:lb:LoadBalancer external-loadbalancer created + ├─ aws:lb:TargetGroupAttachment web-server-us-west-2a created + ├─ aws:lb:TargetGroupAttachment web-server-us-west-2c created + ├─ aws:lb:TargetGroupAttachment web-server-us-west-2d created + └─ aws:lb:TargetGroupAttachment web-server-us-west-2b created + └─ aws:lb:Listener listener created Outputs: hostnames: [ [0]: \u0026#34;ec2-18-197-184-46.us-west-2.compute.amazonaws.com\u0026#34; [1]: \u0026#34;ec2-18-196-225-191.us-west-2.compute.amazonaws.com\u0026#34; [2]: \u0026#34;ec2-35-158-83-62.us-west-2.compute.amazonaws.com\u0026#34; ] ips : [ [0]: \u0026#34;18.197.184.46\u0026#34; [1]: \u0026#34;18.196.225.191\u0026#34; [2]: \u0026#34;35.158.83.62\u0026#34; + url : \u0026#34;web-traffic-09348bc-723263075.us-west-2.elb.amazonaws.com\u0026#34; Resources: + 7 created ~ 1 updated 8 changes. 4 unchanged Duration: 2m33s Permalink: https://app.pulumi.com/jaxxstorm/iac-workshop/dev/updates/3 Step 5 — Verify Now we can curl the load balancer:\nfor i in {0..10}; do curl $(pulumi stack output url); done Observe that the resulting text changes based on where the request is routed:\nHello, World -- from us-west-2a! Hello, World -- from us-west-2a! Hello, World -- from us-west-2d! Hello, World -- from us-west-2b! Hello, World -- from us-west-2b! Hello, World -- from us-west-2c! Hello, World -- from us-west-2b! Hello, World -- from us-west-2a! Hello, World -- from us-west-2c! Hello, World -- from us-west-2d! Hello, World -- from us-west-2a! Step 6 — Destroy Everything Finally, destroy the resources and the stack itself:\npulumi destroy pulumi stack rm "
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python/30_deploying_webservers/30_add_loadbalancer.html",
	"title": "2.4 Add a LoadBalancer",
	"tags": [],
	"description": "",
	"content": "Needing to loop over the webservers isn\u0026rsquo;t very realistic. You will now create a load balancer over them to distribute load evenly.\nStep 1 — Update our Security Group We need to add an egress rule to our security group. Whenever you add a listener to your load balancer or update the health check port for a target group used by the load balancer to route requests, you must verify that the security groups associated with the load balancer allow traffic on the new port in both directions.\n... group = aws.ec2.SecurityGroup( \u0026#34;web-secgrp\u0026#34;, ingress=[ { \u0026#39;protocol\u0026#39;: \u0026#39;icmp\u0026#39;, \u0026#39;from_port\u0026#39;: 8, \u0026#39;to_port\u0026#39;: 0, \u0026#39;cidr_blocks\u0026#39;: [\u0026#39;0.0.0.0/0\u0026#39;] }, { \u0026#39;protocol\u0026#39;: \u0026#39;tcp\u0026#39;, \u0026#39;from_port\u0026#39;: 80, \u0026#39;to_port\u0026#39;: 80, \u0026#39;cidr_blocks\u0026#39;: [\u0026#39;0.0.0.0/0\u0026#39;] }, ], egress=[ { \u0026#39;protocol\u0026#39;: \u0026#39;tcp\u0026#39;, \u0026#39;from_port\u0026#39;: 80, \u0026#39;to_port\u0026#39;: 80, \u0026#39;cidr_blocks\u0026#39;: [\u0026#39;0.0.0.0/0\u0026#39;] }, ] ) ... This is required to ensure the security group ingress rules don\u0026rsquo;t conflict with the load balancer\u0026rsquo;s.\nStep 2 — Define the ALB Now right after the security group creation, and before the EC2 creation block, add the load balancer creation steps:\n... vpc = aws.ec2.get_vpc(default=True) vpc_subnets = aws.ec2.get_subnet_ids(vpc_id=vpc.id) lb = aws.lb.LoadBalancer( \u0026#34;loadbalancer\u0026#34;, internal=False, security_groups=[group.id], subnets=vpc_subnets.ids, load_balancer_type=\u0026#34;application\u0026#34;, ) target_group = aws.lb.TargetGroup( \u0026#34;target-group\u0026#34;, port=80, protocol=\u0026#34;HTTP\u0026#34;, target_type=\u0026#34;ip\u0026#34;, vpc_id=vpc.id ) listener = aws.lb.Listener( \u0026#34;listener\u0026#34;, load_balancer_arn=lb.arn, port=80, default_actions=[{\u0026#34;type\u0026#34;: \u0026#34;forward\u0026#34;, \u0026#34;target_group_arn\u0026#34;: target_group.arn}], ) ... Here, we\u0026rsquo;ve defined the ALB, its TargetGroup and some Listeners, but we haven\u0026rsquo;t actually added the EC2 instances to the ALB.\nStep 3 — Add the Instances to the ALB Replace the EC2 creation block with the following:\n... ips = [] hostnames = [] for az in aws.get_availability_zones().names: server = aws.ec2.Instance(f\u0026#39;web-server-{az}\u0026#39;, instance_type=\u0026#34;t2.micro\u0026#34;, security_groups=[group.name], ami=ami.id, user_data=\u0026#34;\u0026#34;\u0026#34;#!/bin/bash echo \\\u0026#34;Hello, World -- from {}!\\\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp; \u0026#34;\u0026#34;\u0026#34;.format(az), availability_zone=az, tags={ \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34;, }, ) ips.append(server.public_ip) hostnames.append(server.public_dns) attachment = aws.lb.TargetGroupAttachment(f\u0026#39;web-server-{az}\u0026#39;, target_group_arn=target_group.arn, target_id=server.private_ip, port=80, ) export(\u0026#39;ips\u0026#39;, ips) export(\u0026#39;hostnames\u0026#39;, hostnames) export(\u0026#34;url\u0026#34;, lb.dns_name) \u0026#x2705; After this change, your __main__.py should look like this:\n\u0026#34;\u0026#34;\u0026#34;An AWS Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws ami = aws.get_ami( most_recent=\u0026#34;true\u0026#34;, owners=[\u0026#34;137112412989\u0026#34;], filters=[{\u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;values\u0026#34;: [\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;]}], ) vpc = aws.ec2.get_vpc(default=True) vpc_subnets = aws.ec2.get_subnet_ids(vpc_id=vpc.id) group = aws.ec2.SecurityGroup( \u0026#34;web-secgrp\u0026#34;, description=\u0026#34;Enable HTTP Access\u0026#34;, vpc_id=vpc.id, ingress=[ { \u0026#34;protocol\u0026#34;: \u0026#34;icmp\u0026#34;, \u0026#34;from_port\u0026#34;: 8, \u0026#34;to_port\u0026#34;: 0, \u0026#34;cidr_blocks\u0026#34;: [\u0026#34;0.0.0.0/0\u0026#34;], }, { \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;from_port\u0026#34;: 80, \u0026#34;to_port\u0026#34;: 80, \u0026#34;cidr_blocks\u0026#34;: [\u0026#34;0.0.0.0/0\u0026#34;], }, ], egress=[ { \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;from_port\u0026#34;: 80, \u0026#34;to_port\u0026#34;: 80, \u0026#34;cidr_blocks\u0026#34;: [\u0026#34;0.0.0.0/0\u0026#34;], } ], ) lb = aws.lb.LoadBalancer( \u0026#34;loadbalancer\u0026#34;, internal=False, security_groups=[group.id], subnets=vpc_subnets.ids, load_balancer_type=\u0026#34;application\u0026#34;, ) target_group = aws.lb.TargetGroup( \u0026#34;target-group\u0026#34;, port=80, protocol=\u0026#34;HTTP\u0026#34;, target_type=\u0026#34;ip\u0026#34;, vpc_id=vpc.id ) listener = aws.lb.Listener( \u0026#34;listener\u0026#34;, load_balancer_arn=lb.arn, port=80, default_actions=[{\u0026#34;type\u0026#34;: \u0026#34;forward\u0026#34;, \u0026#34;target_group_arn\u0026#34;: target_group.arn}], ) ips = [] hostnames = [] for az in aws.get_availability_zones().names: server = aws.ec2.Instance( f\u0026#34;web-server-{az}\u0026#34;, instance_type=\u0026#34;t2.micro\u0026#34;, vpc_security_group_ids=[group.id], ami=ami.id, user_data=\u0026#34;\u0026#34;\u0026#34;#!/bin/bash echo \\\u0026#34;Hello, World -- from {}!\\\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp; \u0026#34;\u0026#34;\u0026#34;.format( az ), tags={ \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34;, }, ) ips.append(server.public_ip) hostnames.append(server.public_dns) attachment = aws.lb.TargetGroupAttachment( f\u0026#34;web-server-{az}\u0026#34;, target_group_arn=target_group.arn, target_id=server.private_ip, port=80, ) pulumi.export(\u0026#34;ips\u0026#34;, ips) pulumi.export(\u0026#34;hostnames\u0026#34;, hostnames) pulumi.export(\u0026#34;url\u0026#34;, lb.dns_name) This is all the infrastructure we need for our load balanced webserver. Let\u0026rsquo;s apply it.\nStep 4 — Deploy your Changes Deploy these updates:\npulumi up This should result in a fairly large update and, if all goes well, the load balancer\u0026rsquo;s resulting endpoint URL:\nUpdating (dev): Type Name Status pulumi:pulumi:Stack python-testing-dev created ~ ├─ aws:ec2:SecurityGroup web-secgrp updated [diff: ~ingress, ~egress] + ├─ aws:lb:TargetGroup target-group created + ├─ aws:lb:LoadBalancer external-loadbalancer created + ├─ aws:lb:TargetGroupAttachment web-server-us-west-2a created + ├─ aws:lb:TargetGroupAttachment web-server-us-west-2c created + ├─ aws:lb:TargetGroupAttachment web-server-us-west-2d created + └─ aws:lb:TargetGroupAttachment web-server-us-west-2b created + └─ aws:lb:Listener listener created Outputs: hostnames: [ [0]: \u0026#34;ec2-18-197-184-46.us-west-2.compute.amazonaws.com\u0026#34; [1]: \u0026#34;ec2-18-196-225-191.us-west-2.compute.amazonaws.com\u0026#34; [2]: \u0026#34;ec2-35-158-83-62.us-west-2.compute.amazonaws.com\u0026#34; ] ips : [ [0]: \u0026#34;18.197.184.46\u0026#34; [1]: \u0026#34;18.196.225.191\u0026#34; [2]: \u0026#34;35.158.83.62\u0026#34; + url : \u0026#34;web-traffic-09348bc-723263075.us-west-2.elb.amazonaws.com\u0026#34; Resources: + 7 created ~ 1 updated 8 changes. 4 unchanged Duration: 2m33s Permalink: https://app.pulumi.com/jaxxstorm/iac-workshop/dev/updates/3 Step 5 — Verify Now we can curl the load balancer:\nfor i in {0..10}; do curl $(pulumi stack output url); done Observe that the resulting text changes based on where the request is routed:\nHello, World -- from us-west-2a! Hello, World -- from us-west-2a! Hello, World -- from us-west-2d! Hello, World -- from us-west-2b! Hello, World -- from us-west-2b! Hello, World -- from us-west-2c! Hello, World -- from us-west-2b! Hello, World -- from us-west-2a! Hello, World -- from us-west-2c! Hello, World -- from us-west-2d! Hello, World -- from us-west-2a! Step 6 — Destroy Everything Finally, destroy the resources and the stack itself:\npulumi destroy pulumi stack rm "
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java/30_deploying_webservers/30_add_loadbalancer.html",
	"title": "2.4 Add a LoadBalancer",
	"tags": [],
	"description": "",
	"content": "Needing to loop over the webservers isn\u0026rsquo;t very realistic. You will now create a load balancer over them to distribute load evenly.\nStep 1 — Update our Security Group We need to add an egress rule to our security group. Whenever you add a listener to your load balancer or update the health check port for a target group used by the load balancer to route requests, you must verify that the security groups associated with the load balancer allow traffic on the new port in both directions.\nvar securityGroup = new SecurityGroup(\u0026#34;web-secgrp\u0026#34;, SecurityGroupArgs .builder() .description(\u0026#34;Enable HTTP Access\u0026#34;) .vpcId(vpcIdOutput) .ingress( SecurityGroupIngressArgs.builder() .protocol(\u0026#34;tcp\u0026#34;) .fromPort(80) .toPort(80) .cidrBlocks(\u0026#34;0.0.0.0/0\u0026#34;) .build()) .egress( SecurityGroupEgressArgs.builder() .protocol(\u0026#34;tcp\u0026#34;) .fromPort(80) .toPort(80) .cidrBlocks(\u0026#34;0.0.0.0/0\u0026#34;) .build()) .build()); This is required to ensure the security group ingress rules don\u0026rsquo;t conflict with the load balancer\u0026rsquo;s.\nStep 2 — Define the ALB Now right after the security group creation, and before the EC2 creation block, add the load balancer creation steps:\nvar vpcSubnetsIds = defaultVpcId .thenCompose(vpcId -\u0026gt; Ec2Functions.getSubnetIds(GetSubnetIdsArgs.builder().vpcId(vpcId).build())) .thenApply(GetSubnetIdsResult::ids); var loadBalancer = new LoadBalancer(\u0026#34;loadbalancer\u0026#34;, LoadBalancerArgs.builder() .internal(false) .securityGroups(Output.all(securityGroup.getId())) .subnets(Output.of(vpcSubnetsIds)) .loadBalancerType(\u0026#34;application\u0026#34;) .build() ); var targetGroup = new TargetGroup(\u0026#34;target-group\u0026#34;, TargetGroupArgs.builder() .port(80) .protocol(\u0026#34;HTTP\u0026#34;) .targetType(\u0026#34;ip\u0026#34;) .vpcId(Output.of(defaultVpcId)) .build() ); var albListener = new Listener(\u0026#34;listener\u0026#34;, ListenerArgs.builder() .loadBalancerArn(loadBalancer.arn()) .port(80) .defaultActions( ListenerDefaultActionArgs.builder() .type(\u0026#34;forward\u0026#34;) .targetGroupArn(targetGroup.arn()) .build()) .build() ); Here, we\u0026rsquo;ve defined the ALB, its TargetGroup and some Listeners, but we haven\u0026rsquo;t actually added the EC2 instances to the ALB.\nStep 3 — Add the Instances to the ALB Replace the EC2 creation block with the following:\nvar instances = AwsFunctions.getAvailabilityZones().thenApply(response -\u0026gt; response.zoneIds().stream().map(availabilityZone -\u0026gt; { var ec2Instance = new Instance(\u0026#34;web-server-%s\u0026#34;.formatted(availabilityZone), InstanceArgs.builder() .instanceType(\u0026#34;t2.micro\u0026#34;) .vpcSecurityGroupIds(Output.all(securityGroup.getId())) .ami(Output.of(latestAmi)) .userData(\u0026#34;\u0026#34;\u0026#34; #!/bin/bash echo \u0026#34;Hello, World -- from %s!\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp;\u0026#34;\u0026#34;\u0026#34;.formatted(availabilityZone)) .tags(Map.of(\u0026#34;Name\u0026#34;, \u0026#34;web-server-%s\u0026#34;.formatted(availabilityZone))) .build() ); new TargetGroupAttachment(\u0026#34;web-server-%s\u0026#34;.formatted(availabilityZone), TargetGroupAttachmentArgs.builder() .targetGroupArn(targetGroup.arn()) .targetId(ec2Instance.privateIp()) .build() ); return ec2Instance; }).toList() ); var instancesOutput = Output.of(instances); var ipAddresses = instancesOutput.apply(ec2s -\u0026gt; Output.all(ec2s.stream().map(Instance::publicIp).toList())); var hostnames = instancesOutput.apply(ec2s -\u0026gt; Output.all(ec2s.stream().map(Instance::publicDns).toList())); ctx.export(\u0026#34;ips\u0026#34;, ipAddresses); ctx.export(\u0026#34;hostnames\u0026#34;, hostnames); ctx.export(\u0026#34;url\u0026#34;, loadBalancer.dnsName()); \u0026#x2705; After this change, your App.java should look like this:\npackage myproject; import com.pulumi.Pulumi; import com.pulumi.aws.AwsFunctions; import com.pulumi.aws.alb.*; import com.pulumi.aws.alb.inputs.ListenerDefaultActionArgs; import com.pulumi.aws.ec2.*; import com.pulumi.aws.ec2.inputs.*; import com.pulumi.aws.ec2.outputs.GetAmiResult; import com.pulumi.aws.ec2.outputs.GetSubnetIdsResult; import com.pulumi.aws.ec2.outputs.GetVpcResult; import com.pulumi.core.Output; import java.util.Map; public class App { public static void main(String[] args) { Pulumi.run(ctx -\u0026gt; { var latestAmi = Ec2Functions .getAmi( GetAmiArgs.builder() .mostRecent(true) .owners(\u0026#34;137112412989\u0026#34;) .filters(GetAmiFilter.builder().name(\u0026#34;name\u0026#34;).values(\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;).build()) .build() ).thenApply(GetAmiResult::id); var defaultVpcId = Ec2Functions .getVpc(GetVpcArgs.builder().default_(true).build()) .thenApply(GetVpcResult::id); var securityGroup = new SecurityGroup(\u0026#34;web-secgrp\u0026#34;, SecurityGroupArgs .builder() .description(\u0026#34;Enable HTTP Access\u0026#34;) .vpcId(Output.of(defaultVpcId)) .ingress( SecurityGroupIngressArgs.builder() .protocol(\u0026#34;tcp\u0026#34;) .fromPort(80) .toPort(80) .cidrBlocks(\u0026#34;0.0.0.0/0\u0026#34;) .build()) .egress( SecurityGroupEgressArgs.builder() .protocol(\u0026#34;tcp\u0026#34;) .fromPort(80) .toPort(80) .cidrBlocks(\u0026#34;0.0.0.0/0\u0026#34;) .build()) .build()); var vpcSubnetsIds = defaultVpcId .thenCompose(vpcId -\u0026gt; Ec2Functions.getSubnetIds(GetSubnetIdsArgs.builder().vpcId(vpcId).build())) .thenApply(GetSubnetIdsResult::ids); var loadBalancer = new LoadBalancer(\u0026#34;loadbalancer\u0026#34;, LoadBalancerArgs.builder() .internal(false) .securityGroups(Output.all(securityGroup.getId())) .subnets(Output.of(vpcSubnetsIds)) .loadBalancerType(\u0026#34;application\u0026#34;) .build() ); var targetGroup = new TargetGroup(\u0026#34;target-group\u0026#34;, TargetGroupArgs.builder() .port(80) .protocol(\u0026#34;HTTP\u0026#34;) .targetType(\u0026#34;ip\u0026#34;) .vpcId(Output.of(defaultVpcId)) .build() ); var albListener = new Listener(\u0026#34;listener\u0026#34;, ListenerArgs.builder() .loadBalancerArn(loadBalancer.arn()) .port(80) .defaultActions( ListenerDefaultActionArgs.builder() .type(\u0026#34;forward\u0026#34;) .targetGroupArn(targetGroup.arn()) .build()) .build() ); var instances = AwsFunctions.getAvailabilityZones().thenApply(response -\u0026gt; response.zoneIds().stream().map(availabilityZone -\u0026gt; { var ec2Instance = new Instance(\u0026#34;web-server-%s\u0026#34;.formatted(availabilityZone), InstanceArgs.builder() .instanceType(\u0026#34;t2.micro\u0026#34;) .vpcSecurityGroupIds(Output.all(securityGroup.getId())) .ami(Output.of(latestAmi)) .userData(\u0026#34;\u0026#34;\u0026#34; #!/bin/bash echo \u0026#34;Hello, World -- from %s!\u0026#34; \u0026gt; index.html nohup python -m SimpleHTTPServer 80 \u0026amp;\u0026#34;\u0026#34;\u0026#34;.formatted(availabilityZone)) .tags(Map.of(\u0026#34;Name\u0026#34;, \u0026#34;web-server-%s\u0026#34;.formatted(availabilityZone))) .build() ); new TargetGroupAttachment(\u0026#34;web-server-%s\u0026#34;.formatted(availabilityZone), TargetGroupAttachmentArgs.builder() .targetGroupArn(targetGroup.arn()) .targetId(ec2Instance.privateIp()) .build() ); return ec2Instance; }).toList() ); var instancesOutput = Output.of(instances); var ipAddresses = instancesOutput.apply(ec2s -\u0026gt; Output.all(ec2s.stream().map(Instance::publicIp).toList())); var hostnames = instancesOutput.apply(ec2s -\u0026gt; Output.all(ec2s.stream().map(Instance::publicDns).toList())); ctx.export(\u0026#34;ips\u0026#34;, ipAddresses); ctx.export(\u0026#34;hostnames\u0026#34;, hostnames); ctx.export(\u0026#34;url\u0026#34;, loadBalancer.dnsName()); }); } } This is all the infrastructure we need for our load balanced webserver. Let\u0026rsquo;s apply it.\nStep 4 — Deploy your Changes Deploy these updates:\npulumi up This should result in a fairly large update and, if all goes well, the load balancer\u0026rsquo;s resulting endpoint URL:\nUpdating (dev) Type Name Status Info pulumi:pulumi:Stack java-dev 1 warning ~ ├─ aws:ec2:SecurityGroup web-secgrp updated [diff: ~egress] + ├─ aws:alb:TargetGroup target-group created + ├─ aws:alb:LoadBalancer loadbalancer created + ├─ aws:alb:TargetGroupAttachment web-server-euw1-az2 created + ├─ aws:alb:TargetGroupAttachment web-server-euw1-az1 created + ├─ aws:alb:TargetGroupAttachment web-server-euw1-az3 created + └─ aws:alb:Listener listener created Outputs: hostnames: [ [0]: \u0026#34;ec2-34-253-216-194.eu-west-1.compute.amazonaws.com\u0026#34; [1]: \u0026#34;ec2-18-203-162-39.eu-west-1.compute.amazonaws.com\u0026#34; [2]: \u0026#34;ec2-54-155-163-18.eu-west-1.compute.amazonaws.com\u0026#34; ] ips : [ [0]: \u0026#34;34.253.216.194\u0026#34; [1]: \u0026#34;18.203.162.39\u0026#34; [2]: \u0026#34;54.155.163.18\u0026#34; ] + url : \u0026#34;loadbalancer-a1a71b8-1205493908.eu-west-1.elb.amazonaws.com\u0026#34; Resources: + 6 created ~ 1 updated 7 changes. 4 unchanged Duration: 2m10s Step 5 — Verify Now we can curl the load balancer:\nfor i in {0..10}; do curl $(pulumi stack output url); done Observe that the resulting text changes based on where the request is routed:\nHello, World -- from euw1-az1! Hello, World -- from euw1-az2! Hello, World -- from euw1-az1! Hello, World -- from euw1-az1! Hello, World -- from euw1-az3! Hello, World -- from euw1-az3! Hello, World -- from euw1-az2! Hello, World -- from euw1-az1! Hello, World -- from euw1-az2! Hello, World -- from euw1-az1! Hello, World -- from euw1-az3! Step 6 — Destroy Everything Finally, destroy the resources and the stack itself:\npulumi destroy pulumi stack rm "
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts/30_simple_api_gateway/30_processing_data.html",
	"title": "2.4 Processing Input Data",
	"tags": [],
	"description": "",
	"content": "We just saw how Pulumi Crosswalk allows you to quickly define serverless API endpoints and created a simple get request.\nNow, let\u0026rsquo;s take things a little further.\nStep 1 — Add a new API Gateway Route Create a new route in your API Gateway that accepts post requests. We\u0026rsquo;ll add this to our already created API Gateway in the routes: [] block. The route should like this this:\n{ path: \u0026#34;encode\u0026#34;, method: \u0026#34;POST\u0026#34;, eventHandler: async (event) =\u0026gt; { console.log(\u0026#34;request: \u0026#34; + JSON.stringify(event)); let body: string let responseCode: number if (event.body != null) { if (event.isBase64Encoded) { body = event.body // API gateway will base64 encode for us responseCode = 200 } else { body = Buffer.from(event.body).toString(\u0026#39;base64\u0026#39;) responseCode = 200 } } else { body = \u0026#34;No data submitted\u0026#34; responseCode = 400 } return { statusCode: responseCode, body: body, } }, } This new encode endpoint simply takes some HTTP body data and base64 encodes it for us. Let\u0026rsquo;s run this program and add the new route to our API gateway.\nThe index.ts file should now have the following contents:\nimport * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; const api = new awsx.apigateway.API(\u0026#34;hello-world\u0026#34;, { routes: [{ path: \u0026#34;/\u0026#34;, method: \u0026#34;GET\u0026#34;, eventHandler: async (event) =\u0026gt; { return { statusCode: 200, body: \u0026#34;Hello, world!\u0026#34;, }; }, }, { path: \u0026#34;encode\u0026#34;, method: \u0026#34;POST\u0026#34;, eventHandler: async (event) =\u0026gt; { console.log(\u0026#34;request: \u0026#34; + JSON.stringify(event)); let body: string let responseCode: number if (event.body != null) { if (event.isBase64Encoded) { body = event.body // API gateway will base64 encode for us responseCode = 200 } else { body = Buffer.from(event.body).toString(\u0026#39;base64\u0026#39;) responseCode = 200 } } else { body = \u0026#34;No data submitted\u0026#34; responseCode = 400 } return { statusCode: responseCode, body: body, } }, }], }) export const url = api.url; Deploy the changes:\npulumi up This will give you a preview and selecting yes will apply the changes:\nPreviewing update (dev) View Live: https://app.pulumi.com/jaxxstorm/api-gateway/dev/previews/657bac12-9b9e-4ca8-861e-a014b8e69f79 Type Name Plan Info pulumi:pulumi:Stack api-gateway-dev └─ aws:apigateway:x:API hello-world + ├─ aws:iam:Role hello-world02cbc3ee create + ├─ aws:iam:RolePolicyAttachment hello-world02cbc3ee-32be53a2 create + ├─ aws:lambda:Function hello-world02cbc3ee create ~ ├─ aws:apigateway:RestApi hello-world update [diff: ~body] +- ├─ aws:apigateway:Deployment hello-world replace [diff: ~variables] +- ├─ aws:lambda:Permission hello-world-fa520765 replace [diff: ~sourceArn] + ├─ aws:lambda:Permission hello-world-9451c357 create ~ └─ aws:apigateway:Stage hello-world update [diff: ~deployment] Outputs: ~ url: \u0026#34;https://14oplegt8g.execute-api.us-east-1.amazonaws.com/stage/\u0026#34; =\u0026gt; output\u0026lt;string\u0026gt; Resources: + 4 to create ~ 2 to update +-2 to replace 8 changes. 5 unchanged Step 2 — Send some data to the echo endpoint We can post some data to our base64 encoding service using cURL. First, let\u0026rsquo;s send a simple string:\ncurl -X POST $(pulumi stack output url)/encode -d foo The API gateway may take a few moments to provision the endpoint\nThis should return a small base64 encoded string:\nZm9v We can also send some JSON data:\ncurl -X POST $(pulumi stack output url)/encode -d \u0026#39;{\u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;}\u0026#39; Step 3 — View the function logs A nice feature of Pulumi when developing serverless applications is the ability to quickly view the logs from the function within the Pulumi application. Run pulumi logs from without your stack:\npulumi logs You\u0026rsquo;ll get the lambda function output:\n2020-12-01T22:15:00.668-08:00[ hello-world02cbc3ee-f622aef] START RequestId: 4d57a569-cb00-494f-8613-875d6038a979 Version: $LATEST 2020-12-01T22:15:00.670-08:00[ hello-world02cbc3ee-f622aef] 2020-12-02T06:15:00.670Z\t4d57a569-cb00-494f-8613-875d6038a979\tINFO\trequest: {\u0026#34;resource\u0026#34;:\u0026#34;/encode\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/encode\u0026#34;,\u0026#34;httpMethod\u0026#34;:\u0026#34;POST\u0026#34;,\u0026#34;headers\u0026#34;:{\u0026#34;Accept\u0026#34;:\u0026#34;*/*\u0026#34;,\u0026#34;CloudFront-Forwarded-Proto\u0026#34;:\u0026#34;https\u0026#34;,\u0026#34;CloudFront-Is-Desktop-Viewer\u0026#34;:\u0026#34;true\u0026#34;,\u0026#34;CloudFront-Is-Mobile-Viewer\u0026#34;:\u0026#34;false\u0026#34;,\u0026#34;CloudFront-Is-SmartTV-Viewer\u0026#34;:\u0026#34;false\u0026#34;,\u0026#34;CloudFront-Is-Tablet-Viewer\u0026#34;:\u0026#34;false\u0026#34;,\u0026#34;CloudFront-Viewer-Country\u0026#34;:\u0026#34;US\u0026#34;,\u0026#34;content-type\u0026#34;:\u0026#34;application/x-www-form-urlencoded\u0026#34;,\u0026#34;Host\u0026#34;:\u0026#34;8i41k0ifjd.execute-api.us-east-1.amazonaws.com\u0026#34;,\u0026#34;User-Agent\u0026#34;:\u0026#34;curl/7.64.1\u0026#34;,\u0026#34;Via\u0026#34;:\u0026#34;2.0 3dcf7c8001b07734617b28e9bacc90ad.cloudfront.net (CloudFront)\u0026#34;,\u0026#34;X-Amz-Cf-Id\u0026#34;:\u0026#34;Xmm43gQdDAsIGfQrrePMTkNfakJild8CwLi5Ueq0CArYFWwlqB42hw==\u0026#34;,\u0026#34;X-Amzn-Trace-Id\u0026#34;:\u0026#34;Root=1-5fc730e4-5a1e0d750d6f40c80527173e\u0026#34;,\u0026#34;X-Forwarded-For\u0026#34;:\u0026#34;24.56.241.187, 130.176.132.123\u0026#34;,\u0026#34;X-Forwarded-Port\u0026#34;:\u0026#34;443\u0026#34;,\u0026#34;X-Forwarded-Proto\u0026#34;:\u0026#34;https\u0026#34;},\u0026#34;multiValueHeaders\u0026#34;:{\u0026#34;Accept\u0026#34;:[\u0026#34;*/*\u0026#34;],\u0026#34;CloudFront-Forwarded-Proto\u0026#34;:[\u0026#34;https\u0026#34;],\u0026#34;CloudFront-Is-Desktop-Viewer\u0026#34;:[\u0026#34;true\u0026#34;],\u0026#34;CloudFront-Is-Mobile-Viewer\u0026#34;:[\u0026#34;false\u0026#34;],\u0026#34;CloudFront-Is-SmartTV-Viewer\u0026#34;:[\u0026#34;false\u0026#34;],\u0026#34;CloudFront-Is-Tablet-Viewer\u0026#34;:[\u0026#34;false\u0026#34;],\u0026#34;CloudFront-Viewer-Country\u0026#34;:[\u0026#34;US\u0026#34;],\u0026#34;content-type\u0026#34;:[\u0026#34;application/x-www-form-urlencoded\u0026#34;],\u0026#34;Host\u0026#34;:[\u0026#34;8i41k0ifjd.execute-api.us-east-1.amazonaws.com\u0026#34;],\u0026#34;User-Agent\u0026#34;:[\u0026#34;curl/7.64.1\u0026#34;],\u0026#34;Via\u0026#34;:[\u0026#34;2.0 3dcf7c8001b07734617b28e9bacc90ad.cloudfront.net (CloudFront)\u0026#34;],\u0026#34;X-Amz-Cf-Id\u0026#34;:[\u0026#34;Xmm43gQdDAsIGfQrrePMTkNfakJild8CwLi5Ueq0CArYFWwlqB42hw==\u0026#34;],\u0026#34;X-Amzn-Trace-Id\u0026#34;:[\u0026#34;Root=1-5fc730e4-5a1e0d750d6f40c80527173e\u0026#34;],\u0026#34;X-Forwarded-For\u0026#34;:[\u0026#34;24.56.241.187, 130.176.132.123\u0026#34;],\u0026#34;X-Forwarded-Port\u0026#34;:[\u0026#34;443\u0026#34;],\u0026#34;X-Forwarded-Proto\u0026#34;:[\u0026#34;https\u0026#34;]},\u0026#34;queryStringParameters\u0026#34;:null,\u0026#34;multiValueQueryStringParameters\u0026#34;:null,\u0026#34;pathParameters\u0026#34;:null,\u0026#34;stageVariables\u0026#34;:null,\u0026#34;requestContext\u0026#34;:{\u0026#34;resourceId\u0026#34;:\u0026#34;10gsf9\u0026#34;,\u0026#34;resourcePath\u0026#34;:\u0026#34;/encode\u0026#34;,\u0026#34;httpMethod\u0026#34;:\u0026#34;POST\u0026#34;,\u0026#34;extendedRequestId\u0026#34;:\u0026#34;W6STvFSJoAMFeYA=\u0026#34;,\u0026#34;requestTime\u0026#34;:\u0026#34;02/Dec/2020:06:15:00 +0000\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/stage//encode\u0026#34;,\u0026#34;accountId\u0026#34;:\u0026#34;616138583583\u0026#34;,\u0026#34;protocol\u0026#34;:\u0026#34;HTTP/1.1\u0026#34;,\u0026#34;stage\u0026#34;:\u0026#34;stage\u0026#34;,\u0026#34;domainPrefix\u0026#34;:\u0026#34;8i41k0ifjd\u0026#34;,\u0026#34;requestTimeEpoch\u0026#34;:1606889700655,\u0026#34;requestId\u0026#34;:\u0026#34;e62303e4-684b-4f96-a319-f143cdaa07aa\u0026#34;,\u0026#34;identity\u0026#34;:{\u0026#34;cognitoIdentityPoolId\u0026#34;:null,\u0026#34;accountId\u0026#34;:null,\u0026#34;cognitoIdentityId\u0026#34;:null,\u0026#34;caller\u0026#34;:null,\u0026#34;sourceIp\u0026#34;:\u0026#34;24.56.241.187\u0026#34;,\u0026#34;principalOrgId\u0026#34;:null,\u0026#34;accessKey\u0026#34;:null,\u0026#34;cognitoAuthenticationType\u0026#34;:null,\u0026#34;cognitoAuthenticationProvider\u0026#34;:null,\u0026#34;userArn\u0026#34;:null,\u0026#34;userAgent\u0026#34;:\u0026#34;curl/7.64.1\u0026#34;,\u0026#34;user\u0026#34;:null},\u0026#34;domainName\u0026#34;:\u0026#34;8i41k0ifjd.execute-api.us-east-1.amazonaws.com\u0026#34;,\u0026#34;apiId\u0026#34;:\u0026#34;8i41k0ifjd\u0026#34;},\u0026#34;body\u0026#34;:\u0026#34;eyJmb28iOiAiYmFyIn0=\u0026#34;,\u0026#34;isBase64Encoded\u0026#34;:true} 2020-12-01T22:15:00.671-08:00[ hello-world02cbc3ee-f622aef] END RequestId: 4d57a569-cb00-494f-8613-875d6038a979 2020-12-01T22:15:00.671-08:00[ hello-world02cbc3ee-f622aef] REPORT RequestId: 4d57a569-cb00-494f-8613-875d6038a979\tDuration: 1.24 ms\tBilled Duration: 2 ms\tMemory Size: 128 MB\tMax Memory Used: 66 MB This is being returned from the console.log statement in our function.\nStep 4 — Destroy Everything Finally, destroy the resources and the stack itself:\npulumi destroy pulumi stack rm "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/30_deploying_eks_cluster/30_testing_cluster_access.html",
	"title": "2.4 Testing Cluster Access",
	"tags": [],
	"description": "",
	"content": "Extract the kubeconfig from the stack output and point the KUBECONFIG environment variable at your cluster configuration file:\npulumi stack output kubeconfig \u0026gt; kubeconfig.json export KUBECONFIG=$PWD/kubeconfig.json To test out connectivity, run kubectl cluster-info. You should see information similar to this:\nKubernetes master is running at https://E7CD24CD6FADEBA48CA1DE87B4E6A260.gr7.us-west-2.eks.amazonaws.com CoreDNS is running at https://E7CD24CD6FADEBA48CA1DE87B4E6A260.gr7.us-west-2.eks.amazonaws.com/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy Check the nodes and pods:\nkubectl get nodes -o wide --show-labels kubectl get pods -A -o wide "
},
{
	"uri": "//localhost:1313/en/50_eks_platform/40_deploy_app/30_deploy_with_ploy.html",
	"title": "3.3 Deploy with Ploy",
	"tags": [],
	"description": "",
	"content": "Step 1 — Run Ploy We can now use ploy to deploy our application. First let\u0026rsquo;s make sure it\u0026rsquo;s in our $PATH:\nsudo mv ploy /usr/local/bin/ploy Then switch back to our platform-app directory:\ncd ~/environment/platform-app Now, run ploy up from within this directory and specify an organization to use - this should match the name you signed up to the Pulumi SaaS with:\nploy up -o jaxxstorm --verbose You should see some output from the command line application:\nINFO[0003] Creating application: yearly-choice-tadpole INFO[0003] Creating ECR repository INFO[0003] Creating local docker image INFO[0003] Creating Kubernetes namespace INFO[0003] Creating Kubernetes deployment INFO[0003] Creating Kubernetes service INFO[0004] Repository created: 886783038127.dkr.ecr.us-east-1.amazonaws.com/yearly-choice-tadpole-d9d3ae4 Pass the --verbose flag if you\u0026rsquo;d like to see what is happening with Pulumi behind the scenes.\nEventually, you\u0026rsquo;ll see your service has been deployed, like tos:\nINFO[0055] Your service is available at: a89a4e0e31b194a02bcf0207253ccd24-798957911.us-west-2.elb.amazonaws.com Step 2 — Examine our deployed app We can now look at our deployed application. Let\u0026rsquo;s use curl to do this:\ncurl a89a4e0e31b194a02bcf0207253ccd24-798957911.us-west-2.elb.amazonaws.com Hello, world! The application we created inside the Docker file was deployed via Pulumi, without having to write a single line of infrastructure code.\nStep 3 — Examine Pulumi console To examine the Pulumi program created from the automation API application, visit the Pulumi SaaS, replacing jaxxstorm with your org id:\nhttps://app.pulumi.com/jaxxstorm/ploy\nYou should see your created application visible in the console!\nStep 4 — Destroy everything Now we need to destroy our ploy application. Use the randomly generated name and run ploy destroy on it:\nploy -o jaxxstorm destroy firstly-discrete-panther Ploy will prompt you for confirmation:\nThis will delete the application yearly-choice-tadpole. Are you sure you wish to continue?: y INFO[0001] Deleting application: yearly-choice-tadpole Now, cd into your load balancer controller and destroy that Pulumi application:\ncd ~/environment/aws-load-balancer-controller/ pulumi destroy --yes Pulumi will delete all the resources from both your Kubernetes cluster, and the AWS account:\nPreviewing destroy (dev) View Live: https://app.pulumi.com/jaxxstorm/aws-load-balancer-controller/dev/previews/04df4af6-48be-4711-a550-8f51fd23161d Type Name Plan - pulumi:pulumi:Stack aws-load-balancer-controller-dev delete - ├─ pulumi:providers:kubernetes provider delete - │ └─ kubernetes:core/v1:Namespace aws-lb-controller-ns delete - │ └─ kubernetes:helm.sh/v3:Chart lb delete - │ ├─ kubernetes:apps/v1:Deployment aws-lb-controller/lb-aws-load-balancer-controller delete - │ ├─ kubernetes:admissionregistration.k8s.io/v1beta1:MutatingWebhookConfiguration aws-load-balancer-webhook delete - │ ├─ kubernetes:rbac.authorization.k8s.io/v1:ClusterRoleBinding lb-aws-load-balancer-controller-rolebinding delete - │ ├─ kubernetes:rbac.authorization.k8s.io/v1:RoleBinding aws-lb-controller/lb-aws-load-balancer-controller-leader-election-rolebinding delete - │ ├─ kubernetes:admissionregistration.k8s.io/v1beta1:ValidatingWebhookConfiguration aws-load-balancer-webhook delete - │ ├─ kubernetes:rbac.authorization.k8s.io/v1:ClusterRole lb-aws-load-balancer-controller-role delete - │ ├─ kubernetes:rbac.authorization.k8s.io/v1:Role aws-lb-controller/lb-aws-load-balancer-controller-leader-election-role delete - │ ├─ kubernetes:core/v1:Secret aws-lb-controller/aws-load-balancer-tls delete - │ ├─ kubernetes:core/v1:Service aws-lb-controller/aws-load-balancer-webhook-service delete - │ ├─ kubernetes:apiextensions.k8s.io/v1beta1:CustomResourceDefinition targetgroupbindings.elbv2.k8s.aws delete - │ └─ kubernetes:core/v1:ServiceAccount aws-lb-controller/aws-lb-controller-serviceaccount delete - └─ aws:iam:Role aws-loadbalancer-controller-role delete - ├─ aws:iam:PolicyAttachment aws-loadbalancer-controller-attachment delete - └─ aws:iam:Policy aws-loadbalancer-controller-policy delete Resources: - 18 to delete Destroying (dev) Finally, destroy your workshop EKS cluster:\ncd ~/environment/workshop-cluster/ pulumi destroy --yes Which will tear down the EKS cluster:\nPreviewing destroy (dev) View Live: https://app.pulumi.com/jaxxstorm/workshop-cluster/dev/previews/ffc2865e-f3c2-4d4c-bfcc-eb632a6d5263 Type Name Plan pulumi:pulumi:Stack workshop-cluster-dev - ├─ pulumi:providers:kubernetes lbriggs-workshop-provider delete - ├─ aws:cloudformation:Stack lbriggs-workshop-nodes delete - ├─ aws:ec2:LaunchConfiguration lbriggs-workshop-nodeLaunchConfiguration delete - ├─ aws:ec2:SecurityGroupRule lbriggs-workshop-eksExtApiServerClusterIngressRule delete - ├─ aws:ec2:SecurityGroupRule lbriggs-workshop-eksNodeIngressRule delete - ├─ aws:ec2:SecurityGroupRule lbriggs-workshop-eksNodeClusterIngressRule delete - ├─ aws:ec2:SecurityGroupRule lbriggs-workshop-eksNodeInternetEgressRule delete - ├─ kubernetes:core/v1:ConfigMap lbriggs-workshop-nodeAccess delete - ├─ aws:ec2:SecurityGroupRule lbriggs-workshop-eksClusterIngressRule delete - ├─ pulumi-nodejs:dynamic:Resource lbriggs-workshop-vpc-cni delete - │ ├─ awsx:x:ec2:Subnet vpc-lbriggs-workshop-public-0 delete - pulumi:pulumi:Stack workshop-cluster-dev delete - │ │ ├─ aws:ec2:Route vpc-lbriggs-workshop-public-0-ig delete - │ │ ├─ aws:ec2:Subnet vpc-lbriggs-workshop-public-0 delete ... "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/40_deploying_applications_to_eks/30_declare_application_deployment.html",
	"title": "3.4 Declare an Application Deployment Object",
	"tags": [],
	"description": "",
	"content": "You\u0026rsquo;ll now declare a deployment object, which deploys a specific set of containers to the cluster and scales them. In this case, you\u0026rsquo;ll deploy the pre-built gcr.io/google-samples/kubernetes-bootcamp:v1 container image with only a single replica.\nAppend this to your index.ts file:\nconst appLabels = { app: \u0026#34;eks-demo-apps\u0026#34; }; const deployment = new k8s.apps.v1.Deployment(\u0026#34;eks-demo-apps-dep\u0026#34;, { metadata: { namespace: ns.metadata.name }, spec: { selector: { matchLabels: appLabels }, replicas: 1, template: { metadata: { labels: appLabels }, spec: { containers: [{ name: \u0026#34;eks-demo-apps\u0026#34;, image: \u0026#34;gcr.io/google-samples/kubernetes-bootcamp:v1\u0026#34;, }], }, }, }, }, {provider}); The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; const pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); // Get the kubeconfig from the cluster stack output. const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;); // Create the k8s provider with the kubeconfig. const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, { kubeconfig }); const ns = new k8s.core.v1.Namespace(\u0026#34;app-ns\u0026#34;, { metadata: { name: \u0026#34;eks-demo-apps\u0026#34; }, }, {provider}); const appLabels = { app: \u0026#34;eks-demo-apps\u0026#34; }; const deployment = new k8s.apps.v1.Deployment(\u0026#34;eks-demo-apps-dep\u0026#34;, { metadata: { namespace: ns.metadata.name }, spec: { selector: { matchLabels: appLabels }, replicas: 1, template: { metadata: { labels: appLabels }, spec: { containers: [{ name: \u0026#34;eks-demo-apps\u0026#34;, image: \u0026#34;gcr.io/google-samples/kubernetes-bootcamp:v1\u0026#34;, }], }, }, }, }, { provider }); "
},
{
	"uri": "//localhost:1313/en/additional-content/110_deploying_containers_to_ecs/30_build_and_publish_custom_container.html",
	"title": "Build and Publish A Custom Container",
	"tags": [],
	"description": "",
	"content": "Add a few new files. First, create a site directory structure:\nmkdir -p app/site Then create a index.html file in app/site:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello, Pulumi!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Hello, containers!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Made with ❤️ with \u0026lt;a href=\u0026#34;https://pulumi.com\u0026#34;\u0026gt;Pulumi\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; And next, app/Dockerfile:\nFROM nginx COPY site /usr/share/nginx/html Now, you will change the image from \u0026quot;nginx\u0026quot; to a custom build of a local Dockerfile published to a private ECR registry. Add a build step right before the Fargate service definition:\nconst containerImage = awsx.ecs.Image.fromPath(\u0026#34;app-img\u0026#34;, \u0026#34;./app\u0026#34;); And replace the image name \u0026quot;nginx\u0026quot; with a reference to the resulting built image:\nimage: containerImage, Lastly, let\u0026rsquo;s update the desired count of our service:\ndesiredCount: 3, The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; const cluster = new awsx.ecs.Cluster(\u0026#34;cluster\u0026#34;); const alb = new awsx.elasticloadbalancingv2.ApplicationLoadBalancer( \u0026#34;app-lb\u0026#34;, { external: true, securityGroups: cluster.securityGroups }); const atg = alb.createTargetGroup( \u0026#34;app-tg\u0026#34;, { port: 80, deregistrationDelay: 0 }); const web = atg.createListener(\u0026#34;web\u0026#34;, { port: 80 }); const containerImage = awsx.ecs.Image.fromPath(\u0026#34;app-img\u0026#34;, \u0026#34;./app\u0026#34;); const appService = new awsx.ecs.FargateService(\u0026#34;app-svc\u0026#34;, { cluster, taskDefinitionArgs: { container: { image: containerImage, portMappings: [ web ], }, }, desiredCount: 3, }); export const url = pulumi.interpolate`${web.endpoint.hostname}`; To provision the ECS Cluster, run:\npulumi up After confirming, you will see output like the following:\nUpdating (dev): Type Name Status Info pulumi:pulumi:Stack ecs-workshop-dev ├─ awsx:x:ecs:FargateTaskDefinition app-svc + │ ├─ aws:ecr:Repository app-img created + │ ├─ aws:ecr:LifecyclePolicy app-img created +- │ └─ aws:ecs:TaskDefinition app-svc replaced [diff: ~containerDefinitions] ├─ aws:lb:ApplicationLoadBalancer app-lb │ └─ awsx:lb:ApplicationTargetGroup app-tg ~ │ └─ aws:lb:TargetGroup app-tg updated [diff: ~deregistrationDelay] └─ awsx:x:ecs:FargateService app-svc ~ └─ aws:ecs:Service app-svc updated [diff: ~taskDefinition] Outputs: url: \u0026#34;app-lb-fd7bd4b-538931589.us-west-2.elb.amazonaws.com\u0026#34; Resources: + 2 created ~ 2 updated +-1 replaced 5 changes. 31 unchanged Duration: 2m26s Permalink: https://app.pulumi.com/workshops/ecs-workshop/dev/updates/3 You can now curl the resulting endpoint:\ncurl $(pulumi stack output url) And you\u0026rsquo;ll see the application as follows:\n▶ curl $(pulumi stack output url) \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello, Pulumi!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Hello, containers!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Made with ❤️ with \u0026lt;a href=\u0026#34;https://pulumi.com\u0026#34;\u0026gt;Pulumi\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; "
},
{
	"uri": "//localhost:1313/en/additional-content/120_serverless_application_patterns/30_creating_lambda_based_apigateway.html",
	"title": "Creating an API Gateway",
	"tags": [],
	"description": "",
	"content": "Now create an API Gateway powered by Lambda for its sole REST API handler for GET requests at the / route.\nThe first step is to create the code for the Lambda itself — this is the code that will run in response to an API call at runtime. Place this code into a new handler/index.js file.\nCreate a new handler directory and create a new file index.js Paste the below code in the the javascript file:\nconst AWS = require(\u0026#34;aws-sdk\u0026#34;); exports.handler = async function(event, context, callback) { console.log(\u0026#34;Received event: \u0026#34;, event); const dc = new AWS.DynamoDB.DocumentClient(); const result = await dc.update({ TableName: process.env[\u0026#34;HITS_TABLE\u0026#34;], Key: { \u0026#34;Site\u0026#34;: \u0026#34;ACMECorp\u0026#34; }, UpdateExpression: \u0026#34;SET Hits = if_not_exists(Hits, :zero) + :incr\u0026#34;, ExpressionAttributeValues: { \u0026#34;:zero\u0026#34;: 0, \u0026#34;:incr\u0026#34;: 1 }, ReturnValues: \u0026#34;UPDATED_NEW\u0026#34;, }).promise(); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/html\u0026#34; }, body: \u0026#34;\u0026lt;h1\u0026gt;Welcome to ACMECorp!\u0026lt;/h1\u0026gt;\\n\u0026#34;+ `\u0026lt;p\u0026gt;${result.Attributes.Hits} hits.\u0026lt;/p\u0026gt;\\n`, }; }; Next, create the API Gateway and Lambda-based handler to index.ts:\nconst site = new awsx.apigateway.API(\u0026#34;site\u0026#34;, { routes: [{ path: \u0026#34;/\u0026#34;, method: \u0026#34;GET\u0026#34;, eventHandler: new aws.lambda.Function(\u0026#34;get-handler\u0026#34;, { runtime: aws.lambda.NodeJS10dXRuntime, code: new pulumi.asset.AssetArchive({ \u0026#34;.\u0026#34;: new pulumi.asset.FileArchive(\u0026#34;handler\u0026#34;), }), handler: \u0026#34;index.handler\u0026#34;, role: handlerRole.arn, environment: { variables: { \u0026#34;HITS_TABLE\u0026#34;: hits.name, }, }, }, { dependsOn: handlerPolicy }), }], }); export const url = site.url; The index.ts file should now have the following contents:\nimport * as AWS from \u0026#34;aws-sdk\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; import * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; const hits = new aws.dynamodb.Table(\u0026#34;hits\u0026#34;, { attributes: [{ name: \u0026#34;Site\u0026#34;, type: \u0026#34;S\u0026#34; }], hashKey: \u0026#34;Site\u0026#34;, billingMode: \u0026#34;PAY_PER_REQUEST\u0026#34;, }); const handlerRole = new aws.iam.Role(\u0026#34;handler-role\u0026#34;, { assumeRolePolicy: { Version: \u0026#34;2012-10-17\u0026#34;, Statement: [{ Action: \u0026#34;sts:AssumeRole\u0026#34;, Principal: { Service: \u0026#34;lambda.amazonaws.com\u0026#34; }, Effect: \u0026#34;Allow\u0026#34;, Sid: \u0026#34;\u0026#34;, }], }, }); const handlerPolicy = new aws.iam.RolePolicy(\u0026#34;handler-policy\u0026#34;, { role: handlerRole, policy: hits.arn.apply(arn =\u0026gt; JSON.stringify({ Version: \u0026#34;2012-10-17\u0026#34;, Statement: [ { Action: [ \u0026#34;dynamodb:UpdateItem\u0026#34;, \u0026#34;dynamodb:PutItem\u0026#34;, \u0026#34;dynamodb:GetItem\u0026#34;, \u0026#34;dynamodb:DescribeTable\u0026#34;, ], Resource: arn, Effect: \u0026#34;Allow\u0026#34;, }, { Action: [\u0026#34;logs:*\u0026#34;, \u0026#34;cloudwatch:*\u0026#34;], Resource: \u0026#34;*\u0026#34;, Effect: \u0026#34;Allow\u0026#34;, }, ], })), }); const site = new awsx.apigateway.API(\u0026#34;site\u0026#34;, { routes: [{ path: \u0026#34;/\u0026#34;, method: \u0026#34;GET\u0026#34;, eventHandler: new aws.lambda.Function(\u0026#34;get-handler\u0026#34;, { runtime: aws.lambda.NodeJS10dXRuntime, code: new pulumi.asset.AssetArchive({ \u0026#34;.\u0026#34;: new pulumi.asset.FileArchive(\u0026#34;handler\u0026#34;), }), handler: \u0026#34;index.handler\u0026#34;, role: handlerRole.arn, environment: { variables: { \u0026#34;HITS_TABLE\u0026#34;: hits.name, }, }, }, { dependsOn: handlerPolicy }), }], }); export const url = site.url; Notice this definition references the code stored in handler/index.js file through the use of an \u0026ldquo;asset\u0026rdquo; — a mechanism for packaging up files and directories for use by your infrastructure. At the end, your API\u0026rsquo;s base URL will be printed out.\n"
},
{
	"uri": "//localhost:1313/en/additional-content/160_gitops_for_socks_shop/30_declare_sock_shop_resource.html",
	"title": "Declare a Sock Shop Custom Resource",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s look up the namespace in which ArgoCD has been deployed by using the StackReference registered before:\nconst argoCDNamespace = argoStackRef.getOutput(\u0026#34;argoNamespace\u0026#34;); Now, let\u0026rsquo;s register an Argo Application in the Kubernetes API using a CustomResource:\nconst sockshop = new k8s.apiextensions.CustomResource( \u0026#34;sock-shop\u0026#34;, { apiVersion: \u0026#34;argoproj.io/v1alpha1\u0026#34;, kind: \u0026#34;Application\u0026#34;, metadata: { namespace: argoCDNamespace, // the ns where argocd is deployed name: name, // name of app in ArgoCd }, spec: { destination: { namespace: ns.metadata.name, server: \u0026#34;https://kubernetes.default.svc\u0026#34;, }, project: \u0026#34;default\u0026#34;, source: { path: \u0026#34;sock-shop\u0026#34;, repoURL: \u0026#34;https://github.com/argoproj/argocd-example-apps\u0026#34;, targetRevision: \u0026#34;HEAD\u0026#34;, }, syncPolicy: { automated: {} } } }, {provider: provider} ); The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; const pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); const argoStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;argoCDStackRef\u0026#34;)) // Get the kubeconfig from the cluster stack output. const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;); const argoCDNamespace = argoStackRef.getOutput(\u0026#34;argoNamespace\u0026#34;); // Create the k8s provider with the kubeconfig. const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, {kubeconfig}); // Declare a Namespace in which to deploy argocd const name = \u0026#34;sock-shop\u0026#34; const ns = new k8s.core.v1.Namespace(\u0026#34;sock-shop-ns\u0026#34;, { metadata: { name: name }, }, { provider }); const sockshop = new k8s.apiextensions.CustomResource( \u0026#34;sock-shop\u0026#34;, { apiVersion: \u0026#34;argoproj.io/v1alpha1\u0026#34;, kind: \u0026#34;Application\u0026#34;, metadata: { namespace: argoCDNamespace, // the ns where argocd is deployed name: name, // name of app in ArgoCd }, spec: { destination: { namespace: ns.metadata.name, server: \u0026#34;https://kubernetes.default.svc\u0026#34;, }, project: \u0026#34;default\u0026#34;, source: { path: \u0026#34;sock-shop\u0026#34;, repoURL: \u0026#34;https://github.com/argoproj/argocd-example-apps\u0026#34;, targetRevision: \u0026#34;HEAD\u0026#34;, }, syncPolicy: { automated: {} } } }, {provider: provider} ); "
},
{
	"uri": "//localhost:1313/en/additional-content/150_deploying_argocd_to_eks/30_declare_argocd_helm_chart.html",
	"title": "Declare an ArgoCD Helm Chart Object",
	"tags": [],
	"description": "",
	"content": "You\u0026rsquo;ll now declare a helm chart, which deploys all of the components that is required to deploy ArgoCD.\nNext, let\u0026rsquo;s declare the helm chart:\nconst argocd = new k8s.helm.v2.Chart(\u0026#34;argocd\u0026#34;, { namespace: ns.metadata.name, chart: \u0026#34;argo-cd\u0026#34;, fetchOpts: { repo: \u0026#34;https://argoproj.github.io/argo-helm\u0026#34; }, values: { installCRDs: false, server: { service: { type: \u0026#39;LoadBalancer\u0026#39;, }, } }, // The helm chart is using a deprecated apiVersion, // So let\u0026#39;s transform it transformations: [ (obj: any) =\u0026gt; { if (obj.apiVersion == \u0026#34;extensions/v1beta1\u0026#34;) { obj.apiVersion = \u0026#34;networking.k8s.io/v1beta1\u0026#34; } }, ], }, { providers: { kubernetes: provider }}, ); Lastly, we need to get the Url of our ArgoCD deployment:\nexport const url = argocd.getResourceProperty(\u0026#34;v1/Service\u0026#34;, `${name}/argocd-server`, \u0026#34;status\u0026#34;).apply(status =\u0026gt; status.loadBalancer.ingress[0].hostname) The ArgoCRD deployed by the Helm chart is outside of the management of Pulumi. However, Pulumi can still query the Helm chart resource to extract resource properties.\nThe index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; const pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); // Declare a Kubernetes Provider that can talk to our EKS Infrastructure const provider = new k8s.Provider(\u0026#34;k8s\u0026#34;, { kubeconfig: clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;) }); // Declare a Namespace in which to deploy argocd const name = \u0026#34;argocd\u0026#34; const ns = new k8s.core.v1.Namespace(\u0026#34;argocd-ns\u0026#34;, { metadata: { name: name }, }, { provider }); // Deploy the ArgoCD Helm Chart const argocd = new k8s.helm.v2.Chart(\u0026#34;argocd\u0026#34;, { namespace: ns.metadata.name, chart: \u0026#34;argo-cd\u0026#34;, fetchOpts: { repo: \u0026#34;https://argoproj.github.io/argo-helm\u0026#34; }, values: { installCRDs: false, server: { service: { type: \u0026#39;LoadBalancer\u0026#39;, }, } }, // The helm chart is using a deprecated apiVersion, // So let\u0026#39;s transform it transformations: [ (obj: any) =\u0026gt; { if (obj.apiVersion == \u0026#34;extensions/v1beta1\u0026#34;) { obj.apiVersion = \u0026#34;networking.k8s.io/v1beta1\u0026#34; } }, ], }, { providers: { kubernetes: provider }}, ); // Export the URL of our ArgoCD Webserver and the Namespace in which ArgoCD has been deployed export const argoNamespace = name; export const url = argocd.getResourceProperty(\u0026#34;v1/Service\u0026#34;, `${name}/argocd-server`, \u0026#34;status\u0026#34;).apply(status =\u0026gt; status.loadBalancer.ingress[0].hostname) "
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java.html",
	"title": "Intro to Modern IaC with AWS &amp; Pulumi (Java)",
	"tags": [],
	"description": "",
	"content": "Introduction to Modern Infrastructure as Code with AWS and Pulumi (Java) Learning Objectives Getting started with Pulumi Deploy a website on Amazon S3 Deploy load balanced Amazon EC2 Instances and an Application Load Balancer Deploy an application on Amazon ECS with Fargate In this workshop, we have selected containers and various other technologies to demonstrante the strength of IaC. At the end of the workshop you can continue to the additional content section, where you can find more labs to explore other components to work with such as serverless and EC2.\nThe examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various cloud services can be used to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments. "
},
{
	"uri": "//localhost:1313/en/additional-content/100_provision_ec2_virtual_machines/30_loadbalancing_the_vms.html",
	"title": "Loadbalancing the VMs",
	"tags": [],
	"description": "",
	"content": "Needing to loop over the webservers isn\u0026rsquo;t very realistic. You will now create a load balancer over them to distribute load evenly.\nNow install the AWSX package, a collection of helpers that makes things like configuring load balancing easier:\nnpm install @pulumi/awsx And import this package at the top of your program:\nimport * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; Delete the port 80 ingress rule from your security group, leaving behind only the ICMP rule:\nconst sg = new aws.ec2.SecurityGroup(\u0026#34;web-secgrp\u0026#34;, { ingress: [ { protocol: \u0026#34;icmp\u0026#34;, fromPort: 8, toPort: 0, cidrBlocks: [\u0026#34;0.0.0.0/0\u0026#34;] }, ], }); This is required to ensure the security group ingress rules don\u0026rsquo;t conflict with the load balancer\u0026rsquo;s.\nNow right after the security group creation, and before the VM creation block, add the load balancer creation:\nconst alb = new awsx.lb.ApplicationLoadBalancer(\u0026#34;web-traffic\u0026#34;, { external: true, securityGroups: [ sg.id ], }); const listener = alb.createListener(\u0026#34;web-listener\u0026#34;, { port: 80 }); And then replace the VM creation block with the following:\nexport const ips: any[] = []; export const hostnames: any[] = []; for (const az of aws.getAvailabilityZones().names) { const server = new aws.ec2.Instance(`web-server-${az}`, { instanceType: \u0026#34;t3.micro\u0026#34;, securityGroups: [ sg.name ], ami: ami, availabilityZone: az, userData: \u0026#34;#!/bin/bash\\n\u0026#34;+ `echo \u0026#39;Hello, World -- from ${az}!\u0026#39; \u0026gt; index.html\\n` + \u0026#34;nohup python -m SimpleHTTPServer 80 \u0026amp;\u0026#34;, tags: { \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34; }, }); ips.push(server.publicIp); hostnames.push(server.publicDns); alb.attachTarget(`web-target-${az}`, server); } export const url = listener.endpoint.hostname; The index.ts file should now have the following contents:\nimport * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; export = async () =\u0026gt; { const ami = aws.getAmi({ filters: [{ name: \u0026#34;name\u0026#34;, values: [\u0026#34;amzn-ami-hvm-*-x86_64-ebs\u0026#34;] }], owners: [ \u0026#34;137112412989\u0026#34; ], mostRecent: true, }).then(ami =\u0026gt; ami.id); const sg = new aws.ec2.SecurityGroup(\u0026#34;web-secgrp\u0026#34;, { ingress: [ { protocol: \u0026#34;icmp\u0026#34;, fromPort: 8, toPort: 0, cidrBlocks: [\u0026#34;0.0.0.0/0\u0026#34;] }, ], }); const alb = new awsx.lb.ApplicationLoadBalancer(\u0026#34;web-traffic\u0026#34;, { external: true, securityGroups: [ sg.id ], }); const listener = alb.createListener(\u0026#34;web-listener\u0026#34;, { port: 80 }); const ips: any[] = []; const hostnames: any[] = []; const azs = await aws.getAvailabilityZones() for (const az of azs.names) { const server = new aws.ec2.Instance(`web-server-${az}`, { instanceType: \u0026#34;t3.micro\u0026#34;, securityGroups: [ sg.name ], ami: ami, availabilityZone: az, userData: \u0026#34;#!/bin/bash\\n\u0026#34;+ `echo \u0026#39;Hello, World -- from ${az}!\u0026#39; \u0026gt; index.html\\n` + \u0026#34;nohup python -m SimpleHTTPServer 80 \u0026amp;\u0026#34;, tags: { \u0026#34;Name\u0026#34;: \u0026#34;web-server\u0026#34; }, }); ips.push(server.publicIp); hostnames.push(server.publicDns); alb.attachTarget(`web-target-${az}`, server); } return { url: listener.endpoint.hostname, }; } Deploy these updates:\npulumi up This should result in a fairly large update and, if all goes well, the load balancer\u0026rsquo;s resulting endpoint URL:\nUpdating (dev): Type Name Status Info pulumi:pulumi:Stack iac-workshop-dev ~ ├─ aws:ec2:SecurityGroup web-secgrp updated [diff: ~ingress] + ├─ awsx:x:ec2:Vpc default-vpc-eb926d81 created + │ ├─ awsx:x:ec2:Subnet default-vpc-eb926d81-public-0 created + │ └─ awsx:x:ec2:Subnet default-vpc-eb926d81-public-1 created + └─ aws:lb:ApplicationLoadBalancer web-traffic created + ├─ awsx:lb:ApplicationTargetGroup web-listener created + │ ├─ awsx:lb:TargetGroupAttachment web-target-us-west-2a created + │ │ └─ aws:lb:TargetGroupAttachment web-target-us-west-2a created + │ ├─ awsx:lb:TargetGroupAttachment web-target-us-west-2b created + │ │ └─ aws:lb:TargetGroupAttachment web-target-us-west-2b created + │ ├─ awsx:lb:TargetGroupAttachment web-target-us-west-2c created + │ │ └─ aws:lb:TargetGroupAttachment web-target-us-west-2c created + │ └─ aws:lb:TargetGroup web-listener created + ├─ awsx:x:ec2:SecurityGroup web-traffic-0 created + ├─ awsx:lb:ApplicationListener web-listener created + │ ├─ awsx:x:ec2:IngressSecurityGroupRule web-listener-external-0-ingress created + │ │ └─ aws:ec2:SecurityGroupRule web-listener-external-0-ingress created + │ ├─ awsx:x:ec2:EgressSecurityGroupRule web-listener-external-0-egress created + │ │ └─ aws:ec2:SecurityGroupRule web-listener-external-0-egress created + │ └─ aws:lb:Listener web-listener created + └─ aws:lb:LoadBalancer web-traffic created Outputs: hostnames: [ [0]: \u0026#34;ec2-18-197-184-46.us-west-2.compute.amazonaws.com\u0026#34; [1]: \u0026#34;ec2-18-196-225-191.us-west-2.compute.amazonaws.com\u0026#34; [2]: \u0026#34;ec2-35-158-83-62.us-west-2.compute.amazonaws.com\u0026#34; ] ips : [ [0]: \u0026#34;18.197.184.46\u0026#34; [1]: \u0026#34;18.196.225.191\u0026#34; [2]: \u0026#34;35.158.83.62\u0026#34; + url : \u0026#34;web-traffic-09348bc-723263075.us-west-2.elb.amazonaws.com\u0026#34; Resources: + 20 created ~ 1 updated 21 changes. 4 unchanged Duration: 2m33s Permalink: https://app.pulumi.com/workshops/iac-workshop/dev/updates/3 Now we can curl the load balancer:\nfor i in {0..10}; do curl $(pulumi stack output url); done Observe that the resulting text changes based on where the request is routed:\nHello, World -- from us-west-2b! Hello, World -- from us-west-2c! Hello, World -- from us-west-2a! Hello, World -- from us-west-2b! Hello, World -- from us-west-2b! Hello, World -- from us-west-2a! Hello, World -- from us-west-2c! Hello, World -- from us-west-2a! Hello, World -- from us-west-2c! Hello, World -- from us-west-2b! "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/30_deploying_eks_cluster.html",
	"title": "Module 02",
	"tags": [],
	"description": "",
	"content": "Deploying an Amazon EKS Cluster You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will deploy a Kubernetes cluster in EKS. The infrastructure created in this lab will be required for the next 3 labs.\n2.1 Creating a New Project 2.2 Creating an Amazon VPC 2.3 Creating an Amazon EKS Cluster 2.4 Testing Cluster Access "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/30_deploying_webservers.html",
	"title": "Module 02: EC2 Webserver",
	"tags": [],
	"description": "",
	"content": "Deploying EC2 Webservers with Pulumi You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will use Pulumi to create webservers across subnets and use an application loadbalancer to balance load between them.\n2.1 Creating a New Project 2.2 Provision an EC2 Instances 2.3 Add more EC2 Instances 2.4 Add a LoadBalancer "
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python/30_deploying_webservers.html",
	"title": "Module 02: EC2 Webserver",
	"tags": [],
	"description": "",
	"content": "Deploying EC2 Webservers with Pulumi You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will use Pulumi to create webservers across subnets and use an application loadbalancer to balance load between them.\n2.1 Creating a New Project 2.2 Provision an EC2 Instances 2.3 Add more EC2 Instances 2.4 Add a LoadBalancer "
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java/30_deploying_webservers.html",
	"title": "Module 02: EC2 Webserver",
	"tags": [],
	"description": "",
	"content": "Deploying EC2 Webservers with Pulumi You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will use Pulumi to create webservers across subnets and use an application loadbalancer to balance load between them.\n1.1 Creating a New Project 2.2 Provision an EC2 Instances 2.3 Add more EC2 Instances 2.4 Add a LoadBalancer "
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts/30_simple_api_gateway.html",
	"title": "Module 02: Lambda &amp; API Gateway",
	"tags": [],
	"description": "",
	"content": "Simple API Gateway You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will use Pulumi Crosswalk to create a simple lambda function behind an API Gateway\n2.1 Creating a New Project 2.2 Configuring AWS 2.3 API Gateway 2.4 Processing Input Data "
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts/40_container_thumbnailer.html",
	"title": "Module 03: Containers &amp; Microservices",
	"tags": [],
	"description": "",
	"content": "TypeScript Thumbnailer You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you\u0026rsquo;ll use Lambda Containers to process data inside Lambda functions. We\u0026rsquo;ll create a thumbnailer service using ffmpeg\n3.1 Creating a New Project 3.2 Configuring AWS 3.3 Thumbnailer Container 3.4 Define Lambda Container Function 3.5 Make a thumbnail website "
},
{
	"uri": "//localhost:1313/en/50_eks_platform/40_deploy_app.html",
	"title": "Module 03: Deploy an Application",
	"tags": [],
	"description": "",
	"content": "Deploy an Application You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you\u0026rsquo;ll deploy a simple Go application to your Kubernetes cluster. We\u0026rsquo;ll use a pre-built application that uses the Pulumi Automation API to deploy to our built Kubernetes cluster\n3.1 Create a Sample App 3.2 Build Platform Binary 3.3 Deploy with Ploy "
},
{
	"uri": "//localhost:1313/en/50_eks_platform/30_deploy_ingress_controller/20_deploy_ingress_ctrl.html",
	"title": "2.3 Deploy Ingress Controller",
	"tags": [],
	"description": "",
	"content": "We have an IAM role defined, we can deploy the AWS Load Balancer controller using the Helm Chart\nStep 1 — Create a Provider Before we create resources in our Kubernetes cluster, we need to provide a valid Kubernetes endpoint for Pulumi to talk to.\nUsually, we would use KUBECONFIG file for interacting with Kubernetes, but we can also explicitly set a provider on each Kubernetes resource.\nLet\u0026rsquo;s do this now. Define a provider resource in your index.ts. It gets populated from the kubeconfig output from the cluster.\nkubeconfig = cluster.get_output(\u0026#34;kubeconfig\u0026#34;) provider = k8s.Provider(\u0026#34;provider\u0026#34;, kubeconfig=kubeconfig) This provider can then be passed to all the resources we\u0026rsquo;re going to create with Pulumi.\nThe __main__.py file should now have the following contents:\n\u0026#34;\u0026#34;\u0026#34;An AWS Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws import json import pulumi_kubernetes as k8s stack = pulumi.get_stack() cluster = pulumi.StackReference(f\u0026#34;jaxxstorm/workshop-cluster/{stack}\u0026#34;) kubeconfig = cluster.get_output(\u0026#34;kubeconfig\u0026#34;) oidc_arn = cluster.get_output(\u0026#34;clusterOidcProviderArn\u0026#34;) oidc_url = cluster.get_output(\u0026#34;clusterOidcProvider\u0026#34;) ns = \u0026#34;aws-lb-controller\u0026#34; service_account_name = f\u0026#34;system:serviceaccount:{ns}:aws-lb-controller-serviceaccount\u0026#34; iam_role = aws.iam.Role( \u0026#34;aws-loadbalancer-controller-role\u0026#34;, assume_role_policy=pulumi.Output.all(oidc_arn, oidc_url).apply( lambda args: json.dumps( { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Federated\u0026#34;: args[0], }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: {f\u0026#34;{args[1]}:sub\u0026#34;: service_account_name}, }, } ], } ) ), ) with open(\u0026#34;files/iam_policy.json\u0026#34;) as policy_file: policy_doc = policy_file.read() iam_policy = aws.iam.Policy( \u0026#34;aws-loadbalancer-controller-policy\u0026#34;, policy=policy_doc, opts=pulumi.ResourceOptions(parent=iam_role), ) aws.iam.PolicyAttachment( \u0026#34;aws-loadbalancer-controller-attachment\u0026#34;, policy_arn=iam_policy.arn, roles=[iam_role.name], opts=pulumi.ResourceOptions(parent=iam_role), ) provider = k8s.Provider(\u0026#34;provider\u0026#34;, kubeconfig=kubeconfig) Step 2 — Create a Namespace Before we deploy the helm chart, we need to ensure we have a namespace in our Kubernetes cluster for it to be deployed to.\nEarlier we defined a constant called ns to ensure we got a consistent namespace name. Let\u0026rsquo;s use that to create our namespace:\nAdd the following to your __main__.py file:\nnamespace = k8s.core.v1.Namespace( f\u0026#34;{ns}-ns\u0026#34;, metadata={ \u0026#34;name\u0026#34;: ns, \u0026#34;labels\u0026#34;: { \u0026#34;app.kubernetes.io/name\u0026#34;: \u0026#34;aws-load-balancer-controller\u0026#34;, } }, opts=pulumi.ResourceOptions( provider=provider, parent=provider, ) ) The __main__.py file should now have the following contents:\n\u0026#34;\u0026#34;\u0026#34;An AWS Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws import json import pulumi_kubernetes as k8s stack = pulumi.get_stack() cluster = pulumi.StackReference(f\u0026#34;jaxxstorm/workshop-cluster/{stack}\u0026#34;) kubeconfig = cluster.get_output(\u0026#34;kubeconfig\u0026#34;) oidc_arn = cluster.get_output(\u0026#34;clusterOidcProviderArn\u0026#34;) oidc_url = cluster.get_output(\u0026#34;clusterOidcProvider\u0026#34;) ns = \u0026#34;aws-lb-controller\u0026#34; service_account_name = f\u0026#34;system:serviceaccount:{ns}:aws-lb-controller-serviceaccount\u0026#34; iam_role = aws.iam.Role( \u0026#34;aws-loadbalancer-controller-role\u0026#34;, assume_role_policy=pulumi.Output.all(oidc_arn, oidc_url).apply( lambda args: json.dumps( { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Federated\u0026#34;: args[0], }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: {f\u0026#34;{args[1]}:sub\u0026#34;: service_account_name}, }, } ], } ) ), ) with open(\u0026#34;files/iam_policy.json\u0026#34;) as policy_file: policy_doc = policy_file.read() iam_policy = aws.iam.Policy( \u0026#34;aws-loadbalancer-controller-policy\u0026#34;, policy=policy_doc, opts=pulumi.ResourceOptions(parent=iam_role), ) aws.iam.PolicyAttachment( \u0026#34;aws-loadbalancer-controller-attachment\u0026#34;, policy_arn=iam_policy.arn, roles=[iam_role.name], opts=pulumi.ResourceOptions(parent=iam_role), ) provider = k8s.Provider(\u0026#34;provider\u0026#34;, kubeconfig=kubeconfig) namespace = k8s.core.v1.Namespace( f\u0026#34;{ns}-ns\u0026#34;, metadata={ \u0026#34;name\u0026#34;: ns, \u0026#34;labels\u0026#34;: { \u0026#34;app.kubernetes.io/name\u0026#34;: \u0026#34;aws-load-balancer-controller\u0026#34;, } }, opts=pulumi.ResourceOptions( provider=provider, parent=provider, ) ) Step 3 — Create a Service Account We\u0026rsquo;ve defined a role that can be used by our running Kubernetes workload, we now need to pass it to a Kubernetes service account.\nWe can define a service account in our __main__.py like so:\nservice_account = k8s.core.v1.ServiceAccount( \u0026#34;aws-lb-controller-sa\u0026#34;, metadata={ \u0026#34;name\u0026#34;: \u0026#34;aws-lb-controller-serviceaccount\u0026#34;, \u0026#34;namespace\u0026#34;: namespace.metadata[\u0026#34;name\u0026#34;], \u0026#34;annotations\u0026#34;: { \u0026#34;eks.amazonaws.com/role-arn\u0026#34;: iam_role.arn.apply(lambda arn: arn) } } ) We have to use an apply here because the service account metadata takes a standard python string.\nThe __main__.py file should now have the following contents:\n\u0026#34;\u0026#34;\u0026#34;An AWS Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws import json import pulumi_kubernetes as k8s stack = pulumi.get_stack() cluster = pulumi.StackReference(f\u0026#34;jaxxstorm/workshop-cluster/{stack}\u0026#34;) kubeconfig = cluster.get_output(\u0026#34;kubeconfig\u0026#34;) oidc_arn = cluster.get_output(\u0026#34;clusterOidcProviderArn\u0026#34;) oidc_url = cluster.get_output(\u0026#34;clusterOidcProvider\u0026#34;) ns = \u0026#34;aws-lb-controller\u0026#34; service_account_name = f\u0026#34;system:serviceaccount:{ns}:aws-lb-controller-serviceaccount\u0026#34; iam_role = aws.iam.Role( \u0026#34;aws-loadbalancer-controller-role\u0026#34;, assume_role_policy=pulumi.Output.all(oidc_arn, oidc_url).apply( lambda args: json.dumps( { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Federated\u0026#34;: args[0], }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: {f\u0026#34;{args[1]}:sub\u0026#34;: service_account_name}, }, } ], } ) ), ) with open(\u0026#34;files/iam_policy.json\u0026#34;) as policy_file: policy_doc = policy_file.read() iam_policy = aws.iam.Policy( \u0026#34;aws-loadbalancer-controller-policy\u0026#34;, policy=policy_doc, opts=pulumi.ResourceOptions(parent=iam_role), ) aws.iam.PolicyAttachment( \u0026#34;aws-loadbalancer-controller-attachment\u0026#34;, policy_arn=iam_policy.arn, roles=[iam_role.name], opts=pulumi.ResourceOptions(parent=iam_role), ) provider = k8s.Provider(\u0026#34;provider\u0026#34;, kubeconfig=kubeconfig) namespace = k8s.core.v1.Namespace( f\u0026#34;{ns}-ns\u0026#34;, metadata={ \u0026#34;name\u0026#34;: ns, \u0026#34;labels\u0026#34;: { \u0026#34;app.kubernetes.io/name\u0026#34;: \u0026#34;aws-load-balancer-controller\u0026#34;, } }, opts=pulumi.ResourceOptions( provider=provider, parent=provider, ) ) service_account = k8s.core.v1.ServiceAccount( \u0026#34;aws-lb-controller-sa\u0026#34;, metadata={ \u0026#34;name\u0026#34;: \u0026#34;aws-lb-controller-serviceaccount\u0026#34;, \u0026#34;namespace\u0026#34;: namespace.metadata[\u0026#34;name\u0026#34;], \u0026#34;annotations\u0026#34;: { \u0026#34;eks.amazonaws.com/role-arn\u0026#34;: iam_role.arn.apply(lambda arn: arn) } } ) Step 4 — Retrieve needed outputs The next thing we need to do is retrieve some values from our cluster stack so that we can pass them to our helm chart. The AWS Load Balancer Controller first needs to know which cluster to target when it starts.\nWe can retrieve the cluster name from the other stack - add the following to your __main__.py file near the top, where you retrieved the other outputs:\ncluster_name = cluster.get_output(\u0026#34;clusterName\u0026#34;) vpc_id = cluster.get_output(\u0026#34;vpcId\u0026#34;) The __main__.py file should now have the following contents:\n\u0026#34;\u0026#34;\u0026#34;An AWS Python Pulumi program\u0026#34;\u0026#34;\u0026#34; import pulumi import pulumi_aws as aws import json import pulumi_kubernetes as k8s stack = pulumi.get_stack() cluster = pulumi.StackReference(f\u0026#34;jaxxstorm/workshop-cluster/{stack}\u0026#34;) kubeconfig = cluster.get_output(\u0026#34;kubeconfig\u0026#34;) oidc_arn = cluster.get_output(\u0026#34;clusterOidcProviderArn\u0026#34;) oidc_url = cluster.get_output(\u0026#34;clusterOidcProvider\u0026#34;) cluster_name = cluster.get_output(\u0026#34;clusterName\u0026#34;) vpc_id = cluster.get_output(\u0026#34;vpcId\u0026#34;) ns = \u0026#34;aws-lb-controller\u0026#34; service_account_name = f\u0026#34;system:serviceaccount:{ns}:aws-lb-controller-serviceaccount\u0026#34; iam_role = aws.iam.Role( \u0026#34;aws-loadbalancer-controller-role\u0026#34;, assume_role_policy=pulumi.Output.all(oidc_arn, oidc_url).apply( lambda args: json.dumps( { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Federated\u0026#34;: args[0], }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: {f\u0026#34;{args[1]}:sub\u0026#34;: service_account_name}, }, } ], } ) ), ) with open(\u0026#34;files/iam_policy.json\u0026#34;) as policy_file: policy_doc = policy_file.read() iam_policy = aws.iam.Policy( \u0026#34;aws-loadbalancer-controller-policy\u0026#34;, policy=policy_doc, opts=pulumi.ResourceOptions(parent=iam_role), ) aws.iam.PolicyAttachment( \u0026#34;aws-loadbalancer-controller-attachment\u0026#34;, policy_arn=iam_policy.arn, roles=[iam_role.name], opts=pulumi.ResourceOptions(parent=iam_role), ) provider = k8s.Provider(\u0026#34;provider\u0026#34;, kubeconfig=kubeconfig) namespace = k8s.core.v1.Namespace( f\u0026#34;{ns}-ns\u0026#34;, metadata={ \u0026#34;name\u0026#34;: ns, \u0026#34;labels\u0026#34;: { \u0026#34;app.kubernetes.io/name\u0026#34;: \u0026#34;aws-load-balancer-controller\u0026#34;, } }, opts=pulumi.ResourceOptions( provider=provider, parent=provider, ) ) service_account = k8s.core.v1.ServiceAccount( \u0026#34;aws-lb-controller-sa\u0026#34;, metadata={ \u0026#34;name\u0026#34;: \u0026#34;aws-lb-controller-serviceaccount\u0026#34;, \u0026#34;namespace\u0026#34;: namespace.metadata[\u0026#34;name\u0026#34;], \u0026#34;annotations\u0026#34;: { \u0026#34;eks.amazonaws.com/role-arn\u0026#34;: iam_role.arn.apply(lambda arn: arn) } } ) Step 5 — Define your Helm Chart Now that we\u0026rsquo;ve got all our dependencies from other stacks, we can deploy our Helm Chart. We\u0026rsquo;ll pass the retrieved values from the cluster stack to it.\nIn your __main__.py file, add the following:\nk8s.helm.v3.Chart( \u0026#34;lb\u0026#34;, k8s.helm.v3.ChartOpts( chart=\u0026#34;aws-load-balancer-controller\u0026#34;, fetch_opts=k8s.helm.v3.FetchOpts( repo=\u0026#34;https://aws.github.io/eks-charts\u0026#34; ), namespace=namespace.metadata[\u0026#34;name\u0026#34;], values={ \u0026#34;region\u0026#34;: \u0026#34;us-west-1\u0026#34;, \u0026#34;serviceAccount\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;aws-lb-controller-serviceaccount\u0026#34;, \u0026#34;create\u0026#34;: False, }, \u0026#34;vpcId\u0026#34;: vpc_id, \u0026#34;clusterName\u0026#34;: cluster_name, \u0026#34;podLabels\u0026#34;: { \u0026#34;stack\u0026#34;: stack, \u0026#34;app\u0026#34;: \u0026#34;aws-lb-controller\u0026#34; } } ), pulumi.ResourceOptions( provider=provider, parent=namespace ) ) The __main__.py file should now have the following contents:\nimport pulumi import pulumi_aws as aws import json import pulumi_kubernetes as k8s stack = pulumi.get_stack() cluster = pulumi.StackReference(f\u0026#34;jaxxstorm/workshop-cluster/{stack}\u0026#34;) kubeconfig = cluster.get_output(\u0026#34;kubeconfig\u0026#34;) oidc_arn = cluster.get_output(\u0026#34;clusterOidcProviderArn\u0026#34;) oidc_url = cluster.get_output(\u0026#34;clusterOidcProvider\u0026#34;) cluster_name = cluster.get_output(\u0026#34;clusterName\u0026#34;) vpc_id = cluster.get_output(\u0026#34;vpcId\u0026#34;) ns = \u0026#34;aws-lb-controller\u0026#34; service_account_name = f\u0026#34;system:serviceaccount:{ns}:aws-lb-controller-serviceaccount\u0026#34; iam_role = aws.iam.Role( \u0026#34;aws-loadbalancer-controller-role\u0026#34;, assume_role_policy=pulumi.Output.all(oidc_arn, oidc_url).apply( lambda args: json.dumps( { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Federated\u0026#34;: args[0], }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: {f\u0026#34;{args[1]}:sub\u0026#34;: service_account_name}, }, } ], } ) ), ) with open(\u0026#34;files/iam_policy.json\u0026#34;) as policy_file: policy_doc = policy_file.read() iam_policy = aws.iam.Policy( \u0026#34;aws-loadbalancer-controller-policy\u0026#34;, policy=policy_doc, opts=pulumi.ResourceOptions(parent=iam_role), ) aws.iam.PolicyAttachment( \u0026#34;aws-loadbalancer-controller-attachment\u0026#34;, policy_arn=iam_policy.arn, roles=[iam_role.name], opts=pulumi.ResourceOptions(parent=iam_role), ) provider = k8s.Provider(\u0026#34;provider\u0026#34;, kubeconfig=kubeconfig) namespace = k8s.core.v1.Namespace( f\u0026#34;{ns}-ns\u0026#34;, metadata={ \u0026#34;name\u0026#34;: ns, \u0026#34;labels\u0026#34;: { \u0026#34;app.kubernetes.io/name\u0026#34;: \u0026#34;aws-load-balancer-controller\u0026#34;, } }, opts=pulumi.ResourceOptions( provider=provider, parent=provider, ) ) service_account = k8s.core.v1.ServiceAccount( \u0026#34;aws-lb-controller-sa\u0026#34;, metadata={ \u0026#34;name\u0026#34;: \u0026#34;aws-lb-controller-serviceaccount\u0026#34;, \u0026#34;namespace\u0026#34;: namespace.metadata[\u0026#34;name\u0026#34;], \u0026#34;annotations\u0026#34;: { \u0026#34;eks.amazonaws.com/role-arn\u0026#34;: iam_role.arn.apply(lambda arn: arn) } } ) k8s.helm.v3.Chart( \u0026#34;lb\u0026#34;, k8s.helm.v3.ChartOpts( chart=\u0026#34;aws-load-balancer-controller\u0026#34;, fetch_opts=k8s.helm.v3.FetchOpts( repo=\u0026#34;https://aws.github.io/eks-charts\u0026#34; ), namespace=namespace.metadata[\u0026#34;name\u0026#34;], values={ \u0026#34;region\u0026#34;: \u0026#34;us-west-1\u0026#34;, \u0026#34;serviceAccount\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;aws-lb-controller-serviceaccount\u0026#34;, \u0026#34;create\u0026#34;: False, }, \u0026#34;vpcId\u0026#34;: vpc_id, \u0026#34;clusterName\u0026#34;: cluster_name, \u0026#34;podLabels\u0026#34;: { \u0026#34;stack\u0026#34;: stack, \u0026#34;app\u0026#34;: \u0026#34;aws-lb-controller\u0026#34; } } ), pulumi.ResourceOptions( provider=provider, parent=namespace ) ) Step 6 — Patch the Helm Chart Pulumi\u0026rsquo;s Kubernetes provider can manipulate values in Helm charts using transformations.\nThe Helm chart we\u0026rsquo;re installing has a field which causes issues when installing, so we\u0026rsquo;re going to remove it from the chart.\nAdd a function to your __main__.py which will remove the broken fields:\ndef remove_status(obj, opts): if obj[\u0026#34;kind\u0026#34;] == \u0026#34;CustomResourceDefinition\u0026#34;: del obj[\u0026#34;status\u0026#34;] Then update your helm chart to include the transformation:\nk8s.helm.v3.Chart( \u0026#34;lb\u0026#34;, k8s.helm.v3.ChartOpts( chart=\u0026#34;aws-load-balancer-controller\u0026#34;, fetch_opts=k8s.helm.v3.FetchOpts( repo=\u0026#34;https://aws.github.io/eks-charts\u0026#34; ), namespace=namespace.metadata[\u0026#34;name\u0026#34;], values={ \u0026#34;region\u0026#34;: \u0026#34;us-west-1\u0026#34;, \u0026#34;serviceAccount\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;aws-lb-controller-serviceaccount\u0026#34;, \u0026#34;create\u0026#34;: False, }, \u0026#34;vpcId\u0026#34;: vpc_id, \u0026#34;clusterName\u0026#34;: cluster_name, \u0026#34;podLabels\u0026#34;: { \u0026#34;stack\u0026#34;: stack, \u0026#34;app\u0026#34;: \u0026#34;aws-lb-controller\u0026#34; } }, transformations=[remove_status] ), pulumi.ResourceOptions( provider=provider, parent=namespace ) ) The __main__.py file should now have the following contents:\nimport pulumi import pulumi_aws as aws import json import pulumi_kubernetes as k8s stack = pulumi.get_stack() cluster = pulumi.StackReference(f\u0026#34;jaxxstorm/workshop-cluster/{stack}\u0026#34;) kubeconfig = cluster.get_output(\u0026#34;kubeconfig\u0026#34;) oidc_arn = cluster.get_output(\u0026#34;clusterOidcProviderArn\u0026#34;) oidc_url = cluster.get_output(\u0026#34;clusterOidcProvider\u0026#34;) cluster_name = cluster.get_output(\u0026#34;clusterName\u0026#34;) vpc_id = cluster.get_output(\u0026#34;vpcId\u0026#34;) ns = \u0026#34;aws-lb-controller\u0026#34; service_account_name = f\u0026#34;system:serviceaccount:{ns}:aws-lb-controller-serviceaccount\u0026#34; iam_role = aws.iam.Role( \u0026#34;aws-loadbalancer-controller-role\u0026#34;, assume_role_policy=pulumi.Output.all(oidc_arn, oidc_url).apply( lambda args: json.dumps( { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Federated\u0026#34;: args[0], }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: {f\u0026#34;{args[1]}:sub\u0026#34;: service_account_name}, }, } ], } ) ), ) with open(\u0026#34;files/iam_policy.json\u0026#34;) as policy_file: policy_doc = policy_file.read() iam_policy = aws.iam.Policy( \u0026#34;aws-loadbalancer-controller-policy\u0026#34;, policy=policy_doc, opts=pulumi.ResourceOptions(parent=iam_role), ) aws.iam.PolicyAttachment( \u0026#34;aws-loadbalancer-controller-attachment\u0026#34;, policy_arn=iam_policy.arn, roles=[iam_role.name], opts=pulumi.ResourceOptions(parent=iam_role), ) provider = k8s.Provider(\u0026#34;provider\u0026#34;, kubeconfig=kubeconfig) namespace = k8s.core.v1.Namespace( f\u0026#34;{ns}-ns\u0026#34;, metadata={ \u0026#34;name\u0026#34;: ns, \u0026#34;labels\u0026#34;: { \u0026#34;app.kubernetes.io/name\u0026#34;: \u0026#34;aws-load-balancer-controller\u0026#34;, } }, opts=pulumi.ResourceOptions( provider=provider, parent=provider, ) ) service_account = k8s.core.v1.ServiceAccount( \u0026#34;aws-lb-controller-sa\u0026#34;, metadata={ \u0026#34;name\u0026#34;: \u0026#34;aws-lb-controller-serviceaccount\u0026#34;, \u0026#34;namespace\u0026#34;: namespace.metadata[\u0026#34;name\u0026#34;], \u0026#34;annotations\u0026#34;: { \u0026#34;eks.amazonaws.com/role-arn\u0026#34;: iam_role.arn.apply(lambda arn: arn) } } ) def remove_status(obj, opts): if obj[\u0026#34;kind\u0026#34;] == \u0026#34;CustomResourceDefinition\u0026#34;: del obj[\u0026#34;status\u0026#34;] k8s.helm.v3.Chart( \u0026#34;lb\u0026#34;, k8s.helm.v3.ChartOpts( chart=\u0026#34;aws-load-balancer-controller\u0026#34;, fetch_opts=k8s.helm.v3.FetchOpts( repo=\u0026#34;https://aws.github.io/eks-charts\u0026#34; ), namespace=namespace.metadata[\u0026#34;name\u0026#34;], values={ \u0026#34;region\u0026#34;: \u0026#34;us-west-2\u0026#34;, \u0026#34;serviceAccount\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;aws-lb-controller-serviceaccount\u0026#34; }, \u0026#34;vpcId\u0026#34;: vpc_id, \u0026#34;clusterName\u0026#34;: cluster_name, \u0026#34;podLabels\u0026#34;: { \u0026#34;stack\u0026#34;: stack, \u0026#34;app\u0026#34;: \u0026#34;aws-lb-controller\u0026#34; } }, transformations=[remove_status] ), pulumi.ResourceOptions( provider=provider, parent=namespace ) ) Step 7 — Provision your Infrastructure We\u0026rsquo;re now ready to deploy our loadbalancer. Run pulumi up:\npulumi up and validate the changes:\npulumi up Previewing update (dev) View Live: https://app.pulumi.com/jaxxstorm/aws-load-balancer-controller/dev/previews/b4c0a60e-938a-4e06-8838-e974f9ea46b3 Type Name Plan + pulumi:pulumi:Stack aws-load-balancer-controller-dev create + ├─ kubernetes:helm.sh/v3:Chart lb-chart create + │ ├─ kubernetes:rbac.authorization.k8s.io/v1:ClusterRoleBinding lb-chart-aws-load-balancer-controller-rolebinding create + │ ├─ kubernetes:core/v1:Service aws-lb-controller/aws-load-balancer-webhook-service create + │ ├─ kubernetes:admissionregistration.k8s.io/v1beta1:ValidatingWebhookConfiguration aws-load-balancer-webhook create + │ ├─ kubernetes:core/v1:ServiceAccount aws-lb-controller/aws-lb-controller-serviceaccount create + │ ├─ kubernetes:core/v1:Secret aws-lb-controller/aws-load-balancer-tls create + │ ├─ kubernetes:rbac.authorization.k8s.io/v1:RoleBinding aws-lb-controller/lb-chart-aws-load-balancer-controller-leader-election-rolebinding create + │ ├─ kubernetes:rbac.authorization.k8s.io/v1:Role aws-lb-controller/lb-chart-aws-load-balancer-controller-leader-election-role create + │ ├─ kubernetes:rbac.authorization.k8s.io/v1:ClusterRole lb-chart-aws-load-balancer-controller-role create + │ ├─ kubernetes:admissionregistration.k8s.io/v1beta1:MutatingWebhookConfiguration aws-load-balancer-webhook create + │ ├─ kubernetes:apps/v1:Deployment aws-lb-controller/lb-chart-aws-load-balancer-controller create + │ └─ kubernetes:apiextensions.k8s.io/v1beta1:CustomResourceDefinition targetgroupbindings.elbv2.k8s.aws create + ├─ pulumi:providers:kubernetes provider create + ├─ aws:iam:Role aws-loadbalancer-controller-role create + │ ├─ aws:iam:Policy aws-loadbalancer-controller-policy create + │ └─ aws:iam:PolicyAttachment aws-loadbalancer-controller-policy-attachment create + └─ kubernetes:core/v1:Namespace aws-lb-controller-ns create Resources: + 18 to create Do you want to perform this update? [Use arrows to move, enter to select, type to filter] yes \u0026gt; no details Step 8 — Validate the changes We can now verify our AWS Load Balancer Controller started correctly. Let\u0026rsquo;s check the logs of the pod.\nWe\u0026rsquo;ll use kubectl to gather the logs and target the running pod using the labels we specified.\nRun the following command to retrieve the pod logs:\nkubectl logs -n aws-lb-controller -l app=aws-lb-controller -l stack=dev You should see some output from the running pod, like so:\n{\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1607475108.9502738,\u0026#34;logger\u0026#34;:\u0026#34;controller-runtime.certwatcher\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Starting certificate watcher\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1607475108.9502833,\u0026#34;logger\u0026#34;:\u0026#34;controller\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Starting EventSource\u0026#34;,\u0026#34;controller\u0026#34;:\u0026#34;ingress\u0026#34;,\u0026#34;source\u0026#34;:\u0026#34;kind source: /, Kind=\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1607475108.9503238,\u0026#34;logger\u0026#34;:\u0026#34;controller\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Starting EventSource\u0026#34;,\u0026#34;controller\u0026#34;:\u0026#34;service\u0026#34;,\u0026#34;source\u0026#34;:\u0026#34;kind source: /, Kind=\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1607475108.9503775,\u0026#34;logger\u0026#34;:\u0026#34;controller\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Starting Controller\u0026#34;,\u0026#34;controller\u0026#34;:\u0026#34;service\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1607475109.0503407,\u0026#34;logger\u0026#34;:\u0026#34;controller\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Starting EventSource\u0026#34;,\u0026#34;reconcilerGroup\u0026#34;:\u0026#34;elbv2.k8s.aws\u0026#34;,\u0026#34;reconcilerKind\u0026#34;:\u0026#34;TargetGroupBinding\u0026#34;,\u0026#34;controller\u0026#34;:\u0026#34;targetGroupBinding\u0026#34;,\u0026#34;source\u0026#34;:\u0026#34;kind source: /, Kind=\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1607475109.0504348,\u0026#34;logger\u0026#34;:\u0026#34;controller\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Starting workers\u0026#34;,\u0026#34;controller\u0026#34;:\u0026#34;service\u0026#34;,\u0026#34;worker count\u0026#34;:3} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1607475109.0504942,\u0026#34;logger\u0026#34;:\u0026#34;controller\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Starting Controller\u0026#34;,\u0026#34;controller\u0026#34;:\u0026#34;ingress\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1607475109.150941,\u0026#34;logger\u0026#34;:\u0026#34;controller\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Starting Controller\u0026#34;,\u0026#34;reconcilerGroup\u0026#34;:\u0026#34;elbv2.k8s.aws\u0026#34;,\u0026#34;reconcilerKind\u0026#34;:\u0026#34;TargetGroupBinding\u0026#34;,\u0026#34;controller\u0026#34;:\u0026#34;targetGroupBinding\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1607475109.1510022,\u0026#34;logger\u0026#34;:\u0026#34;controller\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Starting workers\u0026#34;,\u0026#34;reconcilerGroup\u0026#34;:\u0026#34;elbv2.k8s.aws\u0026#34;,\u0026#34;reconcilerKind\u0026#34;:\u0026#34;TargetGroupBinding\u0026#34;,\u0026#34;controller\u0026#34;:\u0026#34;targetGroupBinding\u0026#34;,\u0026#34;worker count\u0026#34;:3} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1607475109.1510797,\u0026#34;logger\u0026#34;:\u0026#34;controller\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Starting workers\u0026#34;,\u0026#34;controller\u0026#34;:\u0026#34;ingress\u0026#34;,\u0026#34;worker count\u0026#34;:3} We\u0026rsquo;re now ready to deploy an application to our cluster.\n"
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/40_deploying_applications_to_eks/40_declare_application_service_object.html",
	"title": "3.5 Declare an Application Service Object",
	"tags": [],
	"description": "",
	"content": "Next, you\u0026rsquo;ll declare a service object, which enables networking and load balancing across your deployment replicas.\nAppend this to your index.ts file:\nconst service = new k8s.core.v1.Service(\u0026#34;app-svc\u0026#34;, { metadata: { namespace: ns.metadata.name }, spec: { selector: appLabels, ports: [{ port: 80, targetPort: 8080 }], type: \u0026#34;LoadBalancer\u0026#34;, }, }, { provider }); Afterwards, add these lines to export the resulting, dynamically assigned endpoint for the resulting load balancer:\nconst address = service.status.loadBalancer.ingress[0].hostname; const port = service.spec.ports[0].port; export const url = pulumi.interpolate`http://${address}:${port}`; The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; const pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); // Get the kubeconfig from the cluster stack output. const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;).apply(JSON.stringify); // Create the k8s provider with the kubeconfig. const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, {kubeconfig}); const ns = new k8s.core.v1.Namespace(\u0026#34;app-ns\u0026#34;, { metadata: { name: \u0026#34;eks-demo-apps\u0026#34; }, }, { provider }); const appLabels = { app: \u0026#34;eks-demo-apps\u0026#34; }; const deployment = new k8s.apps.v1.Deployment(\u0026#34;app-dep\u0026#34;, { metadata: { namespace: ns.metadata.name }, spec: { selector: { matchLabels: appLabels }, replicas: 1, template: { metadata: { labels: appLabels }, spec: { containers: [{ name: \u0026#34;eks-demo-apps\u0026#34;, image: \u0026#34;gcr.io/google-samples/kubernetes-bootcamp:v1\u0026#34;, }], }, }, }, }, {provider}); const service = new k8s.core.v1.Service(\u0026#34;app-svc\u0026#34;, { metadata: { namespace: ns.metadata.name }, spec: { selector: appLabels, ports: [{ port: 80, targetPort: 8080 }], type: \u0026#34;LoadBalancer\u0026#34;, }, }, { provider }); const address = service.status.loadBalancer.ingress[0].hostname; const port = service.spec.ports[0].port; export const url = pulumi.interpolate`http://${address}:${port}`; "
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts.html",
	"title": "Deploying Microservices with Pulumi &amp; AWS Lambda (TypeScript)",
	"tags": [],
	"description": "",
	"content": "Deploying Microservices with Pulumi \u0026amp; AWS Lambda (TypeScript) Welcome Learning Objectives Getting started with Pulumi Provision a very simple Lambda function Use Pulumi Crosswalk for AWS to reduce the amount of code to deploy Lambda functions Use AWS Lambda Containers to build a microservice In this workshop, we have selected lambda and serverless technologies to demonstrate the strength of IaC At the end of the workshop you can continue to the additional content section, where you can find more labs to explore other components to work with such as serverless and EC2.\nThe examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various cloud services can be used to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments. "
},
{
	"uri": "//localhost:1313/en/additional-content/150_deploying_argocd_to_eks/40_deploy_our_application.html",
	"title": "Deploying our Application Stack",
	"tags": [],
	"description": "",
	"content": "First, add the StackReference to the cluster stack, which is used to get the kubeconfig from its stack output. This is a reference to the project created in the previous lab.\npulumi config set clusterStackRef workshops/eks-infrastructure/dev Now we can deploy Everything:\npulumi up This will show you a preview and, after selecting yes, the application will be deployed:\nUpdating (dev): Type Name Status Info + pulumi:pulumi:Stack argocd-dev created + ├─ kubernetes:helm.sh:Chart argocd created + │ ├─ kubernetes:core:ServiceAccount argocd/argocd-server created + │ ├─ kubernetes:core:ConfigMap argocd/argocd-rbac-cm created + │ ├─ kubernetes:core:ServiceAccount argocd/argocd-dex-server created + │ ├─ kubernetes:core:Service argocd/argocd-redis created + │ ├─ kubernetes:core:ConfigMap argocd/argocd-tls-certs-cm created + │ ├─ kubernetes:core:ConfigMap argocd/argocd-ssh-known-hosts-cm created + │ ├─ kubernetes:core:ConfigMap argocd/argocd-cm created + │ ├─ kubernetes:core:Service argocd/argocd-repo-server created + │ ├─ kubernetes:core:Service argocd/argocd-application-controller created + │ ├─ kubernetes:rbac.authorization.k8s.io:ClusterRole argocd-application-controller created + │ ├─ kubernetes:core:Service argocd/argocd-dex-server created + │ ├─ kubernetes:core:ServiceAccount argocd/argocd-application-controller created + │ ├─ kubernetes:core:Secret argocd/argocd-secret created + │ ├─ kubernetes:rbac.authorization.k8s.io:Role argocd/argocd-server created + │ ├─ kubernetes:rbac.authorization.k8s.io:ClusterRoleBinding argocd-server created + │ ├─ kubernetes:core:Service argocd/argocd-server created + │ ├─ kubernetes:rbac.authorization.k8s.io:ClusterRole argocd-server created + │ ├─ kubernetes:rbac.authorization.k8s.io:RoleBinding argocd/argocd-application-controller created + │ ├─ kubernetes:rbac.authorization.k8s.io:Role argocd/argocd-dex-server created + │ ├─ kubernetes:rbac.authorization.k8s.io:RoleBinding argocd/argocd-dex-server created + │ ├─ kubernetes:rbac.authorization.k8s.io:Role argocd/argocd-application-controller created + │ ├─ kubernetes:rbac.authorization.k8s.io:RoleBinding argocd/argocd-server created + │ ├─ kubernetes:rbac.authorization.k8s.io:ClusterRoleBinding argocd-application-controller created + │ ├─ kubernetes:apps:Deployment argocd/argocd-server created + │ ├─ kubernetes:apps:Deployment argocd/argocd-application-controller created + │ ├─ kubernetes:apps:Deployment argocd/argocd-dex-server created + │ ├─ kubernetes:apps:Deployment argocd/argocd-repo-server created + │ ├─ kubernetes:apps:Deployment argocd/argocd-redis created + │ ├─ kubernetes:apiextensions.k8s.io:CustomResourceDefinition appprojects.argoproj.io created 1 warning + │ └─ kubernetes:apiextensions.k8s.io:CustomResourceDefinition applications.argoproj.io created 1 warning + ├─ pulumi:providers:kubernetes k8s created + └─ kubernetes:core:Namespace argocd-ns created Outputs: url: \u0026#34;http://ae7c37b7c510511eab4540a6f2211784-521581596.us-west-2.elb.amazonaws.com:80\u0026#34; Resources: + 34 created Duration: 1m3s Permalink: https://app.pulumi.com/workshops/argocd/dev/updates/1 In order to check that everything has been deployed as expected, list the pods in your namespace:\nkubectl get pods --namespace argocd And you should see a number of pods:\nNAME READY STATUS RESTARTS AGE argocd-application-controller-64db95fccd-jkstk 1/1 Running 0 108s argocd-dex-server-6b9cbf5598-znfpk 1/1 Running 0 108s argocd-redis-6b7b6b766b-dkphm 1/1 Running 0 107s argocd-repo-server-7c9d75b48-tg5r8 1/1 Running 0 107s argocd-server-7778cdd5-5f5vd 1/1 Running 1 109s The initial password for the ArgoCD server UI is the name of the pod that is running the application. Grab the name from the post list e.g. argocd-server-7778cdd5-5f5vd. We can use the username admin to go with this.\nOpen the URL from the pulumi output in a browser and you can log in with this username and password combination\n"
},
{
	"uri": "//localhost:1313/en/additional-content/160_gitops_for_socks_shop/40_deploy_our_application.html",
	"title": "Deploying our Application Stack",
	"tags": [],
	"description": "",
	"content": "First, add the StackReferences to the cluster and argoCD stacks, which will be used to get the kubeconfig and argocd namespace from their stack outputs.\npulumi config set clusterStackRef workshops/eks-infrastructure/dev pulumi config set argoCDStackRef workshops/argocd/dev Now we can deploy Everything:\npulumi up This will show you a preview and, after selecting yes, the application will be deployed:\nUpdating (dev): Type Name Status + pulumi:pulumi:Stack socks-shop-dev created + ├─ pulumi:providers:kubernetes k8sProvider created + └─ kubernetes:core:Namespace sock-shop-ns created + └─ kubernetes:argoproj.io:Application sock-shop created Resources: + 4 created Duration: 25s Permalink: https://app.pulumi.com/workshops/sock-shop/dev/updates/1 In order to check that everything has been deployed as expected, list the pods in your namespace:\nkubectl get svc -n sock-shop And you should see a number of pods:\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE carts-db ClusterIP 172.20.185.23 \u0026lt;none\u0026gt; 27017/TCP 46s catalogue ClusterIP 172.20.219.245 \u0026lt;none\u0026gt; 80/TCP 45s catalogue-db ClusterIP 172.20.242.113 \u0026lt;none\u0026gt; 3306/TCP 45s front-end LoadBalancer 172.20.224.217 a001d1dfbb58d44bf9c990602afcca1f-1776126796.us-west-2.elb.amazonaws.com 80:30001/TCP 46s orders ClusterIP 172.20.130.169 \u0026lt;none\u0026gt; 80/TCP 46s orders-db ClusterIP 172.20.118.187 \u0026lt;none\u0026gt; 27017/TCP 45s payment ClusterIP 172.20.113.41 \u0026lt;none\u0026gt; 80/TCP 46s queue-master ClusterIP 172.20.247.113 \u0026lt;none\u0026gt; 80/TCP 45s rabbitmq ClusterIP 172.20.62.136 \u0026lt;none\u0026gt; 5672/TCP,9090/TCP 45s session-db ClusterIP 172.20.58.212 \u0026lt;none\u0026gt; 6379/TCP 45s shipping ClusterIP 172.20.122.90 \u0026lt;none\u0026gt; 80/TCP 46s user ClusterIP 172.20.178.186 \u0026lt;none\u0026gt; 80/TCP 45s user-db ClusterIP 172.20.109.34 \u0026lt;none\u0026gt; 27017/TCP 45s We can use the url attached to the front-end LoadBalancer to view the application via our browser. Please note the url is http NOT https.\nWe can also see how the deployment looks in our ArgoCD instance https://\u0026lt;ARGOURL\u0026gt;/applications/sock-shop.\n"
},
{
	"uri": "//localhost:1313/en/additional-content/120_serverless_application_patterns/40_deploying_our_infrastructure.html",
	"title": "Deploying Our Infrastructure",
	"tags": [],
	"description": "",
	"content": "To provision our infrastructure, run:\npulumi up After confirming, you will see output like the following:\nUpdating (dev): Type Name Status + pulumi:pulumi:Stack serverless-demo-dev created + ├─ aws:apigateway:x:API site created + │ ├─ aws:apigateway:RestApi site created + │ ├─ aws:apigateway:Deployment site created + │ ├─ aws:lambda:Permission site-fa520765 created + │ └─ aws:apigateway:Stage site created + ├─ aws:dynamodb:Table hits created + ├─ aws:iam:Role handler-role created + ├─ aws:iam:RolePolicy handler-policy created + └─ aws:lambda:Function get-handler created Outputs: url: \u0026#34;https://02fpixl9jf.execute-api.us-west-2.amazonaws.com/stage/\u0026#34; Resources: + 10 created Duration: 45s After provisioning, you can access your new site at the resulting URL. For fun, curl it a few times:\nfor i in {1..5}; do curl $(pulumi stack output url); done Notice that the counter increases:\n\u0026lt;h1\u0026gt;Welcome to ACMECorp!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;1 hits.\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;Welcome to ACMECorp!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;2 hits.\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;Welcome to ACMECorp!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;3 hits.\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;Welcome to ACMECorp!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;4 hits.\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;Welcome to ACMECorp!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;5 hits.\u0026lt;/p\u0026gt; "
},
{
	"uri": "//localhost:1313/en/additional-content/100_provision_ec2_virtual_machines/40_destroying_your_infrastructure.html",
	"title": "Destroying Your Infrastructure",
	"tags": [],
	"description": "",
	"content": "Finally, destroy the resources and the stack itself to ensure no unnecessary costs occur:\npulumi destroy pulumi stack rm "
},
{
	"uri": "//localhost:1313/en/additional-content/110_deploying_containers_to_ecs/40_destroying_your_infrastructure.html",
	"title": "Destroying Your Infrastructure",
	"tags": [],
	"description": "",
	"content": "Finally, destroy the resources and the stack itself to ensure no unnecessary costs occur:\npulumi destroy pulumi stack rm "
},
{
	"uri": "//localhost:1313/en/10_prerequisites/50_workshop_setup.html",
	"title": "Install Pulumi &amp; Language Dependencies",
	"tags": [],
	"description": "",
	"content": "These hands-on labs will walk you through various cloud infrastructure tasks. The prerequisites listed below are required to successfully complete them.\nPulumi In order to run this workshop you will need to work with the Pulumi CLI.\nYou will use Pulumi to deploy infrastructure changes using code.\nTo install Pulumi run the following command:\ncurl -fsSL https://get.pulumi.com | sh source ~/.bashrc Now restart your Cloud 9 terminal\nAfter installing the CLI, verify that it is working:\n$ pulumi version v2.8.0 If the Pulumi command isn\u0026rsquo;t recognized yet, You should close and relaunch the terminal window first.\nYou\u0026rsquo;ll also need to login to Pulumi to manage the storage of your infrastructure state. Run pulumi login:\n$ pulumi login Manage your Pulumi stacks by logging in. Run `pulumi login --help` for alternative login options. Enter your access token from https://app.pulumi.com/account/tokens or hit \u0026lt;ENTER\u0026gt; to log in using your browser : Then click on the https://app.pulumi.com/account/tokens URL. If you have not yet signed up for a Pulumi account, login with your email, GitHub or other identity. After logging in, you will see the screen below.\nClick \u0026ldquo;NEW ACCESS TOKEN\u0026rdquo; and create a new accesss token. Copy that token and paste it into the prompt in your Cloud 9 terminal. If succesful, you will see this.\nWelcome to Pulumi! Pulumi helps you create, deploy, and manage infrastructure on any cloud using your favorite language. You can get started today with Pulumi at: https://www.pulumi.com/docs/get-started/ Tip of the day: Resources you create with Pulumi are given unique names (a randomly generated suffix) by default. To learn more about auto-naming or customizing resource names see https://www.pulumi.com/docs/intro/concepts/programming-model/#autonaming. Logged in to pulumi.com as nabohekul (https://app.pulumi.com/nabohekul) Note: If you are unable to sign in to the Pulumi Service, you can still complete the workshop by using pulumi login --local. However, some features highlighted in the workshop won\u0026rsquo;t be available if you use this option.\nNode.js If you are not running this workshop from Cloud9 you will need to install Node.js.\nYou will need Node.js version 10 or later to run Pulumi programs written in TypeScript. Install your desired LTS version from the Node.js download page or using a package manager.\nAfter installing, verify that Node.js is working:\n$ node --version v12.10.0 Also verify that the Node Package Manager (NPM) is working:\n$ npm --version 6.10.3 Docker If you are not running this workshop from Cloud9 you will need to install Docker.\nIf you will be completing the container labs, install Docker Community Edition. After doing so, verify that the docker CLI is operational:\n$ docker --version Docker version 19.03.1, build 74b1e89 Kubectl If you will be completing the Kubernetes labs, install the kubectl CLI. It isn\u0026rsquo;t necessary to configure it to speak to a cluster — you will do that during the appropriate labs that require it.\nDownload the latest release:\ncurl -LO \u0026#34;https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl\u0026#34; Make the kubetcl binary executable:\nchmod +x ./kubectl Move the binary into your path:\nsudo mv ./kubectl /usr/local/bin/kubectl Test to ensure the version you installed is up to date:\nkubectl version --client AWS Subscription and CLI At various points, you will use the AWS CLI to interact with infrastructure you\u0026rsquo;ve provisioned. Installation instructions are available here. As explained further on that page, the CLI requires Python.\nIf you have multiple AWS accounts, you\u0026rsquo;ll need to configure a profile for the account you\u0026rsquo;re using in these labs. That process is described here. All Pulumi operations will respect your profile settings.\nTo verify that everything is working, run:\naws sts get-caller-identity { \u0026#34;UserId\u0026#34;: \u0026#34;ABDAII73ZGOGZ5V4QSTWY\u0026#34;, \u0026#34;Account\u0026#34;: \u0026#34;161298451113\u0026#34;, \u0026#34;Arn\u0026#34;: \u0026#34;arn:aws:iam::161298451113:user/joe@pulumi.com\u0026#34; } "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/40_deploying_applications_to_eks.html",
	"title": "Module 03",
	"tags": [],
	"description": "",
	"content": "Deploying Applications to Amazon EKS You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will deploy an application to a Kubernetes cluster in EKS.\nThis lab assumes you have a Kubernetes cluster up and running. If you don\u0026rsquo;t have a cluster yet, please complete deploying_eks_cluster lab first.\n3.1 Creating a New Project 3.2 Use an Existing Kubernetes Cluster 3.3 Creating a Namespace 3.4 Declare an Application Deployment Object 3.5 Declare an Application Service Object 3.6 Deploying our Application Stack 3.7 Update Application Version 3.8 Destroying Your Infrastructure "
},
{
	"uri": "//localhost:1313/en/25_intro_modern_iac_python/40_ecs.html",
	"title": "Module 03: Docker &amp; Amazon ECS on AWS Fargate",
	"tags": [],
	"description": "",
	"content": "Deploying Docker Images to Amazon ECS on AWS Fargate You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will use Pulumi to deploy a Docker image to Amazon ECS on AWS Fargate\n3.1 Creating a New Project 3.2 Installing and Configuring the AWS and AWSX Providers 3.3 Create a VPC, ECS Cluster, \u0026amp; Load Balancer 3.4 Deploy a Fargate Service "
},
{
	"uri": "//localhost:1313/en/30_intro_modern_iac_java/40_ecs.html",
	"title": "Module 03: Docker &amp; ECS",
	"tags": [],
	"description": "",
	"content": "Deploying Docker Images to ECS \u0026amp; Fargate You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will use Pulumi to deploy a Docker Image to ECS with Fargate\n1.1 Creating a New Project 1.2 Configuring AWS 3.2 Create an ECS Cluster \u0026amp; LoadBalancer 3.3 Deploy a Docker Image "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/45_componens.html",
	"title": "Module 04",
	"tags": [],
	"description": "",
	"content": "Creating Infrastructure Components - Kubernetes You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will extract a common Kubernetes infrastructure of creating both a Deployment and a Service pattern into a reusable ServiceDeployment component.\nThis lab builds on the final state of the deploying_applications_to_eks lab, so you are encouraged to do that lab first.\nThis lab assumes you have a Kubernetes cluster up and running. If you don\u0026rsquo;t have a cluster yet, please complete deploying_eks_cluster lab first.\n4.1 Creating a New Project 4.2 Create a ComponentResource 4.3 Use our Component 4.4 Deploying our Application Stack 4.5 Destroying Your Infrastructure "
},
{
	"uri": "//localhost:1313/en/40_lambda_microservices_ts/40_container_thumbnailer/40_s3_website.html",
	"title": "3.5 Make a thumbnail website",
	"tags": [],
	"description": "",
	"content": "The final step is to make a website to display our images. We can use S3\u0026rsquo;s static content host for this.\nStep 1 — Add a bucket policy Add the following to your index.ts file:\nconst bucketPolicy = new aws.s3.BucketPolicy(\u0026#34;thumbnailer\u0026#34;, { bucket: bucket.id, policy: bucket.arn.apply(arn =\u0026gt; JSON.stringify({ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [{ \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:*\u0026#34; ], \u0026#34;Resource\u0026#34;: [ `${arn}/*`, `${arn}` ] }] })) }) The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; const image = awsx.ecr.buildAndPushImage(\u0026#34;thumbnailer\u0026#34;, { context: \u0026#34;./app\u0026#34;, }); // A bucket to store videos and thumbnails. const bucket = new aws.s3.Bucket(\u0026#34;thumbnailer\u0026#34;, { forceDestroy: true, }); const bucketPolicy = new aws.s3.BucketPolicy(\u0026#34;thumbnailer\u0026#34;, { bucket: bucket.id, policy: bucket.arn.apply(arn =\u0026gt; JSON.stringify({ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [{ \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:*\u0026#34; ], \u0026#34;Resource\u0026#34;: [ `${arn}/*`, `${arn}` ] }] })) }) const role = new aws.iam.Role(\u0026#34;thumbnailerRole\u0026#34;, { assumeRolePolicy: aws.iam.assumeRolePolicyForPrincipal({ Service: \u0026#34;lambda.amazonaws.com\u0026#34; }), }); const lambdaFullAccess = new aws.iam.RolePolicyAttachment(\u0026#34;lambdaFullAccess\u0026#34;, { role: role.name, policyArn: aws.iam.ManagedPolicy.LambdaFullAccess, }); const lambdaBasicExecutionRole = new aws.iam.RolePolicyAttachment(\u0026#34;basicExecutionRole\u0026#34;, { role: role.name, policyArn: aws.iam.ManagedPolicy.AWSLambdaBasicExecutionRole, }); const thumbnailer = new aws.lambda.Function(\u0026#34;thumbnailer\u0026#34;, { packageType: \u0026#34;Image\u0026#34;, imageUri: image.imageValue, role: role.arn, timeout: 900, }); // When a new video is uploaded, run the FFMPEG task on the video file. // Use the time index specified in the filename (e.g. cat_00-01.mp4 uses timestamp 00:01) bucket.onObjectCreated(\u0026#34;onNewVideo\u0026#34;, thumbnailer, { filterSuffix: \u0026#34;.mp4\u0026#34; }); // When a new thumbnail is created, log a message. bucket.onObjectCreated(\u0026#34;onNewThumbnail\u0026#34;, new aws.lambda.CallbackFunction\u0026lt;aws.s3.BucketEvent, void\u0026gt;(\u0026#34;onNewThumbnail\u0026#34;, { callback: async bucketArgs =\u0026gt; { console.log(\u0026#34;onNewThumbnail called\u0026#34;); if (!bucketArgs.Records) { return; } for (const record of bucketArgs.Records) { console.log(`*** New thumbnail: file ${record.s3.object.key} was saved at ${record.eventTime}.`); } }, policies: [ aws.iam.ManagedPolicy.LambdaFullAccess, // Provides wide access to \u0026#34;serverless\u0026#34; services (Dynamo, S3, etc.) aws.iam.ManagedPolicy.AWSLambdaBasicExecutionRole, ], }), { filterSuffix: \u0026#34;.jpg\u0026#34; }); export const bucketName = bucket.id; Step 2 — Make the S3 Bucket a Static Website Now we need to update our bucket to add a parameter\nUpdate your bucket resource with the following in your index.ts file:\nconst bucket = new aws.s3.Bucket(\u0026#34;thumbnailer\u0026#34;, { forceDestroy: true, website: { indexDocument: \u0026#34;cat.jpg\u0026#34;, } }); Also, make sure you export the website url:\nexport const url = bucket.websiteEndpoint The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; const image = awsx.ecr.buildAndPushImage(\u0026#34;thumbnailer\u0026#34;, { context: \u0026#34;./app\u0026#34;, }); // A bucket to store videos and thumbnails. const bucket = new aws.s3.Bucket(\u0026#34;thumbnailer\u0026#34;, { forceDestroy: true, website: { indexDocument: \u0026#34;cat.jpg\u0026#34;, } }); const bucketPolicy = new aws.s3.BucketPolicy(\u0026#34;thumbnailer\u0026#34;, { bucket: bucket.id, policy: bucket.arn.apply(arn =\u0026gt; JSON.stringify({ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [{ \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:*\u0026#34; ], \u0026#34;Resource\u0026#34;: [ `${arn}/*`, `${arn}` ] }] })) }) const role = new aws.iam.Role(\u0026#34;thumbnailerRole\u0026#34;, { assumeRolePolicy: aws.iam.assumeRolePolicyForPrincipal({ Service: \u0026#34;lambda.amazonaws.com\u0026#34; }), }); const lambdaFullAccess = new aws.iam.RolePolicyAttachment(\u0026#34;lambdaFullAccess\u0026#34;, { role: role.name, policyArn: aws.iam.ManagedPolicy.LambdaFullAccess, }); const lambdaBasicExecutionRole = new aws.iam.RolePolicyAttachment(\u0026#34;basicExecutionRole\u0026#34;, { role: role.name, policyArn: aws.iam.ManagedPolicy.AWSLambdaBasicExecutionRole, }); const thumbnailer = new aws.lambda.Function(\u0026#34;thumbnailer\u0026#34;, { packageType: \u0026#34;Image\u0026#34;, imageUri: image.imageValue, role: role.arn, timeout: 900, }); // When a new video is uploaded, run the FFMPEG task on the video file. // Use the time index specified in the filename (e.g. cat_00-01.mp4 uses timestamp 00:01) bucket.onObjectCreated(\u0026#34;onNewVideo\u0026#34;, thumbnailer, { filterSuffix: \u0026#34;.mp4\u0026#34; }); // When a new thumbnail is created, log a message. bucket.onObjectCreated(\u0026#34;onNewThumbnail\u0026#34;, new aws.lambda.CallbackFunction\u0026lt;aws.s3.BucketEvent, void\u0026gt;(\u0026#34;onNewThumbnail\u0026#34;, { callback: async bucketArgs =\u0026gt; { console.log(\u0026#34;onNewThumbnail called\u0026#34;); if (!bucketArgs.Records) { return; } for (const record of bucketArgs.Records) { console.log(`*** New thumbnail: file ${record.s3.object.key} was saved at ${record.eventTime}.`); } }, policies: [ aws.iam.ManagedPolicy.LambdaFullAccess, // Provides wide access to \u0026#34;serverless\u0026#34; services (Dynamo, S3, etc.) aws.iam.ManagedPolicy.AWSLambdaBasicExecutionRole, ], }), { filterSuffix: \u0026#34;.jpg\u0026#34; }); export const bucketName = bucket.id; export const url = bucket.websiteEndpoint Step 3 — Provision your website At this stage we\u0026rsquo;re ready to provision our infrastructrue again. Run pulumi up and observe the resources we\u0026rsquo;re going to provision:\nUpdating (dev) View Live: https://app.pulumi.com/jaxxstorm/lambda-thumbnailer/dev/updates/9 Type Name Status Info pulumi:pulumi:Stack lambda-thumbnailer-dev ├─ awsx:ecr:Repository thumbnailer 1 warning + └─ aws:s3:BucketPolicy thumbnailer created Diagnostics: awsx:ecr:Repository (thumbnailer): warning: WARNING! Your password will be stored unencrypted in /home/ec2-user/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Outputs: bucketName: \u0026#34;thumbnailer-8414171\u0026#34; url : \u0026#34;thumbnailer-8414171.s3-website-us-west-2.amazonaws.com\u0026#34; Resources: + 1 created 16 unchanged Hit yes and provision your infrastructure. You can now visit the chosen URL to see a lovely image of a cat.\nStep 4 — Destroy Everything Finally, destroy the resources and the stack itself:\npulumi destroy pulumi stack rm "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/40_deploying_applications_to_eks/50_deploy_our_application.html",
	"title": "3.6 Deploying our Application Stack",
	"tags": [],
	"description": "",
	"content": "First, add the StackReference to the cluster stack, which is used to get the kubeconfig from its stack output. This is a reference to the project created in the [previous lab].\npulumi config set clusterStackRef workshops/eks-infrastructure/dev Replace \u0026ldquo;workshops\u0026rdquo; from above command with your Pulumi username.\nDeploy Everything:\npulumi up This will show you a preview and, after selecting yes, the application will be deployed:\nUpdating (dev): Type Name Status + pulumi:pulumi:Stack eks-demo-apps-dev created + ├─ pulumi:providers:kubernetes k8sProvider created + ├─ kubernetes:core:Namespace eks-demo-apps-ns created + ├─ kubernetes:apps:Deployment eks-demo-apps-dep created + └─ kubernetes:core:Service eks-demo-apps-svc created Outputs: url: \u0026#34;http://ae7c37b7c510511eab4540a6f2211784-521581596.us-west-2.elb.amazonaws.com:80\u0026#34; Resources: + 5 created Duration: 32s Permalink: https://app.pulumi.com/workshops/eks-demo-apps/dev/updates/1 List the pods in your namespace, again replacing eks-demo-apps with the namespace you chose earlier:\nkubectl get pods --namespace eks-demo-apps And you should see a single replica:\nNAME READY STATUS RESTARTS AGE app-dep-9p399mj2-6c7cdd7d79-7w7vj 1/1 Running 0 0m15s "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/45_componens/50_deploy_our_application.html",
	"title": "4.4 Deploying our Application Stack",
	"tags": [],
	"description": "",
	"content": "We are ready to deploy Everything:\npulumi up This will show you a preview and, after selecting yes, the application will be deployed:\nUpdating (dev2): Type Name Status + pulumi:pulumi:Stack eks-apps-dev2 created + ├─ my:kubernetes:ServiceDeployment eks-demo-app created + │ ├─ kubernetes:core:Service app-svc created + │ └─ kubernetes:apps:Deployment eks-demos-app created + ├─ pulumi:providers:kubernetes k8sProvider created + └─ kubernetes:core:Namespace app-ns created Outputs: url: \u0026#34;http://a8bf84659dc8f4dd1b266e9711de3c2c-1478981199.us-west-2.elb.amazonaws.com:3000\u0026#34; Resources: + 6 created Duration: 15s Permalink: https://app.pulumi.com/workshops/eks-apps/dev2/updates/1 It will take a few seconds for the Load Balancer to be ready, but once it is, you can curl the url to see the same application running again:\n$ curl $(pulumi stack output url) Hello Kubernetes bootcamp! | Running on: eks-demos-app-07it3okr-7df9cddf49-974xn | v=2 We now have a reusable component we can use to deploy any Docker image we want in just a couple lines of code!\n"
},
{
	"uri": "//localhost:1313/en/50_eks_platform.html",
	"title": "Building a Kubernetes Platform in Amazon EKS (Multi-language)",
	"tags": [],
	"description": "",
	"content": "Building a Kubernetes Platform in Amazon EKS (Multi-language) Welcome Learning Objectives Getting started with Pulumi Provision an AWS VPC and Amazon EKS Cluster Provision the [AWS Ingress Controller](Building a Kubernetes Platform in Amazon EKS (Multi-languages)) Build \u0026amp; Deploy an Application to your EKS Cluster In this workshop, we have selected Kubernetes and Container technologies to demonstrate the strength of IaC. At the end of the workshop you can continue to the additional content section, where you can find more labs to explore other components to work with such as serverless and EC2.\nThe examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various cloud services can be used to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments. "
},
{
	"uri": "//localhost:1313/en/additional-content/150_deploying_argocd_to_eks.html",
	"title": "Deploying ArgoCD to Amazon EKS",
	"tags": [],
	"description": "",
	"content": "Deploying ArgoCD to Amazon EKS You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will deploy a Kubernetes cluster in EKS.\nThis lab assumes you have a project set up and a Kubernetes cluster up and running. If you don\u0026rsquo;t have a cluster yet, please complete deploying_eks_cluster lab first.\nCreating a New Project Use an Existing Kubernetes Cluster Creating a Namespace Declare an ArgoCD Helm Chart Object Deploying our Application Stack "
},
{
	"uri": "//localhost:1313/en/additional-content/120_serverless_application_patterns/50_inline_application_code.html",
	"title": "Replacing with Inline Code",
	"tags": [],
	"description": "",
	"content": "It\u0026rsquo;s possible to simplify this serverless application by moving the runtime code into the infrastructure definition. This isn\u0026rsquo;t always the right way to design your infrastructure as code, but for \u0026ldquo;fully serverless\u0026rdquo; applications like this one, where the boundary between application and infrastructure is intentionally blurred, this can be a great way to go.\nFirst, delete the IAM handlerRole and handlerPolicy definitions altogether.\nNext, replace your API Gateway site with the following code:\nconst site = new awsx.apigateway.API(\u0026#34;site\u0026#34;, { routes: [{ path: \u0026#34;/\u0026#34;, method: \u0026#34;GET\u0026#34;, eventHandler: async () =\u0026gt; { const dc = new AWS.DynamoDB.DocumentClient(); const result = await dc.update({ TableName: hits.name.get(), Key: { \u0026#34;Site\u0026#34;: \u0026#34;ACMECorp\u0026#34; }, UpdateExpression: \u0026#34;SET Hits = if_not_exists(Hits, :zero) + :incr\u0026#34;, ExpressionAttributeValues: { \u0026#34;:zero\u0026#34;: 0, \u0026#34;:incr\u0026#34;: 1 }, ReturnValues: \u0026#34;UPDATED_NEW\u0026#34;, }).promise(); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/html\u0026#34; }, body: \u0026#34;\u0026lt;h1\u0026gt;Welcome to ACMECorp!\u0026lt;/h1\u0026gt;\\n\u0026#34;+ `\u0026lt;p\u0026gt;${result.Attributes!.Hits} hits.\u0026lt;/p\u0026gt;\\n`, }; }, }], }); Remember to keep the line at the end to export the url. It is safe to also delete the handler/index.js file altogether now.\nThe index.ts file should now have the following contents:\nimport * as AWS from \u0026#34;aws-sdk\u0026#34;; import * as aws from \u0026#34;@pulumi/aws\u0026#34;; import * as awsx from \u0026#34;@pulumi/awsx\u0026#34;; import * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; const hits = new aws.dynamodb.Table(\u0026#34;hits\u0026#34;, { attributes: [{ name: \u0026#34;Site\u0026#34;, type: \u0026#34;S\u0026#34; }], hashKey: \u0026#34;Site\u0026#34;, billingMode: \u0026#34;PAY_PER_REQUEST\u0026#34;, }); const site = new awsx.apigateway.API(\u0026#34;site\u0026#34;, { routes: [{ path: \u0026#34;/\u0026#34;, method: \u0026#34;GET\u0026#34;, eventHandler: async () =\u0026gt; { const dc = new AWS.DynamoDB.DocumentClient(); const result = await dc.update({ TableName: hits.name.get(), Key: { \u0026#34;Site\u0026#34;: \u0026#34;ACMECorp\u0026#34; }, UpdateExpression: \u0026#34;SET Hits = if_not_exists(Hits, :zero) + :incr\u0026#34;, ExpressionAttributeValues: { \u0026#34;:zero\u0026#34;: 0, \u0026#34;:incr\u0026#34;: 1 }, ReturnValues: \u0026#34;UPDATED_NEW\u0026#34;, }).promise(); return { statusCode: 200, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/html\u0026#34; }, body: \u0026#34;\u0026lt;h1\u0026gt;Welcome to ACMECorp!\u0026lt;/h1\u0026gt;\\n\u0026#34;+ `\u0026lt;p\u0026gt;${result.Attributes!.Hits} hits.\u0026lt;/p\u0026gt;\\n`, }; }, }], }); export const url = site.url; Next, run an update:\npulumi up The output will look something like this:\nUpdating (dev): Type Name Status Info pulumi:pulumi:Stack serverless-demo-dev ├─ aws:apigateway:x:API site + │ ├─ aws:iam:Role site4c238266 created + │ ├─ aws:iam:RolePolicyAttachment site4c238266-32be53a2 created + │ ├─ aws:lambda:Function site4c238266 created ~ │ ├─ aws:apigateway:RestApi site updated [diff: ~body] +- │ ├─ aws:apigateway:Deployment site replaced [diff: ~variables] +- │ ├─ aws:lambda:Permission site-fa520765 replaced [diff: ~function] ~ │ └─ aws:apigateway:Stage site updated [diff: ~deployment] - ├─ aws:lambda:Function get-handler deleted - ├─ aws:iam:RolePolicy handler-policy deleted - └─ aws:iam:Role handler-role deleted Outputs: url: \u0026#34;https://02fpixl9jf.execute-api.us-west-2.amazonaws.com/stage/\u0026#34; Resources: + 3 created ~ 2 updated - 3 deleted +-2 replaced 10 changes. 3 unchanged Duration: 50s Now, curl the endpoint a few more times:\nfor i in {1..5}; do curl $(pulumi stack output url); done Notice that the counter increases:\n\u0026lt;h1\u0026gt;Welcome to ACMECorp!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;6 hits.\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;Welcome to ACMECorp!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;7 hits.\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;Welcome to ACMECorp!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;8 hits.\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;Welcome to ACMECorp!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;9 hits.\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;Welcome to ACMECorp!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;10 hits.\u0026lt;/p\u0026gt; Because we reused the same table from the prior update, the counter has continued where the prior commands left off.\n"
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/40_deploying_applications_to_eks/60_update_application_deployment.html",
	"title": "3.7 Update Application Version",
	"tags": [],
	"description": "",
	"content": "Next, you\u0026rsquo;ll make two changes to the application:\nScale out to 3 replicas, instead of just 1. Update the version of your application by changing its container image tag Note that the application says Hello Kubernetes bootcamp! | Running on: app-dep-9p399mj2-6c7cdd7d79-7w7vj | v=1. After deploying, this will change.\nFirst update your deployment\u0026rsquo;s configuration\u0026rsquo;s replica count:\nreplicas=3, And then update its image to:\nimage=\u0026#34;jocatalin/kubernetes-bootcamp:v2\u0026#34;, The index.ts file should now have the following contents:\nimport * as pulumi from \u0026#34;@pulumi/pulumi\u0026#34;; import * as k8s from \u0026#34;@pulumi/kubernetes\u0026#34;; const pulumiConfig = new pulumi.Config(); // Existing Pulumi stack reference in the format: // \u0026lt;organization\u0026gt;/\u0026lt;project\u0026gt;/\u0026lt;stack\u0026gt; e.g. \u0026#34;myUser/myProject/dev\u0026#34; const clusterStackRef = new pulumi.StackReference(pulumiConfig.require(\u0026#34;clusterStackRef\u0026#34;)); // Get the kubeconfig from the cluster stack output. const kubeconfig = clusterStackRef.getOutput(\u0026#34;kubeconfig\u0026#34;); // Create the k8s provider with the kubeconfig. const provider = new k8s.Provider(\u0026#34;k8sProvider\u0026#34;, { kubeconfig }); const ns = new k8s.core.v1.Namespace(\u0026#34;eks-demo-apps-ns\u0026#34;, { metadata: { name: \u0026#34;eks-demo-apps\u0026#34; }, }, { provider }); const appLabels = { app: \u0026#34;eks-demo-apps\u0026#34; }; const deployment = new k8s.apps.v1.Deployment(\u0026#34;eks-demo-apps-dep\u0026#34;, { metadata: { namespace: ns.metadata.name }, spec: { selector: { matchLabels: appLabels }, replicas: 3, template: { metadata: { labels: appLabels }, spec: { containers: [{ name: \u0026#34;eks-demo-apps\u0026#34;, image: \u0026#34;jocatalin/kubernetes-bootcamp:v2\u0026#34;, }], }, }, }, }, { provider }); const service = new k8s.core.v1.Service(\u0026#34;eks-demo-apps-svc\u0026#34;, { metadata: { namespace: ns.metadata.name }, spec: { selector: appLabels, ports: [{ port: 80, targetPort: 8080 }], type: \u0026#34;LoadBalancer\u0026#34;, }, }, { provider }); const address = service.status.loadBalancer.ingress[0].hostname; const port = service.spec.ports[0].port; export const url = pulumi.interpolate`http://${address}:${port}`; Deploy the changes:\npulumi up This will show you a preview and, after selecting yes, the application will be deployed:\nUpdating (dev): Type Name Status Info pulumi:pulumi:Stack eks-demo-apps-dev ~ └─ kubernetes:apps:Deployment eks-demo-apps-dep updated [diff: ~spec] Outputs: url: \u0026#34;http://ae7c37b7c510511eab4540a6f2211784-521581596.us-west-2.elb.amazonaws.com:80\u0026#34; Resources: ~ 1 updated 4 unchanged Duration: 29s Permalink: https://app.pulumi.com/workshops/eks-demo-apps/dev/updates/2 Query the pods again using your chosen namespace from earlier:\nkubectl get pods --namespace eks-demo-apps Check that there are now three:\nNAME READY STATUS RESTARTS AGE app-dep-9p399mj2-69c7fd4657-79wcp 1/1 Running 0 3m19s app-dep-9p399mj2-69c7fd4657-dlx4p 1/1 Running 0 3m16s app-dep-9p399mj2-69c7fd4657-mrvtt 1/1 Running 0 3m30s Finally, curl the endpoint again:\ncurl $(pulumi stack output url) And verify that the output now ends in v=2, instead of v=1 (the result of the new container image):\nHello Kubernetes bootcamp! | Running on: app-dep-8r1febnu-6cd57d964-c76rx | v=2 If you\u0026rsquo;d like, do it a few more times, and observe that traffic will be load balanced across the three pods:\nfor i in {0..10}; do curl $(pulumi stack output url); done "
},
{
	"uri": "//localhost:1313/en/additional-content/120_serverless_application_patterns/60_destroying_your_infrastructure.html",
	"title": "Destroying Your Infrastructure",
	"tags": [],
	"description": "",
	"content": "Finally, destroy the resources and the stack itself to ensure no unnecessary costs occur:\npulumi destroy pulumi stack rm "
},
{
	"uri": "//localhost:1313/en/additional-content/160_gitops_for_socks_shop.html",
	"title": "GitOps for Socks Shop",
	"tags": [],
	"description": "",
	"content": "Using GitOps to Deploy the Socks Shop Demo You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will deploy a Kubernetes cluster in EKS.\nThis lab assumes you have a project set up and a Kubernetes cluster up and running. If you don\u0026rsquo;t have a cluster yet, please complete deploying_eks_cluster lab first.\nCreating a New Project Use an Existing Kubernetes Cluster Creating a Namespace Declare a Sock Shop Custom Resource Deploying our Application Stack "
},
{
	"uri": "//localhost:1313/en/60_policy_as_code.html",
	"title": "Policy as Code (Python)",
	"tags": [],
	"description": "",
	"content": "Policy as Code Learning Objectives In this self-guided workshop, you\u0026rsquo;ll learn the following:\nThe fundamentals of policy as code How to author your own policy packs in Pulumi with Python How to publish and administer policy packs in the Pulumi service for integrated, organization-wide enforcement This workshop assumes basic familiarity with authoring infrastructure in Pulumi.\nPre-requisites You\u0026rsquo;ll need the following to complete this workshop:\nA Pulumi account and token. If you don\u0026rsquo;t have an account, go to the signup page. The Pulumi CLI Python 3.9 or later The examples and sample code provided in this workshop are intended to be consumed as instructional content. These examples will help you develop compliant and secure infrastructure while demonstrating best practices along the way, but are not intended for use in production environments. "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/40_deploying_applications_to_eks/70_destroying_your_infrastructure.html",
	"title": "3.8 Destroying Your Infrastructure",
	"tags": [],
	"description": "",
	"content": "Finally, destroy the resources and the stack itself to ensure no unnecessary costs occur:\npulumi destroy pulumi stack rm "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/45_componens/70_destroying_your_infrastructure.html",
	"title": "4.5 Destroying Your Infrastructure",
	"tags": [],
	"description": "",
	"content": "Finally, destroy the resources and the stack itself to ensure no unnecessary costs occur:\npulumi destroy pulumi stack rm "
},
{
	"uri": "//localhost:1313/en/20_intro_modern_iac_ts/70_destroying_our_infrastructure.html",
	"title": "Destroying our Infrastructure",
	"tags": [],
	"description": "",
	"content": "Destroying our Infrastructure Please remember to destroy all of the infrastructure you have created in each of the projects. Starting with sock-shop, then argocd and lastly eks-infrastructure run the following commands:\npulumi destroy pulumi stack rm "
},
{
	"uri": "//localhost:1313/en/additional-content.html",
	"title": "Additional Content",
	"tags": ["additional-content"],
	"description": "",
	"content": "Additional Content "
},
{
	"uri": "//localhost:1313/en/additional-content/100_provision_ec2_virtual_machines.html",
	"title": "Provision EC2 Virtual Machines",
	"tags": [],
	"description": "",
	"content": "Provision EC2 Virtual Machines You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you\u0026rsquo;ll first create a single EC2 virtual machine (VM). Afterwards, you\u0026rsquo;ll scale that out to a VM per availability zone in your region, and then add a load balancer to spread load across the entire fleet.\nCreating a New Project Creating a VM Creating Multiple VMs Loadbalancing the VMs Destroying Your Infrastructure "
},
{
	"uri": "//localhost:1313/en/additional-content/110_deploying_containers_to_ecs.html",
	"title": "Deploying Containers to ECS",
	"tags": [],
	"description": "",
	"content": "Deploying Containers to Amazon ECS You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will deploy a containerized application to an AWS ECS cluster.\nCreating a New Project Creating an AWS ECS Cluster Creating an ECS Loadbalanced Service Build and Publish A Custom Container Destroying Your Infrastructure "
},
{
	"uri": "//localhost:1313/en/additional-content/120_serverless_application_patterns.html",
	"title": "Lambda for Serverless Application Patterns",
	"tags": [],
	"description": "",
	"content": "Using AWS Lambda for Serverless Application Patterns You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\nIn this lab, you will create a serverless web application that uses API Gateway and Lambda, along with a dynamic DynamoDB-based hit counter.\nCreating a New Project Creating a DynamoDB Table Creating IAM Policies Creating an API Gateway Deploying Our Infrastructure Replacing with Inline Code Destroying Your Infrastructure "
},
{
	"uri": "//localhost:1313/en/tags/additional-content.html",
	"title": "Additional-Content",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/en/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/en/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]